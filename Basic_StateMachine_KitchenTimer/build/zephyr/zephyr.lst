
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_start>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   0:	20000708 	.word	0x20000708
   4:	000016f1 	.word	0x000016f1
}
   8:	000044bd 	.word	0x000044bd
   c:	00001685 	.word	0x00001685
	...
  2c:	000014f1 	.word	0x000014f1
	...
  38:	00001489 	.word	0x00001489
  3c:	00000000 	.word	0x00000000

00000040 <_irq_vector_table>:
  40:	00001565 00001565 00001565 00001565     e...e...e...e...
  50:	00001565 00001565 00001565 00001565     e...e...e...e...
  60:	00001565 00001565 00001565 00001565     e...e...e...e...
  70:	00001565 00001565 00001565 00001565     e...e...e...e...
  80:	00001565 00001565 00001565 00001565     e...e...e...e...
  90:	00001565 00001565 00001565 00001565     e...e...e...e...
  a0:	00001565 00001565                       e...e...

Disassembly of section text:

000000a8 <__aeabi_idiv0>:
      a8:	4770      	bx	lr
      aa:	46c0      	nop			; (mov r8, r8)

000000ac <__clzsi2>:
      ac:	211c      	movs	r1, #28
      ae:	2301      	movs	r3, #1
      b0:	041b      	lsls	r3, r3, #16
      b2:	4298      	cmp	r0, r3
      b4:	d301      	bcc.n	ba <__clzsi2+0xe>
      b6:	0c00      	lsrs	r0, r0, #16
      b8:	3910      	subs	r1, #16
      ba:	0a1b      	lsrs	r3, r3, #8
      bc:	4298      	cmp	r0, r3
      be:	d301      	bcc.n	c4 <__clzsi2+0x18>
      c0:	0a00      	lsrs	r0, r0, #8
      c2:	3908      	subs	r1, #8
      c4:	091b      	lsrs	r3, r3, #4
      c6:	4298      	cmp	r0, r3
      c8:	d301      	bcc.n	ce <__clzsi2+0x22>
      ca:	0900      	lsrs	r0, r0, #4
      cc:	3904      	subs	r1, #4
      ce:	a202      	add	r2, pc, #8	; (adr r2, d8 <__clzsi2+0x2c>)
      d0:	5c10      	ldrb	r0, [r2, r0]
      d2:	1840      	adds	r0, r0, r1
      d4:	4770      	bx	lr
      d6:	46c0      	nop			; (mov r8, r8)
      d8:	02020304 	.word	0x02020304
      dc:	01010101 	.word	0x01010101
	...

000000e8 <__aeabi_uldivmod>:
      e8:	2b00      	cmp	r3, #0
      ea:	d111      	bne.n	110 <CONFIG_FLASH_SIZE+0x10>
      ec:	2a00      	cmp	r2, #0
      ee:	d10f      	bne.n	110 <CONFIG_FLASH_SIZE+0x10>
      f0:	2900      	cmp	r1, #0
      f2:	d100      	bne.n	f6 <__aeabi_uldivmod+0xe>
      f4:	2800      	cmp	r0, #0
      f6:	d002      	beq.n	fe <__aeabi_uldivmod+0x16>
      f8:	2100      	movs	r1, #0
      fa:	43c9      	mvns	r1, r1
      fc:	1c08      	adds	r0, r1, #0
      fe:	b407      	push	{r0, r1, r2}
     100:	4802      	ldr	r0, [pc, #8]	; (10c <CONFIG_FLASH_SIZE+0xc>)
     102:	a102      	add	r1, pc, #8	; (adr r1, 10c <CONFIG_FLASH_SIZE+0xc>)
     104:	1840      	adds	r0, r0, r1
     106:	9002      	str	r0, [sp, #8]
     108:	bd03      	pop	{r0, r1, pc}
     10a:	46c0      	nop			; (mov r8, r8)
     10c:	ffffff9d 	.word	0xffffff9d
     110:	b403      	push	{r0, r1}
     112:	4668      	mov	r0, sp
     114:	b501      	push	{r0, lr}
     116:	9802      	ldr	r0, [sp, #8]
     118:	f000 f82e 	bl	178 <__udivmoddi4>
     11c:	9b01      	ldr	r3, [sp, #4]
     11e:	469e      	mov	lr, r3
     120:	b002      	add	sp, #8
     122:	bc0c      	pop	{r2, r3}
     124:	4770      	bx	lr
     126:	46c0      	nop			; (mov r8, r8)

00000128 <__aeabi_lmul>:
     128:	b5f0      	push	{r4, r5, r6, r7, lr}
     12a:	0415      	lsls	r5, r2, #16
     12c:	0c2d      	lsrs	r5, r5, #16
     12e:	000f      	movs	r7, r1
     130:	0001      	movs	r1, r0
     132:	002e      	movs	r6, r5
     134:	46c6      	mov	lr, r8
     136:	4684      	mov	ip, r0
     138:	0400      	lsls	r0, r0, #16
     13a:	0c14      	lsrs	r4, r2, #16
     13c:	0c00      	lsrs	r0, r0, #16
     13e:	0c09      	lsrs	r1, r1, #16
     140:	4346      	muls	r6, r0
     142:	434d      	muls	r5, r1
     144:	4360      	muls	r0, r4
     146:	4361      	muls	r1, r4
     148:	1940      	adds	r0, r0, r5
     14a:	0c34      	lsrs	r4, r6, #16
     14c:	1824      	adds	r4, r4, r0
     14e:	b500      	push	{lr}
     150:	42a5      	cmp	r5, r4
     152:	d903      	bls.n	15c <__aeabi_lmul+0x34>
     154:	2080      	movs	r0, #128	; 0x80
     156:	0240      	lsls	r0, r0, #9
     158:	4680      	mov	r8, r0
     15a:	4441      	add	r1, r8
     15c:	0c25      	lsrs	r5, r4, #16
     15e:	186d      	adds	r5, r5, r1
     160:	4661      	mov	r1, ip
     162:	4359      	muls	r1, r3
     164:	437a      	muls	r2, r7
     166:	0430      	lsls	r0, r6, #16
     168:	1949      	adds	r1, r1, r5
     16a:	0424      	lsls	r4, r4, #16
     16c:	0c00      	lsrs	r0, r0, #16
     16e:	1820      	adds	r0, r4, r0
     170:	1889      	adds	r1, r1, r2
     172:	bc04      	pop	{r2}
     174:	4690      	mov	r8, r2
     176:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000178 <__udivmoddi4>:
     178:	b5f0      	push	{r4, r5, r6, r7, lr}
     17a:	4657      	mov	r7, sl
     17c:	464e      	mov	r6, r9
     17e:	4645      	mov	r5, r8
     180:	46de      	mov	lr, fp
     182:	b5e0      	push	{r5, r6, r7, lr}
     184:	0004      	movs	r4, r0
     186:	000d      	movs	r5, r1
     188:	4692      	mov	sl, r2
     18a:	4699      	mov	r9, r3
     18c:	b083      	sub	sp, #12
     18e:	428b      	cmp	r3, r1
     190:	d830      	bhi.n	1f4 <__udivmoddi4+0x7c>
     192:	d02d      	beq.n	1f0 <__udivmoddi4+0x78>
     194:	4649      	mov	r1, r9
     196:	4650      	mov	r0, sl
     198:	f000 f8ba 	bl	310 <__clzdi2>
     19c:	0029      	movs	r1, r5
     19e:	0006      	movs	r6, r0
     1a0:	0020      	movs	r0, r4
     1a2:	f000 f8b5 	bl	310 <__clzdi2>
     1a6:	1a33      	subs	r3, r6, r0
     1a8:	4698      	mov	r8, r3
     1aa:	3b20      	subs	r3, #32
     1ac:	469b      	mov	fp, r3
     1ae:	d433      	bmi.n	218 <__udivmoddi4+0xa0>
     1b0:	465a      	mov	r2, fp
     1b2:	4653      	mov	r3, sl
     1b4:	4093      	lsls	r3, r2
     1b6:	4642      	mov	r2, r8
     1b8:	001f      	movs	r7, r3
     1ba:	4653      	mov	r3, sl
     1bc:	4093      	lsls	r3, r2
     1be:	001e      	movs	r6, r3
     1c0:	42af      	cmp	r7, r5
     1c2:	d83a      	bhi.n	23a <__udivmoddi4+0xc2>
     1c4:	42af      	cmp	r7, r5
     1c6:	d100      	bne.n	1ca <__udivmoddi4+0x52>
     1c8:	e078      	b.n	2bc <__udivmoddi4+0x144>
     1ca:	465b      	mov	r3, fp
     1cc:	1ba4      	subs	r4, r4, r6
     1ce:	41bd      	sbcs	r5, r7
     1d0:	2b00      	cmp	r3, #0
     1d2:	da00      	bge.n	1d6 <__udivmoddi4+0x5e>
     1d4:	e075      	b.n	2c2 <__udivmoddi4+0x14a>
     1d6:	2200      	movs	r2, #0
     1d8:	2300      	movs	r3, #0
     1da:	9200      	str	r2, [sp, #0]
     1dc:	9301      	str	r3, [sp, #4]
     1de:	2301      	movs	r3, #1
     1e0:	465a      	mov	r2, fp
     1e2:	4093      	lsls	r3, r2
     1e4:	9301      	str	r3, [sp, #4]
     1e6:	2301      	movs	r3, #1
     1e8:	4642      	mov	r2, r8
     1ea:	4093      	lsls	r3, r2
     1ec:	9300      	str	r3, [sp, #0]
     1ee:	e028      	b.n	242 <__udivmoddi4+0xca>
     1f0:	4282      	cmp	r2, r0
     1f2:	d9cf      	bls.n	194 <__udivmoddi4+0x1c>
     1f4:	2200      	movs	r2, #0
     1f6:	2300      	movs	r3, #0
     1f8:	9200      	str	r2, [sp, #0]
     1fa:	9301      	str	r3, [sp, #4]
     1fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     1fe:	2b00      	cmp	r3, #0
     200:	d001      	beq.n	206 <__udivmoddi4+0x8e>
     202:	601c      	str	r4, [r3, #0]
     204:	605d      	str	r5, [r3, #4]
     206:	9800      	ldr	r0, [sp, #0]
     208:	9901      	ldr	r1, [sp, #4]
     20a:	b003      	add	sp, #12
     20c:	bc3c      	pop	{r2, r3, r4, r5}
     20e:	4690      	mov	r8, r2
     210:	4699      	mov	r9, r3
     212:	46a2      	mov	sl, r4
     214:	46ab      	mov	fp, r5
     216:	bdf0      	pop	{r4, r5, r6, r7, pc}
     218:	4642      	mov	r2, r8
     21a:	2320      	movs	r3, #32
     21c:	1a9b      	subs	r3, r3, r2
     21e:	4652      	mov	r2, sl
     220:	40da      	lsrs	r2, r3
     222:	4641      	mov	r1, r8
     224:	0013      	movs	r3, r2
     226:	464a      	mov	r2, r9
     228:	408a      	lsls	r2, r1
     22a:	0017      	movs	r7, r2
     22c:	4642      	mov	r2, r8
     22e:	431f      	orrs	r7, r3
     230:	4653      	mov	r3, sl
     232:	4093      	lsls	r3, r2
     234:	001e      	movs	r6, r3
     236:	42af      	cmp	r7, r5
     238:	d9c4      	bls.n	1c4 <__udivmoddi4+0x4c>
     23a:	2200      	movs	r2, #0
     23c:	2300      	movs	r3, #0
     23e:	9200      	str	r2, [sp, #0]
     240:	9301      	str	r3, [sp, #4]
     242:	4643      	mov	r3, r8
     244:	2b00      	cmp	r3, #0
     246:	d0d9      	beq.n	1fc <__udivmoddi4+0x84>
     248:	07fb      	lsls	r3, r7, #31
     24a:	0872      	lsrs	r2, r6, #1
     24c:	431a      	orrs	r2, r3
     24e:	4646      	mov	r6, r8
     250:	087b      	lsrs	r3, r7, #1
     252:	e00e      	b.n	272 <__udivmoddi4+0xfa>
     254:	42ab      	cmp	r3, r5
     256:	d101      	bne.n	25c <__udivmoddi4+0xe4>
     258:	42a2      	cmp	r2, r4
     25a:	d80c      	bhi.n	276 <__udivmoddi4+0xfe>
     25c:	1aa4      	subs	r4, r4, r2
     25e:	419d      	sbcs	r5, r3
     260:	2001      	movs	r0, #1
     262:	1924      	adds	r4, r4, r4
     264:	416d      	adcs	r5, r5
     266:	2100      	movs	r1, #0
     268:	3e01      	subs	r6, #1
     26a:	1824      	adds	r4, r4, r0
     26c:	414d      	adcs	r5, r1
     26e:	2e00      	cmp	r6, #0
     270:	d006      	beq.n	280 <__udivmoddi4+0x108>
     272:	42ab      	cmp	r3, r5
     274:	d9ee      	bls.n	254 <__udivmoddi4+0xdc>
     276:	3e01      	subs	r6, #1
     278:	1924      	adds	r4, r4, r4
     27a:	416d      	adcs	r5, r5
     27c:	2e00      	cmp	r6, #0
     27e:	d1f8      	bne.n	272 <__udivmoddi4+0xfa>
     280:	9800      	ldr	r0, [sp, #0]
     282:	9901      	ldr	r1, [sp, #4]
     284:	465b      	mov	r3, fp
     286:	1900      	adds	r0, r0, r4
     288:	4169      	adcs	r1, r5
     28a:	2b00      	cmp	r3, #0
     28c:	db24      	blt.n	2d8 <__udivmoddi4+0x160>
     28e:	002b      	movs	r3, r5
     290:	465a      	mov	r2, fp
     292:	4644      	mov	r4, r8
     294:	40d3      	lsrs	r3, r2
     296:	002a      	movs	r2, r5
     298:	40e2      	lsrs	r2, r4
     29a:	001c      	movs	r4, r3
     29c:	465b      	mov	r3, fp
     29e:	0015      	movs	r5, r2
     2a0:	2b00      	cmp	r3, #0
     2a2:	db2a      	blt.n	2fa <__udivmoddi4+0x182>
     2a4:	0026      	movs	r6, r4
     2a6:	409e      	lsls	r6, r3
     2a8:	0033      	movs	r3, r6
     2aa:	0026      	movs	r6, r4
     2ac:	4647      	mov	r7, r8
     2ae:	40be      	lsls	r6, r7
     2b0:	0032      	movs	r2, r6
     2b2:	1a80      	subs	r0, r0, r2
     2b4:	4199      	sbcs	r1, r3
     2b6:	9000      	str	r0, [sp, #0]
     2b8:	9101      	str	r1, [sp, #4]
     2ba:	e79f      	b.n	1fc <__udivmoddi4+0x84>
     2bc:	42a3      	cmp	r3, r4
     2be:	d8bc      	bhi.n	23a <__udivmoddi4+0xc2>
     2c0:	e783      	b.n	1ca <__udivmoddi4+0x52>
     2c2:	4642      	mov	r2, r8
     2c4:	2320      	movs	r3, #32
     2c6:	2100      	movs	r1, #0
     2c8:	1a9b      	subs	r3, r3, r2
     2ca:	2200      	movs	r2, #0
     2cc:	9100      	str	r1, [sp, #0]
     2ce:	9201      	str	r2, [sp, #4]
     2d0:	2201      	movs	r2, #1
     2d2:	40da      	lsrs	r2, r3
     2d4:	9201      	str	r2, [sp, #4]
     2d6:	e786      	b.n	1e6 <__udivmoddi4+0x6e>
     2d8:	4642      	mov	r2, r8
     2da:	2320      	movs	r3, #32
     2dc:	1a9b      	subs	r3, r3, r2
     2de:	002a      	movs	r2, r5
     2e0:	4646      	mov	r6, r8
     2e2:	409a      	lsls	r2, r3
     2e4:	0023      	movs	r3, r4
     2e6:	40f3      	lsrs	r3, r6
     2e8:	4644      	mov	r4, r8
     2ea:	4313      	orrs	r3, r2
     2ec:	002a      	movs	r2, r5
     2ee:	40e2      	lsrs	r2, r4
     2f0:	001c      	movs	r4, r3
     2f2:	465b      	mov	r3, fp
     2f4:	0015      	movs	r5, r2
     2f6:	2b00      	cmp	r3, #0
     2f8:	dad4      	bge.n	2a4 <__udivmoddi4+0x12c>
     2fa:	4642      	mov	r2, r8
     2fc:	002f      	movs	r7, r5
     2fe:	2320      	movs	r3, #32
     300:	0026      	movs	r6, r4
     302:	4097      	lsls	r7, r2
     304:	1a9b      	subs	r3, r3, r2
     306:	40de      	lsrs	r6, r3
     308:	003b      	movs	r3, r7
     30a:	4333      	orrs	r3, r6
     30c:	e7cd      	b.n	2aa <__udivmoddi4+0x132>
     30e:	46c0      	nop			; (mov r8, r8)

00000310 <__clzdi2>:
     310:	b510      	push	{r4, lr}
     312:	2900      	cmp	r1, #0
     314:	d103      	bne.n	31e <__clzdi2+0xe>
     316:	f7ff fec9 	bl	ac <__clzsi2>
     31a:	3020      	adds	r0, #32
     31c:	e002      	b.n	324 <__clzdi2+0x14>
     31e:	1c08      	adds	r0, r1, #0
     320:	f7ff fec4 	bl	ac <__clzsi2>
     324:	bd10      	pop	{r4, pc}
     326:	46c0      	nop			; (mov r8, r8)

00000328 <z_impl_gpio_pin_configure>:
				 gpio_flags_t flags);

static inline int z_impl_gpio_pin_configure(const struct device *port,
					    gpio_pin_t pin,
					    gpio_flags_t flags)
{
     328:	b570      	push	{r4, r5, r6, lr}
     32a:	0013      	movs	r3, r2
	const struct gpio_driver_api *api =
     32c:	6885      	ldr	r5, [r0, #8]
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
     32e:	6904      	ldr	r4, [r0, #16]

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
		 != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
		 "Output cannot be initialized low and high");

	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
     330:	04da      	lsls	r2, r3, #19
     332:	d508      	bpl.n	346 <z_impl_gpio_pin_configure+0x1e>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
     334:	22c0      	movs	r2, #192	; 0xc0
     336:	0112      	lsls	r2, r2, #4
     338:	4213      	tst	r3, r2
     33a:	d004      	beq.n	346 <z_impl_gpio_pin_configure+0x1e>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
     33c:	07da      	lsls	r2, r3, #31
     33e:	d502      	bpl.n	346 <z_impl_gpio_pin_configure+0x1e>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
     340:	22c0      	movs	r2, #192	; 0xc0
     342:	0112      	lsls	r2, r2, #4
     344:	4053      	eors	r3, r2
	}

	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
     346:	4a09      	ldr	r2, [pc, #36]	; (36c <z_impl_gpio_pin_configure+0x44>)
     348:	401a      	ands	r2, r3

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
     34a:	07db      	lsls	r3, r3, #31
     34c:	d507      	bpl.n	35e <z_impl_gpio_pin_configure+0x36>
		data->invert |= (gpio_port_pins_t)BIT(pin);
     34e:	2301      	movs	r3, #1
     350:	408b      	lsls	r3, r1
     352:	6826      	ldr	r6, [r4, #0]
     354:	4333      	orrs	r3, r6
     356:	6023      	str	r3, [r4, #0]
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
	}

	return api->pin_configure(port, pin, flags);
     358:	682b      	ldr	r3, [r5, #0]
     35a:	4798      	blx	r3
}
     35c:	bd70      	pop	{r4, r5, r6, pc}
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
     35e:	2301      	movs	r3, #1
     360:	408b      	lsls	r3, r1
     362:	6826      	ldr	r6, [r4, #0]
     364:	439e      	bics	r6, r3
     366:	6026      	str	r6, [r4, #0]
     368:	e7f6      	b.n	358 <z_impl_gpio_pin_configure+0x30>
     36a:	46c0      	nop			; (mov r8, r8)
     36c:	ffffefff 	.word	0xffffefff

00000370 <ALARM_Handler>:
event_t SET_TIME_Handler(KitchenTimer_t * MainObject, GenericEvent_t * Event);

void Event_dispatcher(KitchenTimer_t * MainObject,GenericEvent_t * e);

  
event_t ALARM_Handler(KitchenTimer_t * MainObject, GenericEvent_t * Event){
     370:	b510      	push	{r4, lr}
     372:	0004      	movs	r4, r0

	switch (Event->Signal)	{
     374:	780b      	ldrb	r3, [r1, #0]
     376:	2b02      	cmp	r3, #2
     378:	d014      	beq.n	3a4 <ALARM_Handler+0x34>
     37a:	d808      	bhi.n	38e <ALARM_Handler+0x1e>
     37c:	2b00      	cmp	r3, #0
     37e:	d104      	bne.n	38a <ALARM_Handler+0x1a>

	}

	case Entry:{

	printk("Alarm State Entry- Count down expired\n");
     380:	480e      	ldr	r0, [pc, #56]	; (3bc <ALARM_Handler+0x4c>)
     382:	f003 fda6 	bl	3ed2 <printk>

    return EVENT_HANDLED;
     386:	2007      	movs	r0, #7
     388:	e000      	b.n	38c <ALARM_Handler+0x1c>
	switch (Event->Signal)	{
     38a:	2001      	movs	r0, #1
					}
	}

return 1;

}
     38c:	bd10      	pop	{r4, pc}
	switch (Event->Signal)	{
     38e:	3b03      	subs	r3, #3
     390:	b2db      	uxtb	r3, r3
     392:	2b02      	cmp	r3, #2
     394:	d810      	bhi.n	3b8 <ALARM_Handler+0x48>
	printk("Alarm cleared\n");
     396:	480a      	ldr	r0, [pc, #40]	; (3c0 <ALARM_Handler+0x50>)
     398:	f003 fd9b 	bl	3ed2 <printk>
	MainObject->CurrentState = IDLE;
     39c:	2300      	movs	r3, #0
     39e:	7123      	strb	r3, [r4, #4]
	return EVENT_TRANISITON;
     3a0:	2006      	movs	r0, #6
     3a2:	e7f3      	b.n	38c <ALARM_Handler+0x1c>
	if(((SystemGenerated_Event_t*)Event)->SubSecond == 10){
     3a4:	784b      	ldrb	r3, [r1, #1]
     3a6:	2b0a      	cmp	r3, #10
     3a8:	d001      	beq.n	3ae <ALARM_Handler+0x3e>
    return EVENT_HANDLED;
     3aa:	2007      	movs	r0, #7
     3ac:	e7ee      	b.n	38c <ALARM_Handler+0x1c>
	printk("Alarm State Tick Event - New Alarm\n");
     3ae:	4805      	ldr	r0, [pc, #20]	; (3c4 <ALARM_Handler+0x54>)
     3b0:	f003 fd8f 	bl	3ed2 <printk>
    return EVENT_HANDLED;
     3b4:	2007      	movs	r0, #7
     3b6:	e7e9      	b.n	38c <ALARM_Handler+0x1c>
	switch (Event->Signal)	{
     3b8:	2001      	movs	r0, #1
     3ba:	e7e7      	b.n	38c <ALARM_Handler+0x1c>
     3bc:	00005008 	.word	0x00005008
     3c0:	00004ff8 	.word	0x00004ff8
     3c4:	00005030 	.word	0x00005030

000003c8 <COUNTDOWN_Handler>:


event_t COUNTDOWN_Handler(KitchenTimer_t * MainObject, GenericEvent_t * Event){
     3c8:	b510      	push	{r4, lr}
     3ca:	0004      	movs	r4, r0

	switch (Event->Signal){
     3cc:	780b      	ldrb	r3, [r1, #0]
     3ce:	2b02      	cmp	r3, #2
     3d0:	d00b      	beq.n	3ea <COUNTDOWN_Handler+0x22>
     3d2:	2b05      	cmp	r3, #5
     3d4:	d01d      	beq.n	412 <CONFIG_MAIN_STACK_SIZE+0x12>
     3d6:	2b00      	cmp	r3, #0
     3d8:	d001      	beq.n	3de <COUNTDOWN_Handler+0x16>
     3da:	2001      	movs	r0, #1
	}
	}

return 1;

}
     3dc:	bd10      	pop	{r4, pc}
	printk("Countdown State - Entry event - Countdown time in seconds - %d\n",MainObject->CountDownValue);
     3de:	6801      	ldr	r1, [r0, #0]
     3e0:	480f      	ldr	r0, [pc, #60]	; (420 <CONFIG_MAIN_STACK_SIZE+0x20>)
     3e2:	f003 fd76 	bl	3ed2 <printk>
	return EVENT_HANDLED;
     3e6:	2007      	movs	r0, #7
     3e8:	e7f8      	b.n	3dc <COUNTDOWN_Handler+0x14>
	if(((SystemGenerated_Event_t*)Event)->SubSecond == 10){
     3ea:	784b      	ldrb	r3, [r1, #1]
     3ec:	2b0a      	cmp	r3, #10
     3ee:	d001      	beq.n	3f4 <COUNTDOWN_Handler+0x2c>
	return EVENT_HANDLED;
     3f0:	2007      	movs	r0, #7
     3f2:	e7f3      	b.n	3dc <COUNTDOWN_Handler+0x14>
	MainObject->CountDownValue -=1;
     3f4:	6803      	ldr	r3, [r0, #0]
     3f6:	1e59      	subs	r1, r3, #1
     3f8:	6001      	str	r1, [r0, #0]
	printk("Countdown State Tick event- Countdown time in seconds - %d\n",MainObject->CountDownValue);
     3fa:	480a      	ldr	r0, [pc, #40]	; (424 <CONFIG_MAIN_STACK_SIZE+0x24>)
     3fc:	f003 fd69 	bl	3ed2 <printk>
	if(MainObject->CountDownValue ==0){
     400:	6823      	ldr	r3, [r4, #0]
     402:	2b00      	cmp	r3, #0
     404:	d001      	beq.n	40a <CONFIG_MAIN_STACK_SIZE+0xa>
	return EVENT_HANDLED;
     406:	2007      	movs	r0, #7
     408:	e7e8      	b.n	3dc <COUNTDOWN_Handler+0x14>
		MainObject->CurrentState = ALARM;
     40a:	3304      	adds	r3, #4
     40c:	7123      	strb	r3, [r4, #4]
		return EVENT_TRANISITON;
     40e:	2006      	movs	r0, #6
     410:	e7e4      	b.n	3dc <COUNTDOWN_Handler+0x14>
	printk("START_PAUSE event received in Countdown state\n");
     412:	4805      	ldr	r0, [pc, #20]	; (428 <CONFIG_MAIN_STACK_SIZE+0x28>)
     414:	f003 fd5d 	bl	3ed2 <printk>
	MainObject->CurrentState = PAUSE;
     418:	2303      	movs	r3, #3
     41a:	7123      	strb	r3, [r4, #4]
	return EVENT_TRANISITON;
     41c:	2006      	movs	r0, #6
     41e:	e7dd      	b.n	3dc <COUNTDOWN_Handler+0x14>
     420:	00005054 	.word	0x00005054
     424:	00005094 	.word	0x00005094
     428:	000050d0 	.word	0x000050d0

0000042c <PAUSE_Handler>:


event_t PAUSE_Handler(KitchenTimer_t * MainObject, GenericEvent_t * Event){
     42c:	b510      	push	{r4, lr}
     42e:	0004      	movs	r4, r0
	
	switch (Event->Signal){
     430:	780b      	ldrb	r3, [r1, #0]
     432:	2b04      	cmp	r3, #4
     434:	d021      	beq.n	47a <PAUSE_Handler+0x4e>
     436:	d80f      	bhi.n	458 <PAUSE_Handler+0x2c>
     438:	2b00      	cmp	r3, #0
     43a:	d018      	beq.n	46e <PAUSE_Handler+0x42>
     43c:	2b03      	cmp	r3, #3
     43e:	d109      	bne.n	454 <PAUSE_Handler+0x28>
		
	}
	
	case INCREMENT_TIME:{

	printk("Increment time event received in Pause state\n");
     440:	4812      	ldr	r0, [pc, #72]	; (48c <PAUSE_Handler+0x60>)
     442:	f003 fd46 	bl	3ed2 <printk>

	MainObject->CountDownValue +=60;
     446:	6823      	ldr	r3, [r4, #0]
     448:	333c      	adds	r3, #60	; 0x3c
     44a:	6023      	str	r3, [r4, #0]

	MainObject->CurrentState = SET_TIME;
     44c:	2301      	movs	r3, #1
     44e:	7123      	strb	r3, [r4, #4]

	return EVENT_TRANISITON;
     450:	2006      	movs	r0, #6
     452:	e00b      	b.n	46c <PAUSE_Handler+0x40>
	switch (Event->Signal){
     454:	2001      	movs	r0, #1
     456:	e009      	b.n	46c <PAUSE_Handler+0x40>
     458:	2b05      	cmp	r3, #5
     45a:	d106      	bne.n	46a <PAUSE_Handler+0x3e>
	printk("START_PAUSE event received in Pause state\n");
     45c:	480c      	ldr	r0, [pc, #48]	; (490 <PAUSE_Handler+0x64>)
     45e:	f003 fd38 	bl	3ed2 <printk>
	MainObject->CurrentState = COUNTDOWN;
     462:	2302      	movs	r3, #2
     464:	7123      	strb	r3, [r4, #4]
	return EVENT_TRANISITON;
     466:	2006      	movs	r0, #6
     468:	e000      	b.n	46c <PAUSE_Handler+0x40>
	switch (Event->Signal){
     46a:	2001      	movs	r0, #1
						}
	}

return 1;

}
     46c:	bd10      	pop	{r4, pc}
	printk("Pause State - Entry - Countdown time in seconds - %d\n",MainObject->CountDownValue);
     46e:	6801      	ldr	r1, [r0, #0]
     470:	4808      	ldr	r0, [pc, #32]	; (494 <PAUSE_Handler+0x68>)
     472:	f003 fd2e 	bl	3ed2 <printk>
	return EVENT_HANDLED;
     476:	2007      	movs	r0, #7
     478:	e7f8      	b.n	46c <PAUSE_Handler+0x40>
	printk("Reset time event received in Pause state\n");
     47a:	4807      	ldr	r0, [pc, #28]	; (498 <PAUSE_Handler+0x6c>)
     47c:	f003 fd29 	bl	3ed2 <printk>
	MainObject->CountDownValue =0;
     480:	2300      	movs	r3, #0
     482:	6023      	str	r3, [r4, #0]
	MainObject->CurrentState = IDLE;
     484:	7123      	strb	r3, [r4, #4]
	return EVENT_TRANISITON;
     486:	2006      	movs	r0, #6
     488:	e7f0      	b.n	46c <PAUSE_Handler+0x40>
     48a:	46c0      	nop			; (mov r8, r8)
     48c:	00005190 	.word	0x00005190
     490:	00005164 	.word	0x00005164
     494:	00005100 	.word	0x00005100
     498:	00005138 	.word	0x00005138

0000049c <IDLE_Handler>:


event_t IDLE_Handler(KitchenTimer_t * MainObject, GenericEvent_t * Event){
     49c:	b510      	push	{r4, lr}
     49e:	0004      	movs	r4, r0

	switch (Event->Signal){
     4a0:	780b      	ldrb	r3, [r1, #0]
     4a2:	2b00      	cmp	r3, #0
     4a4:	d003      	beq.n	4ae <IDLE_Handler+0x12>
     4a6:	2b03      	cmp	r3, #3
     4a8:	d007      	beq.n	4ba <IDLE_Handler+0x1e>
     4aa:	2001      	movs	r0, #1
						}
	}

return 1;

}
     4ac:	bd10      	pop	{r4, pc}
		printk("Idle State - Entry - Countdown time in seconds - %d\n",MainObject->CountDownValue);
     4ae:	6801      	ldr	r1, [r0, #0]
     4b0:	4807      	ldr	r0, [pc, #28]	; (4d0 <IDLE_Handler+0x34>)
     4b2:	f003 fd0e 	bl	3ed2 <printk>
		return EVENT_HANDLED;
     4b6:	2007      	movs	r0, #7
     4b8:	e7f8      	b.n	4ac <IDLE_Handler+0x10>
		printk("Increment time event received in Idle state\n");
     4ba:	4806      	ldr	r0, [pc, #24]	; (4d4 <IDLE_Handler+0x38>)
     4bc:	f003 fd09 	bl	3ed2 <printk>
		MainObject->CountDownValue +=60;
     4c0:	6823      	ldr	r3, [r4, #0]
     4c2:	333c      	adds	r3, #60	; 0x3c
     4c4:	6023      	str	r3, [r4, #0]
		MainObject->CurrentState = SET_TIME;
     4c6:	2301      	movs	r3, #1
     4c8:	7123      	strb	r3, [r4, #4]
		return EVENT_TRANISITON;
     4ca:	2006      	movs	r0, #6
     4cc:	e7ee      	b.n	4ac <IDLE_Handler+0x10>
     4ce:	46c0      	nop			; (mov r8, r8)
     4d0:	000051c0 	.word	0x000051c0
     4d4:	000051f8 	.word	0x000051f8

000004d8 <SET_TIME_Handler>:


event_t SET_TIME_Handler(KitchenTimer_t * MainObject, GenericEvent_t * Event){
     4d8:	b510      	push	{r4, lr}
     4da:	0004      	movs	r4, r0

	switch (Event->Signal){
     4dc:	780b      	ldrb	r3, [r1, #0]
     4de:	2b04      	cmp	r3, #4
     4e0:	d025      	beq.n	52e <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x46>
     4e2:	d80b      	bhi.n	4fc <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x14>
     4e4:	2b00      	cmp	r3, #0
     4e6:	d014      	beq.n	512 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x2a>
     4e8:	2b03      	cmp	r3, #3
     4ea:	d105      	bne.n	4f8 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x10>

	}

	case INCREMENT_TIME:{

	if(MainObject->CountDownValue<(60*25)){
     4ec:	6801      	ldr	r1, [r0, #0]
     4ee:	4b14      	ldr	r3, [pc, #80]	; (540 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x58>)
     4f0:	4299      	cmp	r1, r3
     4f2:	dd14      	ble.n	51e <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x36>

	return EVENT_HANDLED;
		
		}

	return EVENT_HANDLED;
     4f4:	2007      	movs	r0, #7
     4f6:	e00b      	b.n	510 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x28>
	switch (Event->Signal){
     4f8:	2001      	movs	r0, #1
     4fa:	e009      	b.n	510 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x28>
     4fc:	2b05      	cmp	r3, #5
     4fe:	d106      	bne.n	50e <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x26>
		
	}

	case START_PAUSE:{

	printk("START_PAUSE event received in set_time state\n");
     500:	4810      	ldr	r0, [pc, #64]	; (544 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x5c>)
     502:	f003 fce6 	bl	3ed2 <printk>

	MainObject->CurrentState = COUNTDOWN;
     506:	2302      	movs	r3, #2
     508:	7123      	strb	r3, [r4, #4]

	return EVENT_TRANISITON;
     50a:	2006      	movs	r0, #6
     50c:	e000      	b.n	510 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x28>
	switch (Event->Signal){
     50e:	2001      	movs	r0, #1

	}

return 1;

}
     510:	bd10      	pop	{r4, pc}
	printk("SET_TIME State - Countdown time in seconds - %d\n",MainObject->CountDownValue);
     512:	6801      	ldr	r1, [r0, #0]
     514:	480c      	ldr	r0, [pc, #48]	; (548 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x60>)
     516:	f003 fcdc 	bl	3ed2 <printk>
	return EVENT_HANDLED;
     51a:	2007      	movs	r0, #7
     51c:	e7f8      	b.n	510 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x28>
	printk("Increment time event received in Set_Time state - Countdown time in seconds - %d\n",MainObject->CountDownValue);
     51e:	480b      	ldr	r0, [pc, #44]	; (54c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x64>)
     520:	f003 fcd7 	bl	3ed2 <printk>
	MainObject->CountDownValue +=60;
     524:	6823      	ldr	r3, [r4, #0]
     526:	333c      	adds	r3, #60	; 0x3c
     528:	6023      	str	r3, [r4, #0]
	return EVENT_HANDLED;
     52a:	2007      	movs	r0, #7
     52c:	e7f0      	b.n	510 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x28>
	printk("Reset time event received in Set_Time state\n");
     52e:	4808      	ldr	r0, [pc, #32]	; (550 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x68>)
     530:	f003 fccf 	bl	3ed2 <printk>
	MainObject->CountDownValue =0;
     534:	2300      	movs	r3, #0
     536:	6023      	str	r3, [r4, #0]
	MainObject->CurrentState = IDLE;
     538:	7123      	strb	r3, [r4, #4]
	return EVENT_TRANISITON;
     53a:	2006      	movs	r0, #6
     53c:	e7e8      	b.n	510 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x28>
     53e:	46c0      	nop			; (mov r8, r8)
     540:	000005db 	.word	0x000005db
     544:	000052e0 	.word	0x000052e0
     548:	00005228 	.word	0x00005228
     54c:	0000525c 	.word	0x0000525c
     550:	000052b0 	.word	0x000052b0

00000554 <StateMachine_Handler>:
	StateMachine_Handler(&Main_KitchenTimer,&EventStatus);

}


event_t StateMachine_Handler(KitchenTimer_t * MainObject, GenericEvent_t * Event){
     554:	b510      	push	{r4, lr}

switch (MainObject->CurrentState){
     556:	7903      	ldrb	r3, [r0, #4]
     558:	2b04      	cmp	r3, #4
     55a:	d812      	bhi.n	582 <StateMachine_Handler+0x2e>
     55c:	009b      	lsls	r3, r3, #2
     55e:	4a0a      	ldr	r2, [pc, #40]	; (588 <StateMachine_Handler+0x34>)
     560:	58d3      	ldr	r3, [r2, r3]
     562:	469f      	mov	pc, r3

case IDLE:{

	return IDLE_Handler(MainObject,Event);
     564:	f7ff ff9a 	bl	49c <IDLE_Handler>

}

return 1;

}
     568:	bd10      	pop	{r4, pc}
	return COUNTDOWN_Handler(MainObject,Event);
     56a:	f7ff ff2d 	bl	3c8 <COUNTDOWN_Handler>
     56e:	e7fb      	b.n	568 <StateMachine_Handler+0x14>
	return ALARM_Handler(MainObject,Event);
     570:	f7ff fefe 	bl	370 <ALARM_Handler>
     574:	e7f8      	b.n	568 <StateMachine_Handler+0x14>
	return PAUSE_Handler(MainObject,Event);
     576:	f7ff ff59 	bl	42c <PAUSE_Handler>
     57a:	e7f5      	b.n	568 <StateMachine_Handler+0x14>
	return SET_TIME_Handler(MainObject,Event);
     57c:	f7ff ffac 	bl	4d8 <SET_TIME_Handler>
     580:	e7f2      	b.n	568 <StateMachine_Handler+0x14>
switch (MainObject->CurrentState){
     582:	2001      	movs	r0, #1
     584:	e7f0      	b.n	568 <StateMachine_Handler+0x14>
     586:	46c0      	nop			; (mov r8, r8)
     588:	00005310 	.word	0x00005310

0000058c <Initialize_StateMachine>:
void Initialize_StateMachine(void){
     58c:	b510      	push	{r4, lr}
	Main_KitchenTimer.CountDownValue =(60*0);
     58e:	4804      	ldr	r0, [pc, #16]	; (5a0 <Initialize_StateMachine+0x14>)
     590:	2300      	movs	r3, #0
     592:	6003      	str	r3, [r0, #0]
	EventStatus.Signal = Entry;
     594:	4903      	ldr	r1, [pc, #12]	; (5a4 <Initialize_StateMachine+0x18>)
     596:	700b      	strb	r3, [r1, #0]
	Main_KitchenTimer.CurrentState = IDLE;
     598:	7103      	strb	r3, [r0, #4]
	StateMachine_Handler(&Main_KitchenTimer,&EventStatus);
     59a:	f7ff ffdb 	bl	554 <StateMachine_Handler>
}
     59e:	bd10      	pop	{r4, pc}
     5a0:	200001b4 	.word	0x200001b4
     5a4:	200001b0 	.word	0x200001b0

000005a8 <main>:



void main(void){
     5a8:	b5f0      	push	{r4, r5, r6, r7, lr}
     5aa:	b083      	sub	sp, #12

	//console_init();

	Initialize_StateMachine();
     5ac:	f7ff ffee 	bl	58c <Initialize_StateMachine>
		(void)arch_syscall_invoke1((uintptr_t)&ret64, K_SYSCALL_K_UPTIME_TICKS);
		return (int64_t)ret64;
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
     5b0:	f004 fbe7 	bl	4d82 <z_impl_k_uptime_ticks>
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
     5b4:	22fa      	movs	r2, #250	; 0xfa
     5b6:	0092      	lsls	r2, r2, #2
     5b8:	2300      	movs	r3, #0
     5ba:	f7ff fdb5 	bl	128 <__aeabi_lmul>
     5be:	044b      	lsls	r3, r1, #17
     5c0:	0bc0      	lsrs	r0, r0, #15
 *
 * @return Current uptime in milliseconds.
 */
static inline int64_t k_uptime_get(void)
{
	return k_ticks_to_ms_floor64(k_uptime_ticks());
     5c2:	4303      	orrs	r3, r0
     5c4:	001c      	movs	r4, r3
     5c6:	0bcd      	lsrs	r5, r1, #15
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     5c8:	4854      	ldr	r0, [pc, #336]	; (71c <main+0x174>)
     5ca:	f002 fce3 	bl	2f94 <z_impl_device_get_binding>

	static SystemGenerated_Event_t SystemTick;

	static UserGenerated_Event_t UserActivity;

	gpio0 = device_get_binding("GPIO_0");
     5ce:	4f54      	ldr	r7, [pc, #336]	; (720 <main+0x178>)
     5d0:	6038      	str	r0, [r7, #0]
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&port, *(uintptr_t *)&pin, *(uintptr_t *)&flags, K_SYSCALL_GPIO_PIN_CONFIGURE);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_pin_configure(port, pin, flags);
     5d2:	2680      	movs	r6, #128	; 0x80
     5d4:	0076      	lsls	r6, r6, #1
     5d6:	0032      	movs	r2, r6
     5d8:	2102      	movs	r1, #2
     5da:	f7ff fea5 	bl	328 <z_impl_gpio_pin_configure>

   	gpio_pin_configure(gpio0, 2, GPIO_INPUT);

   	gpio_pin_configure(gpio0, 3, GPIO_INPUT);
     5de:	6838      	ldr	r0, [r7, #0]
     5e0:	0032      	movs	r2, r6
     5e2:	2103      	movs	r1, #3
     5e4:	f7ff fea0 	bl	328 <z_impl_gpio_pin_configure>

   	gpio_pin_configure(gpio0, 30, GPIO_INPUT);
     5e8:	6838      	ldr	r0, [r7, #0]
     5ea:	0032      	movs	r2, r6
     5ec:	211e      	movs	r1, #30
     5ee:	f7ff fe9b 	bl	328 <z_impl_gpio_pin_configure>
     5f2:	e067      	b.n	6c4 <main+0x11c>
	
	while (1) {
		
	if(k_uptime_get()-Current_time>=100){

	int button_state = gpio_pin_get(gpio0, 3);
     5f4:	4b4a      	ldr	r3, [pc, #296]	; (720 <main+0x178>)
     5f6:	6818      	ldr	r0, [r3, #0]
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_port_get(const struct device *port,
				gpio_port_value_t *value)
{
	const struct gpio_driver_data *const data =
     5f8:	6905      	ldr	r5, [r0, #16]
	const struct gpio_driver_api *api =
     5fa:	6883      	ldr	r3, [r0, #8]
	return api->port_get_raw(port, value);
     5fc:	685b      	ldr	r3, [r3, #4]
     5fe:	a901      	add	r1, sp, #4
     600:	4798      	blx	r3
     602:	1e04      	subs	r4, r0, #0
			(const struct gpio_driver_data *)port->data;
	int ret;

	ret = gpio_port_get_raw(port, value);
	if (ret == 0) {
     604:	d103      	bne.n	60e <main+0x66>
		*value ^= data->invert;
     606:	682b      	ldr	r3, [r5, #0]
     608:	9a01      	ldr	r2, [sp, #4]
     60a:	4053      	eors	r3, r2
     60c:	9301      	str	r3, [sp, #4]
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	ret = gpio_port_get(port, &value);
	if (ret == 0) {
     60e:	2c00      	cmp	r4, #0
     610:	d105      	bne.n	61e <main+0x76>
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
     612:	3408      	adds	r4, #8
     614:	9b01      	ldr	r3, [sp, #4]
     616:	401c      	ands	r4, r3
     618:	1e63      	subs	r3, r4, #1
     61a:	419c      	sbcs	r4, r3
     61c:	b2e4      	uxtb	r4, r4

	int button_state2 = gpio_pin_get(gpio0, 2);
     61e:	4b40      	ldr	r3, [pc, #256]	; (720 <main+0x178>)
     620:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_data *const data =
     622:	6906      	ldr	r6, [r0, #16]
	const struct gpio_driver_api *api =
     624:	6883      	ldr	r3, [r0, #8]
	return api->port_get_raw(port, value);
     626:	685b      	ldr	r3, [r3, #4]
     628:	a901      	add	r1, sp, #4
     62a:	4798      	blx	r3
     62c:	1e05      	subs	r5, r0, #0
	if (ret == 0) {
     62e:	d103      	bne.n	638 <main+0x90>
		*value ^= data->invert;
     630:	6833      	ldr	r3, [r6, #0]
     632:	9a01      	ldr	r2, [sp, #4]
     634:	4053      	eors	r3, r2
     636:	9301      	str	r3, [sp, #4]
	if (ret == 0) {
     638:	2d00      	cmp	r5, #0
     63a:	d105      	bne.n	648 <main+0xa0>
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
     63c:	3504      	adds	r5, #4
     63e:	9b01      	ldr	r3, [sp, #4]
     640:	401d      	ands	r5, r3
     642:	1e6b      	subs	r3, r5, #1
     644:	419d      	sbcs	r5, r3
     646:	b2ed      	uxtb	r5, r5

	int button_state3 = gpio_pin_get(gpio0, 30);
     648:	4b35      	ldr	r3, [pc, #212]	; (720 <main+0x178>)
     64a:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_data *const data =
     64c:	6906      	ldr	r6, [r0, #16]
	const struct gpio_driver_api *api =
     64e:	6883      	ldr	r3, [r0, #8]
	return api->port_get_raw(port, value);
     650:	685b      	ldr	r3, [r3, #4]
     652:	a901      	add	r1, sp, #4
     654:	4798      	blx	r3
	if (ret == 0) {
     656:	2800      	cmp	r0, #0
     658:	d103      	bne.n	662 <main+0xba>
		*value ^= data->invert;
     65a:	6833      	ldr	r3, [r6, #0]
     65c:	9a01      	ldr	r2, [sp, #4]
     65e:	4053      	eors	r3, r2
     660:	9301      	str	r3, [sp, #4]
	if (ret == 0) {
     662:	2800      	cmp	r0, #0
     664:	d106      	bne.n	674 <main+0xcc>
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
     666:	2080      	movs	r0, #128	; 0x80
     668:	05c0      	lsls	r0, r0, #23
     66a:	9b01      	ldr	r3, [sp, #4]
     66c:	4018      	ands	r0, r3
     66e:	1e43      	subs	r3, r0, #1
     670:	4198      	sbcs	r0, r3
     672:	b2c0      	uxtb	r0, r0

	if((button_state2 !=1)|(button_state3 !=1)|(button_state !=1)){
     674:	1e6b      	subs	r3, r5, #1
     676:	1e5a      	subs	r2, r3, #1
     678:	4193      	sbcs	r3, r2
     67a:	1e42      	subs	r2, r0, #1
     67c:	1e51      	subs	r1, r2, #1
     67e:	418a      	sbcs	r2, r1
     680:	4313      	orrs	r3, r2
     682:	1e62      	subs	r2, r4, #1
     684:	1e51      	subs	r1, r2, #1
     686:	418a      	sbcs	r2, r1
     688:	b2d2      	uxtb	r2, r2
     68a:	2b00      	cmp	r3, #0
     68c:	d12e      	bne.n	6ec <main+0x144>
     68e:	2a00      	cmp	r2, #0
     690:	d12c      	bne.n	6ec <main+0x144>
     692:	f004 fb76 	bl	4d82 <z_impl_k_uptime_ticks>
     696:	22fa      	movs	r2, #250	; 0xfa
     698:	0092      	lsls	r2, r2, #2
     69a:	2300      	movs	r3, #0
     69c:	f7ff fd44 	bl	128 <__aeabi_lmul>
     6a0:	044b      	lsls	r3, r1, #17
     6a2:	0bc0      	lsrs	r0, r0, #15
     6a4:	4303      	orrs	r3, r0
     6a6:	001c      	movs	r4, r3
     6a8:	0bcd      	lsrs	r5, r1, #15

	}

	Current_time = k_uptime_get();

	SystemTick.SystemSignal.Signal = TIME_TICK;
     6aa:	4b1e      	ldr	r3, [pc, #120]	; (724 <main+0x17c>)
     6ac:	2202      	movs	r2, #2
     6ae:	701a      	strb	r2, [r3, #0]

	if(SystemTick.SubSecond>10){
     6b0:	785b      	ldrb	r3, [r3, #1]
     6b2:	2b0a      	cmp	r3, #10
     6b4:	d92e      	bls.n	714 <main+0x16c>

		SystemTick.SubSecond=1;
     6b6:	4b1b      	ldr	r3, [pc, #108]	; (724 <main+0x17c>)
     6b8:	3a01      	subs	r2, #1
     6ba:	705a      	strb	r2, [r3, #1]
	}
	else SystemTick.SubSecond++;

	// control reaches every 100 milli second

	Event_dispatcher(&Main_KitchenTimer,&SystemTick.SystemSignal);
     6bc:	4919      	ldr	r1, [pc, #100]	; (724 <main+0x17c>)
     6be:	481a      	ldr	r0, [pc, #104]	; (728 <main+0x180>)
     6c0:	f003 fbaa 	bl	3e18 <Event_dispatcher>
     6c4:	f004 fb5d 	bl	4d82 <z_impl_k_uptime_ticks>
     6c8:	22fa      	movs	r2, #250	; 0xfa
     6ca:	0092      	lsls	r2, r2, #2
     6cc:	2300      	movs	r3, #0
     6ce:	f7ff fd2b 	bl	128 <__aeabi_lmul>
     6d2:	044e      	lsls	r6, r1, #17
     6d4:	0bc0      	lsrs	r0, r0, #15
     6d6:	4306      	orrs	r6, r0
     6d8:	0032      	movs	r2, r6
     6da:	0bcb      	lsrs	r3, r1, #15
	if(k_uptime_get()-Current_time>=100){
     6dc:	1b12      	subs	r2, r2, r4
     6de:	41ab      	sbcs	r3, r5
     6e0:	2b00      	cmp	r3, #0
     6e2:	dc87      	bgt.n	5f4 <main+0x4c>
     6e4:	d1ee      	bne.n	6c4 <main+0x11c>
     6e6:	2a63      	cmp	r2, #99	; 0x63
     6e8:	d9ec      	bls.n	6c4 <main+0x11c>
     6ea:	e783      	b.n	5f4 <main+0x4c>
	if(button_state2 !=1){
     6ec:	2d01      	cmp	r5, #1
     6ee:	d002      	beq.n	6f6 <main+0x14e>
		UserActivity.UserSignal.Signal = INCREMENT_TIME;
     6f0:	4b0e      	ldr	r3, [pc, #56]	; (72c <main+0x184>)
     6f2:	2203      	movs	r2, #3
     6f4:	701a      	strb	r2, [r3, #0]
	if(button_state3 !=1){
     6f6:	2801      	cmp	r0, #1
     6f8:	d002      	beq.n	700 <main+0x158>
	UserActivity.UserSignal.Signal = START_PAUSE;
     6fa:	4b0c      	ldr	r3, [pc, #48]	; (72c <main+0x184>)
     6fc:	2205      	movs	r2, #5
     6fe:	701a      	strb	r2, [r3, #0]
	if(button_state !=1){
     700:	2c01      	cmp	r4, #1
     702:	d002      	beq.n	70a <main+0x162>
	UserActivity.UserSignal.Signal = RESET_TIME;
     704:	4b09      	ldr	r3, [pc, #36]	; (72c <main+0x184>)
     706:	2204      	movs	r2, #4
     708:	701a      	strb	r2, [r3, #0]
	Event_dispatcher(&Main_KitchenTimer,&UserActivity.UserSignal);
     70a:	4908      	ldr	r1, [pc, #32]	; (72c <main+0x184>)
     70c:	4806      	ldr	r0, [pc, #24]	; (728 <main+0x180>)
     70e:	f003 fb83 	bl	3e18 <Event_dispatcher>
     712:	e7be      	b.n	692 <main+0xea>
	else SystemTick.SubSecond++;
     714:	3301      	adds	r3, #1
     716:	4a03      	ldr	r2, [pc, #12]	; (724 <main+0x17c>)
     718:	7053      	strb	r3, [r2, #1]
     71a:	e7cf      	b.n	6bc <main+0x114>
     71c:	00005324 	.word	0x00005324
     720:	200001c4 	.word	0x200001c4
     724:	200001bc 	.word	0x200001bc
     728:	200001b4 	.word	0x200001b4
     72c:	200001c0 	.word	0x200001c0

00000730 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
     730:	b510      	push	{r4, lr}
	struct out_context *ctx = ctx_p;

	ctx->count++;
     732:	680b      	ldr	r3, [r1, #0]
     734:	3301      	adds	r3, #1
     736:	600b      	str	r3, [r1, #0]
	return _char_out(c);
     738:	4b01      	ldr	r3, [pc, #4]	; (740 <char_out+0x10>)
     73a:	681b      	ldr	r3, [r3, #0]
     73c:	4798      	blx	r3
}
     73e:	bd10      	pop	{r4, pc}
     740:	20000000 	.word	0x20000000

00000744 <__printk_hook_install>:
	_char_out = fn;
     744:	4b01      	ldr	r3, [pc, #4]	; (74c <__printk_hook_install+0x8>)
     746:	6018      	str	r0, [r3, #0]
}
     748:	4770      	bx	lr
     74a:	46c0      	nop			; (mov r8, r8)
     74c:	20000000 	.word	0x20000000

00000750 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
     750:	b500      	push	{lr}
     752:	b083      	sub	sp, #12
     754:	0002      	movs	r2, r0
     756:	000b      	movs	r3, r1
	struct out_context ctx = { 0 };
     758:	2100      	movs	r1, #0
     75a:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
     75c:	a901      	add	r1, sp, #4
     75e:	4802      	ldr	r0, [pc, #8]	; (768 <vprintk+0x18>)
     760:	f000 f932 	bl	9c8 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
     764:	b003      	add	sp, #12
     766:	bd00      	pop	{pc}
     768:	00000731 	.word	0x00000731

0000076c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
     76c:	b510      	push	{r4, lr}
     76e:	b084      	sub	sp, #16
     770:	0004      	movs	r4, r0
	struct str_context ctx = { str, size, 0 };
     772:	9001      	str	r0, [sp, #4]
     774:	9102      	str	r1, [sp, #8]
     776:	2100      	movs	r1, #0
     778:	9103      	str	r1, [sp, #12]

	cbvprintf(str_out, &ctx, fmt, ap);
     77a:	a901      	add	r1, sp, #4
     77c:	4806      	ldr	r0, [pc, #24]	; (798 <vsnprintk+0x2c>)
     77e:	f000 f923 	bl	9c8 <cbvprintf>

	if (ctx.count < ctx.max) {
     782:	9803      	ldr	r0, [sp, #12]
     784:	9b02      	ldr	r3, [sp, #8]
     786:	4298      	cmp	r0, r3
     788:	da02      	bge.n	790 <vsnprintk+0x24>
		str[ctx.count] = '\0';
     78a:	1824      	adds	r4, r4, r0
     78c:	2300      	movs	r3, #0
     78e:	7023      	strb	r3, [r4, #0]
	}

	return ctx.count;
}
     790:	9803      	ldr	r0, [sp, #12]
     792:	b004      	add	sp, #16
     794:	bd10      	pop	{r4, pc}
     796:	46c0      	nop			; (mov r8, r8)
     798:	00003ea1 	.word	0x00003ea1

0000079c <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     79c:	b5f0      	push	{r4, r5, r6, r7, lr}
     79e:	46ce      	mov	lr, r9
     7a0:	4647      	mov	r7, r8
     7a2:	b580      	push	{r7, lr}
     7a4:	b083      	sub	sp, #12
     7a6:	0004      	movs	r4, r0
     7a8:	0008      	movs	r0, r1
     7aa:	0015      	movs	r5, r2
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     7ac:	8b23      	ldrh	r3, [r4, #24]
     7ae:	2707      	movs	r7, #7
     7b0:	401f      	ands	r7, r3
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     7b2:	071a      	lsls	r2, r3, #28
     7b4:	d403      	bmi.n	7be <process_event+0x22>
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
     7b6:	2300      	movs	r3, #0
     7b8:	9300      	str	r3, [sp, #0]
	list->tail = NULL;
     7ba:	9301      	str	r3, [sp, #4]
}
     7bc:	e06f      	b.n	89e <CONFIG_ISR_STACK_SIZE+0x9e>
		if (evt == EVT_COMPLETE) {
     7be:	2901      	cmp	r1, #1
     7c0:	d00c      	beq.n	7dc <process_event+0x40>
			mgr->flags |= ONOFF_FLAG_COMPLETE;
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     7c2:	2220      	movs	r2, #32
     7c4:	4313      	orrs	r3, r2
     7c6:	8323      	strh	r3, [r4, #24]
 */

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	if (key != 0U) {
     7c8:	2d00      	cmp	r5, #0
     7ca:	d102      	bne.n	7d2 <process_event+0x36>
		return;
	}
	__asm__ volatile(
     7cc:	b662      	cpsie	i
     7ce:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     7d2:	b003      	add	sp, #12
     7d4:	bc0c      	pop	{r2, r3}
     7d6:	4690      	mov	r8, r2
     7d8:	4699      	mov	r9, r3
     7da:	bdf0      	pop	{r4, r5, r6, r7, pc}
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     7dc:	2210      	movs	r2, #16
     7de:	4313      	orrs	r3, r2
     7e0:	8323      	strh	r3, [r4, #24]
     7e2:	e7f1      	b.n	7c8 <process_event+0x2c>
			evt = process_recheck(mgr);
     7e4:	0020      	movs	r0, r4
     7e6:	f003 fbb6 	bl	3f56 <process_recheck>
     7ea:	e05a      	b.n	8a2 <CONFIG_ISR_STACK_SIZE+0xa2>
			res = mgr->last_res;
     7ec:	6963      	ldr	r3, [r4, #20]
     7ee:	4699      	mov	r9, r3
			process_complete(mgr, &clients, res);
     7f0:	001a      	movs	r2, r3
     7f2:	4669      	mov	r1, sp
     7f4:	0020      	movs	r0, r4
     7f6:	f003 fbcb 	bl	3f90 <process_complete>
		onoff_transition_fn transit = NULL;
     7fa:	2300      	movs	r3, #0
     7fc:	4698      	mov	r8, r3
     7fe:	e05e      	b.n	8be <CONFIG_ISR_STACK_SIZE+0xbe>
			transit = mgr->transitions->start;
     800:	6923      	ldr	r3, [r4, #16]
     802:	681b      	ldr	r3, [r3, #0]
     804:	4698      	mov	r8, r3
			set_state(mgr, ONOFF_STATE_TO_ON);
     806:	2106      	movs	r1, #6
     808:	0020      	movs	r0, r4
     80a:	f003 fb7a 	bl	3f02 <set_state>
		res = 0;
     80e:	2300      	movs	r3, #0
     810:	4699      	mov	r9, r3
     812:	e054      	b.n	8be <CONFIG_ISR_STACK_SIZE+0xbe>
			transit = mgr->transitions->stop;
     814:	6923      	ldr	r3, [r4, #16]
     816:	685b      	ldr	r3, [r3, #4]
     818:	4698      	mov	r8, r3
			set_state(mgr, ONOFF_STATE_TO_OFF);
     81a:	2104      	movs	r1, #4
     81c:	0020      	movs	r0, r4
     81e:	f003 fb70 	bl	3f02 <set_state>
		res = 0;
     822:	2300      	movs	r3, #0
     824:	4699      	mov	r9, r3
     826:	e04a      	b.n	8be <CONFIG_ISR_STACK_SIZE+0xbe>
			transit = mgr->transitions->reset;
     828:	6923      	ldr	r3, [r4, #16]
     82a:	689b      	ldr	r3, [r3, #8]
     82c:	4698      	mov	r8, r3
			set_state(mgr, ONOFF_STATE_RESETTING);
     82e:	2105      	movs	r1, #5
     830:	0020      	movs	r0, r4
     832:	f003 fb66 	bl	3f02 <set_state>
		res = 0;
     836:	2300      	movs	r3, #0
     838:	4699      	mov	r9, r3
     83a:	e040      	b.n	8be <CONFIG_ISR_STACK_SIZE+0xbe>
				   && !sys_slist_is_empty(&mgr->monitors);
     83c:	2300      	movs	r3, #0
     83e:	e047      	b.n	8d0 <CONFIG_ISR_STACK_SIZE+0xd0>
     840:	2300      	movs	r3, #0
     842:	e045      	b.n	8d0 <CONFIG_ISR_STACK_SIZE+0xd0>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     844:	2108      	movs	r1, #8
     846:	430a      	orrs	r2, r1
			mgr->flags = flags;
     848:	8322      	strh	r2, [r4, #24]
	if (key != 0U) {
     84a:	2d00      	cmp	r5, #0
     84c:	d102      	bne.n	854 <CONFIG_ISR_STACK_SIZE+0x54>
	__asm__ volatile(
     84e:	b662      	cpsie	i
     850:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
     854:	2b00      	cmp	r3, #0
     856:	d144      	bne.n	8e2 <CONFIG_ISR_STACK_SIZE+0xe2>
			if (!sys_slist_is_empty(&clients)) {
     858:	9b00      	ldr	r3, [sp, #0]
     85a:	2b00      	cmp	r3, #0
     85c:	d005      	beq.n	86a <CONFIG_ISR_STACK_SIZE+0x6a>
				notify_all(mgr, &clients, state, res);
     85e:	464b      	mov	r3, r9
     860:	0032      	movs	r2, r6
     862:	4669      	mov	r1, sp
     864:	0020      	movs	r0, r4
     866:	f003 fc0c 	bl	4082 <notify_all>
			if (transit != NULL) {
     86a:	4643      	mov	r3, r8
     86c:	2b00      	cmp	r3, #0
     86e:	d002      	beq.n	876 <CONFIG_ISR_STACK_SIZE+0x76>
				transit(mgr, transition_complete);
     870:	4923      	ldr	r1, [pc, #140]	; (900 <CONFIG_ISR_STACK_SIZE+0x100>)
     872:	0020      	movs	r0, r4
     874:	47c0      	blx	r8
	__asm__ volatile("mrs %0, PRIMASK;"
     876:	f3ef 8510 	mrs	r5, PRIMASK
     87a:	b672      	cpsid	i
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     87c:	8b23      	ldrh	r3, [r4, #24]
     87e:	2208      	movs	r2, #8
     880:	4393      	bics	r3, r2
     882:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     884:	8b23      	ldrh	r3, [r4, #24]
     886:	06da      	lsls	r2, r3, #27
     888:	d531      	bpl.n	8ee <CONFIG_ISR_STACK_SIZE+0xee>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     88a:	2210      	movs	r2, #16
     88c:	4393      	bics	r3, r2
     88e:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
     890:	2001      	movs	r0, #1
		state = mgr->flags & ONOFF_STATE_MASK;
     892:	8b23      	ldrh	r3, [r4, #24]
     894:	2707      	movs	r7, #7
     896:	401f      	ands	r7, r3
	} while (evt != EVT_NOP);
     898:	2800      	cmp	r0, #0
     89a:	d100      	bne.n	89e <CONFIG_ISR_STACK_SIZE+0x9e>
     89c:	e794      	b.n	7c8 <process_event+0x2c>
		if (evt == EVT_RECHECK) {
     89e:	2802      	cmp	r0, #2
     8a0:	d0a0      	beq.n	7e4 <process_event+0x48>
		if (evt == EVT_NOP) {
     8a2:	2800      	cmp	r0, #0
     8a4:	d100      	bne.n	8a8 <CONFIG_ISR_STACK_SIZE+0xa8>
     8a6:	e78f      	b.n	7c8 <process_event+0x2c>
		if (evt == EVT_COMPLETE) {
     8a8:	2801      	cmp	r0, #1
     8aa:	d09f      	beq.n	7ec <process_event+0x50>
		} else if (evt == EVT_START) {
     8ac:	2803      	cmp	r0, #3
     8ae:	d0a7      	beq.n	800 <CONFIG_ISR_STACK_SIZE>
		} else if (evt == EVT_STOP) {
     8b0:	2804      	cmp	r0, #4
     8b2:	d0af      	beq.n	814 <CONFIG_ISR_STACK_SIZE+0x14>
		} else if (evt == EVT_RESET) {
     8b4:	2805      	cmp	r0, #5
     8b6:	d0b7      	beq.n	828 <CONFIG_ISR_STACK_SIZE+0x28>
		onoff_transition_fn transit = NULL;
     8b8:	2300      	movs	r3, #0
     8ba:	4698      	mov	r8, r3
		res = 0;
     8bc:	4699      	mov	r9, r3
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     8be:	8b22      	ldrh	r2, [r4, #24]
     8c0:	2607      	movs	r6, #7
     8c2:	4016      	ands	r6, r2
				   && !sys_slist_is_empty(&mgr->monitors);
     8c4:	42be      	cmp	r6, r7
     8c6:	d0b9      	beq.n	83c <CONFIG_ISR_STACK_SIZE+0x3c>
     8c8:	68a3      	ldr	r3, [r4, #8]
     8ca:	2b00      	cmp	r3, #0
     8cc:	d0b8      	beq.n	840 <CONFIG_ISR_STACK_SIZE+0x40>
     8ce:	2301      	movs	r3, #1
		if (do_monitors
     8d0:	2b00      	cmp	r3, #0
     8d2:	d1b7      	bne.n	844 <CONFIG_ISR_STACK_SIZE+0x44>
		    || !sys_slist_is_empty(&clients)
     8d4:	9900      	ldr	r1, [sp, #0]
     8d6:	2900      	cmp	r1, #0
     8d8:	d1b4      	bne.n	844 <CONFIG_ISR_STACK_SIZE+0x44>
		    || (transit != NULL)) {
     8da:	4641      	mov	r1, r8
     8dc:	2900      	cmp	r1, #0
     8de:	d1b1      	bne.n	844 <CONFIG_ISR_STACK_SIZE+0x44>
     8e0:	e7d0      	b.n	884 <CONFIG_ISR_STACK_SIZE+0x84>
				notify_monitors(mgr, state, res);
     8e2:	464a      	mov	r2, r9
     8e4:	0031      	movs	r1, r6
     8e6:	0020      	movs	r0, r4
     8e8:	f003 fb13 	bl	3f12 <notify_monitors>
     8ec:	e7b4      	b.n	858 <CONFIG_ISR_STACK_SIZE+0x58>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     8ee:	069a      	lsls	r2, r3, #26
     8f0:	d504      	bpl.n	8fc <CONFIG_ISR_STACK_SIZE+0xfc>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     8f2:	2220      	movs	r2, #32
     8f4:	4393      	bics	r3, r2
     8f6:	8323      	strh	r3, [r4, #24]
			evt = EVT_RECHECK;
     8f8:	2002      	movs	r0, #2
     8fa:	e7ca      	b.n	892 <CONFIG_ISR_STACK_SIZE+0x92>
		evt = EVT_NOP;
     8fc:	2000      	movs	r0, #0
     8fe:	e7c8      	b.n	892 <CONFIG_ISR_STACK_SIZE+0x92>
     900:	000040b7 	.word	0x000040b7

00000904 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
     904:	b5f0      	push	{r4, r5, r6, r7, lr}
     906:	b083      	sub	sp, #12
     908:	0004      	movs	r4, r0
     90a:	000e      	movs	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
     90c:	f003 fb8d 	bl	402a <validate_args>
     910:	1e05      	subs	r5, r0, #0

	if (rv < 0) {
     912:	db39      	blt.n	988 <onoff_request+0x84>
     914:	f3ef 8210 	mrs	r2, PRIMASK
     918:	b672      	cpsid	i

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
     91a:	9201      	str	r2, [sp, #4]
		return rv;
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     91c:	8b23      	ldrh	r3, [r4, #24]
     91e:	2107      	movs	r1, #7
     920:	4019      	ands	r1, r3

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
     922:	8b67      	ldrh	r7, [r4, #26]
     924:	4d27      	ldr	r5, [pc, #156]	; (9c4 <onoff_request+0xc0>)
     926:	42af      	cmp	r7, r5
     928:	d037      	beq.n	99a <onoff_request+0x96>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
     92a:	000d      	movs	r5, r1
	if (state == ONOFF_STATE_ON) {
     92c:	2902      	cmp	r1, #2
     92e:	d00d      	beq.n	94c <onoff_request+0x48>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
	} else if ((state == ONOFF_STATE_OFF)
     930:	2900      	cmp	r1, #0
     932:	d011      	beq.n	958 <onoff_request+0x54>
		   || (state == ONOFF_STATE_TO_OFF)
     934:	2904      	cmp	r1, #4
     936:	d00f      	beq.n	958 <onoff_request+0x54>
		   || (state == ONOFF_STATE_TO_ON)) {
     938:	2906      	cmp	r1, #6
     93a:	d00d      	beq.n	958 <onoff_request+0x54>
		/* Start if OFF, queue client */
		start = (state == ONOFF_STATE_OFF);
		add_client = true;
	} else if (state == ONOFF_STATE_RESETTING) {
     93c:	2905      	cmp	r1, #5
     93e:	d026      	beq.n	98e <onoff_request+0x8a>
		rv = -ENOTSUP;
	} else {
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
		rv = -EIO;
     940:	2505      	movs	r5, #5
     942:	426d      	negs	r5, r5
	bool notify = false;            /* do client notification */
     944:	2000      	movs	r0, #0
	bool start = false;             /* trigger a start transition */
     946:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
     948:	2700      	movs	r7, #0
     94a:	e00a      	b.n	962 <onoff_request+0x5e>
		mgr->refs += 1U;
     94c:	3701      	adds	r7, #1
     94e:	8367      	strh	r7, [r4, #26]
		notify = true;
     950:	2001      	movs	r0, #1
	bool start = false;             /* trigger a start transition */
     952:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
     954:	2700      	movs	r7, #0
     956:	e004      	b.n	962 <onoff_request+0x5e>
		start = (state == ONOFF_STATE_OFF);
     958:	424b      	negs	r3, r1
     95a:	414b      	adcs	r3, r1
     95c:	b2db      	uxtb	r3, r3
	bool notify = false;            /* do client notification */
     95e:	2000      	movs	r0, #0
		add_client = true;
     960:	2701      	movs	r7, #1
	}

out:
	if (add_client) {
     962:	2f00      	cmp	r7, #0
     964:	d006      	beq.n	974 <onoff_request+0x70>
	return node->next;
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
	parent->next = child;
     966:	2700      	movs	r7, #0
     968:	6037      	str	r7, [r6, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
     96a:	6867      	ldr	r7, [r4, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
     96c:	2f00      	cmp	r7, #0
     96e:	d01a      	beq.n	9a6 <onoff_request+0xa2>
	parent->next = child;
     970:	603e      	str	r6, [r7, #0]
	list->tail = node;
     972:	6066      	str	r6, [r4, #4]
		sys_slist_append(&mgr->clients, &cli->node);
	}

	if (start) {
     974:	2b00      	cmp	r3, #0
     976:	d119      	bne.n	9ac <onoff_request+0xa8>
	if (key != 0U) {
     978:	9b01      	ldr	r3, [sp, #4]
     97a:	2b00      	cmp	r3, #0
     97c:	d102      	bne.n	984 <onoff_request+0x80>
	__asm__ volatile(
     97e:	b662      	cpsie	i
     980:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
     984:	2800      	cmp	r0, #0
     986:	d116      	bne.n	9b6 <onoff_request+0xb2>
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
     988:	0028      	movs	r0, r5
     98a:	b003      	add	sp, #12
     98c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		rv = -ENOTSUP;
     98e:	2586      	movs	r5, #134	; 0x86
     990:	426d      	negs	r5, r5
	bool notify = false;            /* do client notification */
     992:	2000      	movs	r0, #0
	bool start = false;             /* trigger a start transition */
     994:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
     996:	2700      	movs	r7, #0
     998:	e7e3      	b.n	962 <onoff_request+0x5e>
		rv = -EAGAIN;
     99a:	250b      	movs	r5, #11
     99c:	426d      	negs	r5, r5
	bool notify = false;            /* do client notification */
     99e:	2000      	movs	r0, #0
	bool start = false;             /* trigger a start transition */
     9a0:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
     9a2:	2700      	movs	r7, #0
     9a4:	e7dd      	b.n	962 <onoff_request+0x5e>
     9a6:	6066      	str	r6, [r4, #4]
	list->head = node;
     9a8:	6026      	str	r6, [r4, #0]
}
     9aa:	e7e3      	b.n	974 <onoff_request+0x70>
		process_event(mgr, EVT_RECHECK, key);
     9ac:	2102      	movs	r1, #2
     9ae:	0020      	movs	r0, r4
     9b0:	f7ff fef4 	bl	79c <process_event>
     9b4:	e7e8      	b.n	988 <onoff_request+0x84>
			notify_one(mgr, cli, state, 0);
     9b6:	2300      	movs	r3, #0
     9b8:	000a      	movs	r2, r1
     9ba:	0031      	movs	r1, r6
     9bc:	0020      	movs	r0, r4
     9be:	f003 fb4d 	bl	405c <notify_one>
     9c2:	e7e1      	b.n	988 <onoff_request+0x84>
     9c4:	0000ffff 	.word	0x0000ffff

000009c8 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
     9c8:	b5f0      	push	{r4, r5, r6, r7, lr}
     9ca:	46de      	mov	lr, fp
     9cc:	4657      	mov	r7, sl
     9ce:	464e      	mov	r6, r9
     9d0:	4645      	mov	r5, r8
     9d2:	b5e0      	push	{r5, r6, r7, lr}
     9d4:	b095      	sub	sp, #84	; 0x54
     9d6:	0005      	movs	r5, r0
     9d8:	4689      	mov	r9, r1
     9da:	0017      	movs	r7, r2
     9dc:	9305      	str	r3, [sp, #20]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
     9de:	2400      	movs	r4, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
     9e0:	7838      	ldrb	r0, [r7, #0]
     9e2:	2800      	cmp	r0, #0
     9e4:	d101      	bne.n	9ea <cbvprintf+0x22>
     9e6:	f000 fc26 	bl	1236 <CONFIG_FPROTECT_BLOCK_SIZE+0x236>
		if (*fp != '%') {
     9ea:	2825      	cmp	r0, #37	; 0x25
     9ec:	d008      	beq.n	a00 <cbvprintf+0x38>
			OUTC(*fp++);
     9ee:	3701      	adds	r7, #1
     9f0:	4649      	mov	r1, r9
     9f2:	47a8      	blx	r5
     9f4:	2800      	cmp	r0, #0
     9f6:	da01      	bge.n	9fc <cbvprintf+0x34>
     9f8:	f000 fc1e 	bl	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
     9fc:	3401      	adds	r4, #1
			continue;
     9fe:	e7ef      	b.n	9e0 <cbvprintf+0x18>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
     a00:	2218      	movs	r2, #24
     a02:	2100      	movs	r1, #0
     a04:	a808      	add	r0, sp, #32
     a06:	f003 fdcb 	bl	45a0 <memset>
	*conv = (struct conversion) {
     a0a:	220c      	movs	r2, #12
     a0c:	2100      	movs	r1, #0
     a0e:	a80a      	add	r0, sp, #40	; 0x28
     a10:	f003 fdc6 	bl	45a0 <memset>
	++sp;
     a14:	1c7a      	adds	r2, r7, #1
	if (*sp == '%') {
     a16:	787b      	ldrb	r3, [r7, #1]
     a18:	2b25      	cmp	r3, #37	; 0x25
     a1a:	d001      	beq.n	a20 <cbvprintf+0x58>
	bool loop = true;
     a1c:	2601      	movs	r6, #1
     a1e:	e028      	b.n	a72 <cbvprintf+0xaa>
		conv->specifier = *sp++;
     a20:	1cba      	adds	r2, r7, #2
     a22:	9203      	str	r2, [sp, #12]
     a24:	aa08      	add	r2, sp, #32
     a26:	72d3      	strb	r3, [r2, #11]
		return sp;
     a28:	e130      	b.n	c8c <cbvprintf+0x2c4>
			conv->flag_dash = true;
     a2a:	a908      	add	r1, sp, #32
     a2c:	7a0b      	ldrb	r3, [r1, #8]
     a2e:	2004      	movs	r0, #4
     a30:	4303      	orrs	r3, r0
     a32:	720b      	strb	r3, [r1, #8]
		if (loop) {
     a34:	2e00      	cmp	r6, #0
     a36:	d01a      	beq.n	a6e <cbvprintf+0xa6>
			++sp;
     a38:	3201      	adds	r2, #1
     a3a:	e018      	b.n	a6e <cbvprintf+0xa6>
			conv->flag_plus = true;
     a3c:	a908      	add	r1, sp, #32
     a3e:	7a0b      	ldrb	r3, [r1, #8]
     a40:	2008      	movs	r0, #8
     a42:	4303      	orrs	r3, r0
     a44:	720b      	strb	r3, [r1, #8]
			break;
     a46:	e7f5      	b.n	a34 <cbvprintf+0x6c>
			conv->flag_space = true;
     a48:	a908      	add	r1, sp, #32
     a4a:	7a0b      	ldrb	r3, [r1, #8]
     a4c:	2010      	movs	r0, #16
     a4e:	4303      	orrs	r3, r0
     a50:	720b      	strb	r3, [r1, #8]
			break;
     a52:	e7ef      	b.n	a34 <cbvprintf+0x6c>
			conv->flag_hash = true;
     a54:	a908      	add	r1, sp, #32
     a56:	7a0b      	ldrb	r3, [r1, #8]
     a58:	2020      	movs	r0, #32
     a5a:	4303      	orrs	r3, r0
     a5c:	720b      	strb	r3, [r1, #8]
			break;
     a5e:	e7e9      	b.n	a34 <cbvprintf+0x6c>
			conv->flag_zero = true;
     a60:	a908      	add	r1, sp, #32
     a62:	7a0b      	ldrb	r3, [r1, #8]
     a64:	2040      	movs	r0, #64	; 0x40
     a66:	4303      	orrs	r3, r0
     a68:	720b      	strb	r3, [r1, #8]
			break;
     a6a:	e7e3      	b.n	a34 <cbvprintf+0x6c>
		switch (*sp) {
     a6c:	2600      	movs	r6, #0
	} while (loop);
     a6e:	2e00      	cmp	r6, #0
     a70:	d008      	beq.n	a84 <cbvprintf+0xbc>
		switch (*sp) {
     a72:	7813      	ldrb	r3, [r2, #0]
     a74:	3b20      	subs	r3, #32
     a76:	b2d9      	uxtb	r1, r3
     a78:	2910      	cmp	r1, #16
     a7a:	d8f7      	bhi.n	a6c <cbvprintf+0xa4>
     a7c:	008b      	lsls	r3, r1, #2
     a7e:	49db      	ldr	r1, [pc, #876]	; (dec <cbvprintf+0x424>)
     a80:	58cb      	ldr	r3, [r1, r3]
     a82:	469f      	mov	pc, r3
	if (conv->flag_zero && conv->flag_dash) {
     a84:	ab08      	add	r3, sp, #32
     a86:	7a19      	ldrb	r1, [r3, #8]
     a88:	2344      	movs	r3, #68	; 0x44
     a8a:	400b      	ands	r3, r1
     a8c:	2b44      	cmp	r3, #68	; 0x44
     a8e:	d05e      	beq.n	b4e <cbvprintf+0x186>
	sp = extract_width(conv, sp);
     a90:	9207      	str	r2, [sp, #28]
	conv->width_present = true;
     a92:	a908      	add	r1, sp, #32
     a94:	7a08      	ldrb	r0, [r1, #8]
     a96:	2380      	movs	r3, #128	; 0x80
     a98:	425b      	negs	r3, r3
     a9a:	4303      	orrs	r3, r0
     a9c:	720b      	strb	r3, [r1, #8]
	if (*sp == '*') {
     a9e:	9203      	str	r2, [sp, #12]
     aa0:	7813      	ldrb	r3, [r2, #0]
     aa2:	2b2a      	cmp	r3, #42	; 0x2a
     aa4:	d059      	beq.n	b5a <cbvprintf+0x192>
	size_t width = extract_decimal(&sp);
     aa6:	a807      	add	r0, sp, #28
     aa8:	f003 fc4e 	bl	4348 <extract_decimal>
	if (sp != wp) {
     aac:	9b03      	ldr	r3, [sp, #12]
     aae:	9a07      	ldr	r2, [sp, #28]
     ab0:	4293      	cmp	r3, r2
     ab2:	d013      	beq.n	adc <cbvprintf+0x114>
		conv->width_present = true;
     ab4:	aa08      	add	r2, sp, #32
     ab6:	7a11      	ldrb	r1, [r2, #8]
     ab8:	2380      	movs	r3, #128	; 0x80
     aba:	425b      	negs	r3, r3
     abc:	430b      	orrs	r3, r1
     abe:	7213      	strb	r3, [r2, #8]
		conv->width_value = width;
     ac0:	900b      	str	r0, [sp, #44]	; 0x2c
		conv->unsupported |= ((conv->width_value < 0)
     ac2:	079b      	lsls	r3, r3, #30
     ac4:	0fdb      	lsrs	r3, r3, #31
				      || (width != (size_t)conv->width_value));
     ac6:	2800      	cmp	r0, #0
     ac8:	db4f      	blt.n	b6a <cbvprintf+0x1a2>
     aca:	2100      	movs	r1, #0
		conv->unsupported |= ((conv->width_value < 0)
     acc:	aa08      	add	r2, sp, #32
     ace:	430b      	orrs	r3, r1
     ad0:	005b      	lsls	r3, r3, #1
     ad2:	7a11      	ldrb	r1, [r2, #8]
     ad4:	2002      	movs	r0, #2
     ad6:	4381      	bics	r1, r0
     ad8:	430b      	orrs	r3, r1
     ada:	7213      	strb	r3, [r2, #8]
	return sp;
     adc:	9b07      	ldr	r3, [sp, #28]
	sp = extract_prec(conv, sp);
     ade:	9307      	str	r3, [sp, #28]
	conv->prec_present = (*sp == '.');
     ae0:	781b      	ldrb	r3, [r3, #0]
     ae2:	3b2e      	subs	r3, #46	; 0x2e
     ae4:	425a      	negs	r2, r3
     ae6:	4153      	adcs	r3, r2
     ae8:	b2db      	uxtb	r3, r3
     aea:	a908      	add	r1, sp, #32
     aec:	005a      	lsls	r2, r3, #1
     aee:	4692      	mov	sl, r2
     af0:	7a4a      	ldrb	r2, [r1, #9]
     af2:	4690      	mov	r8, r2
     af4:	2202      	movs	r2, #2
     af6:	4640      	mov	r0, r8
     af8:	4390      	bics	r0, r2
     afa:	0002      	movs	r2, r0
     afc:	4650      	mov	r0, sl
     afe:	4302      	orrs	r2, r0
     b00:	724a      	strb	r2, [r1, #9]
	if (!conv->prec_present) {
     b02:	2b00      	cmp	r3, #0
     b04:	d033      	beq.n	b6e <cbvprintf+0x1a6>
	++sp;
     b06:	9b07      	ldr	r3, [sp, #28]
     b08:	1c5a      	adds	r2, r3, #1
     b0a:	9207      	str	r2, [sp, #28]
	if (*sp == '*') {
     b0c:	785b      	ldrb	r3, [r3, #1]
     b0e:	2b2a      	cmp	r3, #42	; 0x2a
     b10:	d02f      	beq.n	b72 <cbvprintf+0x1aa>
	size_t prec = extract_decimal(&sp);
     b12:	a807      	add	r0, sp, #28
     b14:	f003 fc18 	bl	4348 <extract_decimal>
	conv->prec_value = prec;
     b18:	ab08      	add	r3, sp, #32
     b1a:	900c      	str	r0, [sp, #48]	; 0x30
	conv->unsupported |= ((conv->prec_value < 0)
     b1c:	7a1b      	ldrb	r3, [r3, #8]
     b1e:	079b      	lsls	r3, r3, #30
     b20:	0fdb      	lsrs	r3, r3, #31
			      || (prec != (size_t)conv->prec_value));
     b22:	2800      	cmp	r0, #0
     b24:	db2d      	blt.n	b82 <cbvprintf+0x1ba>
     b26:	2100      	movs	r1, #0
	conv->unsupported |= ((conv->prec_value < 0)
     b28:	aa08      	add	r2, sp, #32
     b2a:	430b      	orrs	r3, r1
     b2c:	005b      	lsls	r3, r3, #1
     b2e:	7a11      	ldrb	r1, [r2, #8]
     b30:	2002      	movs	r0, #2
     b32:	4381      	bics	r1, r0
     b34:	430b      	orrs	r3, r1
     b36:	7213      	strb	r3, [r2, #8]
	return sp;
     b38:	9a07      	ldr	r2, [sp, #28]
	switch (*sp) {
     b3a:	7813      	ldrb	r3, [r2, #0]
     b3c:	3b4c      	subs	r3, #76	; 0x4c
     b3e:	b2d9      	uxtb	r1, r3
     b40:	292e      	cmp	r1, #46	; 0x2e
     b42:	d900      	bls.n	b46 <cbvprintf+0x17e>
     b44:	e081      	b.n	c4a <cbvprintf+0x282>
     b46:	008b      	lsls	r3, r1, #2
     b48:	49a9      	ldr	r1, [pc, #676]	; (df0 <cbvprintf+0x428>)
     b4a:	58cb      	ldr	r3, [r1, r3]
     b4c:	469f      	mov	pc, r3
		conv->flag_zero = false;
     b4e:	a908      	add	r1, sp, #32
     b50:	7a0b      	ldrb	r3, [r1, #8]
     b52:	2040      	movs	r0, #64	; 0x40
     b54:	4383      	bics	r3, r0
     b56:	720b      	strb	r3, [r1, #8]
     b58:	e79a      	b.n	a90 <cbvprintf+0xc8>
		conv->width_star = true;
     b5a:	000a      	movs	r2, r1
     b5c:	7a4b      	ldrb	r3, [r1, #9]
     b5e:	2101      	movs	r1, #1
     b60:	430b      	orrs	r3, r1
     b62:	7253      	strb	r3, [r2, #9]
		return ++sp;
     b64:	9b07      	ldr	r3, [sp, #28]
     b66:	3301      	adds	r3, #1
     b68:	e7b9      	b.n	ade <cbvprintf+0x116>
				      || (width != (size_t)conv->width_value));
     b6a:	2101      	movs	r1, #1
     b6c:	e7ae      	b.n	acc <cbvprintf+0x104>
		return sp;
     b6e:	9a07      	ldr	r2, [sp, #28]
     b70:	e7e3      	b.n	b3a <cbvprintf+0x172>
		conv->prec_star = true;
     b72:	aa08      	add	r2, sp, #32
     b74:	7a53      	ldrb	r3, [r2, #9]
     b76:	2104      	movs	r1, #4
     b78:	430b      	orrs	r3, r1
     b7a:	7253      	strb	r3, [r2, #9]
		return ++sp;
     b7c:	9b07      	ldr	r3, [sp, #28]
     b7e:	1c5a      	adds	r2, r3, #1
     b80:	e7db      	b.n	b3a <cbvprintf+0x172>
			      || (prec != (size_t)conv->prec_value));
     b82:	2101      	movs	r1, #1
     b84:	e7d0      	b.n	b28 <cbvprintf+0x160>
		if (*++sp == 'h') {
     b86:	1c51      	adds	r1, r2, #1
     b88:	7853      	ldrb	r3, [r2, #1]
     b8a:	2b68      	cmp	r3, #104	; 0x68
     b8c:	d008      	beq.n	ba0 <cbvprintf+0x1d8>
			conv->length_mod = LENGTH_H;
     b8e:	aa08      	add	r2, sp, #32
     b90:	7a53      	ldrb	r3, [r2, #9]
     b92:	2078      	movs	r0, #120	; 0x78
     b94:	4383      	bics	r3, r0
     b96:	2010      	movs	r0, #16
     b98:	4303      	orrs	r3, r0
     b9a:	7253      	strb	r3, [r2, #9]
		if (*++sp == 'h') {
     b9c:	000a      	movs	r2, r1
     b9e:	e026      	b.n	bee <cbvprintf+0x226>
			conv->length_mod = LENGTH_HH;
     ba0:	a908      	add	r1, sp, #32
     ba2:	7a4b      	ldrb	r3, [r1, #9]
     ba4:	2078      	movs	r0, #120	; 0x78
     ba6:	4383      	bics	r3, r0
     ba8:	2008      	movs	r0, #8
     baa:	4303      	orrs	r3, r0
     bac:	724b      	strb	r3, [r1, #9]
			++sp;
     bae:	3202      	adds	r2, #2
     bb0:	e01d      	b.n	bee <cbvprintf+0x226>
		if (*++sp == 'l') {
     bb2:	1c51      	adds	r1, r2, #1
     bb4:	7853      	ldrb	r3, [r2, #1]
     bb6:	2b6c      	cmp	r3, #108	; 0x6c
     bb8:	d008      	beq.n	bcc <cbvprintf+0x204>
			conv->length_mod = LENGTH_L;
     bba:	aa08      	add	r2, sp, #32
     bbc:	7a53      	ldrb	r3, [r2, #9]
     bbe:	2078      	movs	r0, #120	; 0x78
     bc0:	4383      	bics	r3, r0
     bc2:	2018      	movs	r0, #24
     bc4:	4303      	orrs	r3, r0
     bc6:	7253      	strb	r3, [r2, #9]
		if (*++sp == 'l') {
     bc8:	000a      	movs	r2, r1
     bca:	e010      	b.n	bee <cbvprintf+0x226>
			conv->length_mod = LENGTH_LL;
     bcc:	a908      	add	r1, sp, #32
     bce:	7a4b      	ldrb	r3, [r1, #9]
     bd0:	2078      	movs	r0, #120	; 0x78
     bd2:	4383      	bics	r3, r0
     bd4:	2020      	movs	r0, #32
     bd6:	4303      	orrs	r3, r0
     bd8:	724b      	strb	r3, [r1, #9]
			++sp;
     bda:	3202      	adds	r2, #2
     bdc:	e007      	b.n	bee <cbvprintf+0x226>
		conv->length_mod = LENGTH_J;
     bde:	a908      	add	r1, sp, #32
     be0:	7a4b      	ldrb	r3, [r1, #9]
     be2:	2078      	movs	r0, #120	; 0x78
     be4:	4383      	bics	r3, r0
     be6:	2028      	movs	r0, #40	; 0x28
     be8:	4303      	orrs	r3, r0
     bea:	724b      	strb	r3, [r1, #9]
		++sp;
     bec:	3201      	adds	r2, #1
	conv->specifier = *sp++;
     bee:	1c53      	adds	r3, r2, #1
     bf0:	9303      	str	r3, [sp, #12]
     bf2:	7812      	ldrb	r2, [r2, #0]
     bf4:	ab08      	add	r3, sp, #32
     bf6:	72da      	strb	r2, [r3, #11]
	switch (conv->specifier) {
     bf8:	0013      	movs	r3, r2
     bfa:	3b41      	subs	r3, #65	; 0x41
     bfc:	b2d9      	uxtb	r1, r3
     bfe:	2937      	cmp	r1, #55	; 0x37
     c00:	d900      	bls.n	c04 <cbvprintf+0x23c>
     c02:	e0c5      	b.n	d90 <cbvprintf+0x3c8>
     c04:	008b      	lsls	r3, r1, #2
     c06:	497b      	ldr	r1, [pc, #492]	; (df4 <cbvprintf+0x42c>)
     c08:	58cb      	ldr	r3, [r1, r3]
     c0a:	469f      	mov	pc, r3
		conv->length_mod = LENGTH_Z;
     c0c:	a908      	add	r1, sp, #32
     c0e:	7a4b      	ldrb	r3, [r1, #9]
     c10:	2078      	movs	r0, #120	; 0x78
     c12:	4383      	bics	r3, r0
     c14:	2030      	movs	r0, #48	; 0x30
     c16:	4303      	orrs	r3, r0
     c18:	724b      	strb	r3, [r1, #9]
		++sp;
     c1a:	3201      	adds	r2, #1
		break;
     c1c:	e7e7      	b.n	bee <cbvprintf+0x226>
		conv->length_mod = LENGTH_T;
     c1e:	a908      	add	r1, sp, #32
     c20:	7a4b      	ldrb	r3, [r1, #9]
     c22:	2078      	movs	r0, #120	; 0x78
     c24:	4383      	bics	r3, r0
     c26:	2038      	movs	r0, #56	; 0x38
     c28:	4303      	orrs	r3, r0
     c2a:	724b      	strb	r3, [r1, #9]
		++sp;
     c2c:	3201      	adds	r2, #1
		break;
     c2e:	e7de      	b.n	bee <cbvprintf+0x226>
		conv->length_mod = LENGTH_UPPER_L;
     c30:	a908      	add	r1, sp, #32
     c32:	7a4b      	ldrb	r3, [r1, #9]
     c34:	2078      	movs	r0, #120	; 0x78
     c36:	4383      	bics	r3, r0
     c38:	2040      	movs	r0, #64	; 0x40
     c3a:	4303      	orrs	r3, r0
     c3c:	724b      	strb	r3, [r1, #9]
		++sp;
     c3e:	3201      	adds	r2, #1
		conv->unsupported = true;
     c40:	7a0b      	ldrb	r3, [r1, #8]
     c42:	2002      	movs	r0, #2
     c44:	4303      	orrs	r3, r0
     c46:	720b      	strb	r3, [r1, #8]
		break;
     c48:	e7d1      	b.n	bee <cbvprintf+0x226>
		conv->length_mod = LENGTH_NONE;
     c4a:	a908      	add	r1, sp, #32
     c4c:	7a4b      	ldrb	r3, [r1, #9]
     c4e:	2078      	movs	r0, #120	; 0x78
     c50:	4383      	bics	r3, r0
     c52:	724b      	strb	r3, [r1, #9]
		break;
     c54:	e7cb      	b.n	bee <cbvprintf+0x226>
		conv->specifier_cat = SPECIFIER_SINT;
     c56:	a908      	add	r1, sp, #32
     c58:	7a8b      	ldrb	r3, [r1, #10]
     c5a:	2007      	movs	r0, #7
     c5c:	4383      	bics	r3, r0
     c5e:	2001      	movs	r0, #1
     c60:	4303      	orrs	r3, r0
     c62:	728b      	strb	r3, [r1, #10]
		if (conv->length_mod == LENGTH_UPPER_L) {
     c64:	ab08      	add	r3, sp, #32
     c66:	7a59      	ldrb	r1, [r3, #9]
     c68:	2378      	movs	r3, #120	; 0x78
     c6a:	400b      	ands	r3, r1
     c6c:	2b40      	cmp	r3, #64	; 0x40
     c6e:	d059      	beq.n	d24 <cbvprintf+0x35c>
		if (conv->specifier == 'c') {
     c70:	2a63      	cmp	r2, #99	; 0x63
     c72:	d064      	beq.n	d3e <cbvprintf+0x376>
	conv->unsupported |= unsupported;
     c74:	a908      	add	r1, sp, #32
     c76:	7a0a      	ldrb	r2, [r1, #8]
     c78:	0793      	lsls	r3, r2, #30
     c7a:	0fdb      	lsrs	r3, r3, #31
     c7c:	4333      	orrs	r3, r6
     c7e:	2001      	movs	r0, #1
     c80:	4003      	ands	r3, r0
     c82:	005b      	lsls	r3, r3, #1
     c84:	3001      	adds	r0, #1
     c86:	4382      	bics	r2, r0
     c88:	431a      	orrs	r2, r3
     c8a:	720a      	strb	r2, [r1, #8]
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
     c8c:	ab08      	add	r3, sp, #32
     c8e:	7a5b      	ldrb	r3, [r3, #9]
     c90:	07db      	lsls	r3, r3, #31
     c92:	d400      	bmi.n	c96 <cbvprintf+0x2ce>
     c94:	e08b      	b.n	dae <cbvprintf+0x3e6>
			width = va_arg(ap, int);
     c96:	9b05      	ldr	r3, [sp, #20]
     c98:	1d1a      	adds	r2, r3, #4
     c9a:	9205      	str	r2, [sp, #20]
     c9c:	681b      	ldr	r3, [r3, #0]
     c9e:	4698      	mov	r8, r3

			if (width < 0) {
     ca0:	2b00      	cmp	r3, #0
     ca2:	db7b      	blt.n	d9c <cbvprintf+0x3d4>

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
     ca4:	ab08      	add	r3, sp, #32
     ca6:	7a5b      	ldrb	r3, [r3, #9]
     ca8:	075a      	lsls	r2, r3, #29
     caa:	d400      	bmi.n	cae <cbvprintf+0x2e6>
     cac:	e094      	b.n	dd8 <cbvprintf+0x410>
			int arg = va_arg(ap, int);
     cae:	9b05      	ldr	r3, [sp, #20]
     cb0:	1d1a      	adds	r2, r3, #4
     cb2:	9205      	str	r2, [sp, #20]
     cb4:	681b      	ldr	r3, [r3, #0]
     cb6:	469a      	mov	sl, r3

			if (arg < 0) {
     cb8:	2b00      	cmp	r3, #0
     cba:	da00      	bge.n	cbe <cbvprintf+0x2f6>
     cbc:	e083      	b.n	dc6 <cbvprintf+0x3fe>
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv->pad0_value = 0;
     cbe:	ab08      	add	r3, sp, #32
     cc0:	2200      	movs	r2, #0
     cc2:	920b      	str	r2, [sp, #44]	; 0x2c
		conv->pad0_pre_exp = 0;
     cc4:	920c      	str	r2, [sp, #48]	; 0x30
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
     cc6:	7a9a      	ldrb	r2, [r3, #10]
     cc8:	0752      	lsls	r2, r2, #29
     cca:	0f52      	lsrs	r2, r2, #29
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
     ccc:	7a5b      	ldrb	r3, [r3, #9]
     cce:	065b      	lsls	r3, r3, #25
     cd0:	0f1b      	lsrs	r3, r3, #28
		enum length_mod_enum length_mod
     cd2:	0019      	movs	r1, r3
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
     cd4:	2a01      	cmp	r2, #1
     cd6:	d100      	bne.n	cda <cbvprintf+0x312>
     cd8:	e090      	b.n	dfc <cbvprintf+0x434>
			if (length_mod == LENGTH_HH) {
				value->sint = (char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
     cda:	2a02      	cmp	r2, #2
     cdc:	d100      	bne.n	ce0 <cbvprintf+0x318>
     cde:	e0da      	b.n	e96 <cbvprintf+0x4ce>
			if (length_mod == LENGTH_HH) {
				value->uint = (unsigned char)value->uint;
			} else if (length_mod == LENGTH_H) {
				value->uint = (unsigned short)value->uint;
			}
		} else if (specifier_cat == SPECIFIER_FP) {
     ce0:	2a04      	cmp	r2, #4
     ce2:	d100      	bne.n	ce6 <cbvprintf+0x31e>
     ce4:	e131      	b.n	f4a <cbvprintf+0x582>
			if (length_mod == LENGTH_UPPER_L) {
				value->ldbl = va_arg(ap, long double);
			} else {
				value->dbl = va_arg(ap, double);
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
     ce6:	2a03      	cmp	r2, #3
     ce8:	d100      	bne.n	cec <cbvprintf+0x324>
     cea:	e148      	b.n	f7e <cbvprintf+0x5b6>
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
     cec:	ab08      	add	r3, sp, #32
     cee:	7a1a      	ldrb	r2, [r3, #8]
     cf0:	2303      	movs	r3, #3
     cf2:	0019      	movs	r1, r3
     cf4:	4011      	ands	r1, r2
     cf6:	468b      	mov	fp, r1
     cf8:	4213      	tst	r3, r2
     cfa:	d000      	beq.n	cfe <cbvprintf+0x336>
     cfc:	e145      	b.n	f8a <cbvprintf+0x5c2>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
     cfe:	ab08      	add	r3, sp, #32
     d00:	7adb      	ldrb	r3, [r3, #11]
     d02:	3b25      	subs	r3, #37	; 0x25
     d04:	b2d9      	uxtb	r1, r3
     d06:	2953      	cmp	r1, #83	; 0x53
     d08:	d900      	bls.n	d0c <cbvprintf+0x344>
     d0a:	e1f3      	b.n	10f4 <CONFIG_FPROTECT_BLOCK_SIZE+0xf4>
     d0c:	008b      	lsls	r3, r1, #2
     d0e:	493a      	ldr	r1, [pc, #232]	; (df8 <cbvprintf+0x430>)
     d10:	58cb      	ldr	r3, [r1, r3]
     d12:	469f      	mov	pc, r3
		conv->specifier_cat = SPECIFIER_UINT;
     d14:	a908      	add	r1, sp, #32
     d16:	7a8b      	ldrb	r3, [r1, #10]
     d18:	2007      	movs	r0, #7
     d1a:	4383      	bics	r3, r0
     d1c:	2002      	movs	r0, #2
     d1e:	4303      	orrs	r3, r0
     d20:	728b      	strb	r3, [r1, #10]
     d22:	e79f      	b.n	c64 <cbvprintf+0x29c>
			conv->invalid = true;
     d24:	a908      	add	r1, sp, #32
     d26:	9104      	str	r1, [sp, #16]
     d28:	7a09      	ldrb	r1, [r1, #8]
     d2a:	4688      	mov	r8, r1
     d2c:	2101      	movs	r1, #1
     d2e:	468c      	mov	ip, r1
     d30:	4661      	mov	r1, ip
     d32:	4640      	mov	r0, r8
     d34:	4308      	orrs	r0, r1
     d36:	0001      	movs	r1, r0
     d38:	9804      	ldr	r0, [sp, #16]
     d3a:	7201      	strb	r1, [r0, #8]
     d3c:	e798      	b.n	c70 <cbvprintf+0x2a8>
			unsupported = (conv->length_mod != LENGTH_NONE);
     d3e:	1e5a      	subs	r2, r3, #1
     d40:	4193      	sbcs	r3, r2
     d42:	b2de      	uxtb	r6, r3
     d44:	e796      	b.n	c74 <cbvprintf+0x2ac>
		conv->specifier_cat = SPECIFIER_FP;
     d46:	aa08      	add	r2, sp, #32
     d48:	7a93      	ldrb	r3, [r2, #10]
     d4a:	2107      	movs	r1, #7
     d4c:	438b      	bics	r3, r1
     d4e:	2104      	movs	r1, #4
     d50:	430b      	orrs	r3, r1
     d52:	7293      	strb	r3, [r2, #10]
			unsupported = true;
     d54:	2601      	movs	r6, #1
			break;
     d56:	e78d      	b.n	c74 <cbvprintf+0x2ac>
		conv->specifier_cat = SPECIFIER_PTR;
     d58:	aa08      	add	r2, sp, #32
     d5a:	7a93      	ldrb	r3, [r2, #10]
     d5c:	2107      	movs	r1, #7
     d5e:	438b      	bics	r3, r1
     d60:	2103      	movs	r1, #3
     d62:	430b      	orrs	r3, r1
     d64:	7293      	strb	r3, [r2, #10]
		if (conv->length_mod == LENGTH_UPPER_L) {
     d66:	7a52      	ldrb	r2, [r2, #9]
     d68:	2378      	movs	r3, #120	; 0x78
     d6a:	4013      	ands	r3, r2
     d6c:	2b40      	cmp	r3, #64	; 0x40
     d6e:	d181      	bne.n	c74 <cbvprintf+0x2ac>
			unsupported = true;
     d70:	2601      	movs	r6, #1
     d72:	e77f      	b.n	c74 <cbvprintf+0x2ac>
		conv->specifier_cat = SPECIFIER_PTR;
     d74:	aa08      	add	r2, sp, #32
     d76:	7a93      	ldrb	r3, [r2, #10]
     d78:	2107      	movs	r1, #7
     d7a:	438b      	bics	r3, r1
     d7c:	2103      	movs	r1, #3
     d7e:	430b      	orrs	r3, r1
     d80:	7293      	strb	r3, [r2, #10]
		if (conv->length_mod != LENGTH_NONE) {
     d82:	7a53      	ldrb	r3, [r2, #9]
     d84:	2278      	movs	r2, #120	; 0x78
     d86:	421a      	tst	r2, r3
     d88:	d100      	bne.n	d8c <cbvprintf+0x3c4>
     d8a:	e773      	b.n	c74 <cbvprintf+0x2ac>
			unsupported = true;
     d8c:	2601      	movs	r6, #1
     d8e:	e771      	b.n	c74 <cbvprintf+0x2ac>
		conv->invalid = true;
     d90:	aa08      	add	r2, sp, #32
     d92:	7a13      	ldrb	r3, [r2, #8]
     d94:	2101      	movs	r1, #1
     d96:	430b      	orrs	r3, r1
     d98:	7213      	strb	r3, [r2, #8]
		break;
     d9a:	e76b      	b.n	c74 <cbvprintf+0x2ac>
				conv->flag_dash = true;
     d9c:	aa08      	add	r2, sp, #32
     d9e:	7a13      	ldrb	r3, [r2, #8]
     da0:	2104      	movs	r1, #4
     da2:	430b      	orrs	r3, r1
     da4:	7213      	strb	r3, [r2, #8]
				width = -width;
     da6:	4643      	mov	r3, r8
     da8:	425b      	negs	r3, r3
     daa:	4698      	mov	r8, r3
     dac:	e77a      	b.n	ca4 <cbvprintf+0x2dc>
		} else if (conv->width_present) {
     dae:	ab08      	add	r3, sp, #32
     db0:	7a1b      	ldrb	r3, [r3, #8]
     db2:	b25b      	sxtb	r3, r3
     db4:	2b00      	cmp	r3, #0
     db6:	db03      	blt.n	dc0 <cbvprintf+0x3f8>
		int width = -1;
     db8:	2301      	movs	r3, #1
     dba:	425b      	negs	r3, r3
     dbc:	4698      	mov	r8, r3
     dbe:	e771      	b.n	ca4 <cbvprintf+0x2dc>
			width = conv->width_value;
     dc0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     dc2:	4698      	mov	r8, r3
     dc4:	e76e      	b.n	ca4 <cbvprintf+0x2dc>
				conv->prec_present = false;
     dc6:	aa08      	add	r2, sp, #32
     dc8:	7a53      	ldrb	r3, [r2, #9]
     dca:	2102      	movs	r1, #2
     dcc:	438b      	bics	r3, r1
     dce:	7253      	strb	r3, [r2, #9]
		int precision = -1;
     dd0:	2301      	movs	r3, #1
     dd2:	425b      	negs	r3, r3
     dd4:	469a      	mov	sl, r3
     dd6:	e772      	b.n	cbe <cbvprintf+0x2f6>
		} else if (conv->prec_present) {
     dd8:	079b      	lsls	r3, r3, #30
     dda:	d502      	bpl.n	de2 <cbvprintf+0x41a>
			precision = conv->prec_value;
     ddc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     dde:	469a      	mov	sl, r3
     de0:	e76d      	b.n	cbe <cbvprintf+0x2f6>
		int precision = -1;
     de2:	2301      	movs	r3, #1
     de4:	425b      	negs	r3, r3
     de6:	469a      	mov	sl, r3
     de8:	e769      	b.n	cbe <cbvprintf+0x2f6>
     dea:	46c0      	nop			; (mov r8, r8)
     dec:	00005334 	.word	0x00005334
     df0:	00005378 	.word	0x00005378
     df4:	00005434 	.word	0x00005434
     df8:	00005514 	.word	0x00005514
			switch (length_mod) {
     dfc:	2b05      	cmp	r3, #5
     dfe:	d037      	beq.n	e70 <cbvprintf+0x4a8>
     e00:	d80f      	bhi.n	e22 <cbvprintf+0x45a>
     e02:	2b03      	cmp	r3, #3
     e04:	d02c      	beq.n	e60 <cbvprintf+0x498>
     e06:	2b04      	cmp	r3, #4
     e08:	d118      	bne.n	e3c <cbvprintf+0x474>
					(sint_value_type)va_arg(ap, long long);
     e0a:	9b05      	ldr	r3, [sp, #20]
     e0c:	3307      	adds	r3, #7
     e0e:	2207      	movs	r2, #7
     e10:	4393      	bics	r3, r2
     e12:	001a      	movs	r2, r3
     e14:	3208      	adds	r2, #8
     e16:	9205      	str	r2, [sp, #20]
     e18:	681a      	ldr	r2, [r3, #0]
     e1a:	685b      	ldr	r3, [r3, #4]
     e1c:	9208      	str	r2, [sp, #32]
     e1e:	9309      	str	r3, [sp, #36]	; 0x24
				break;
     e20:	e013      	b.n	e4a <cbvprintf+0x482>
			switch (length_mod) {
     e22:	330a      	adds	r3, #10
     e24:	220f      	movs	r2, #15
     e26:	4013      	ands	r3, r2
     e28:	2b01      	cmp	r3, #1
     e2a:	d807      	bhi.n	e3c <cbvprintf+0x474>
					(sint_value_type)va_arg(ap, ptrdiff_t);
     e2c:	9b05      	ldr	r3, [sp, #20]
     e2e:	1d1a      	adds	r2, r3, #4
     e30:	9205      	str	r2, [sp, #20]
     e32:	681b      	ldr	r3, [r3, #0]
     e34:	17da      	asrs	r2, r3, #31
				value->sint =
     e36:	9308      	str	r3, [sp, #32]
     e38:	9209      	str	r2, [sp, #36]	; 0x24
				break;
     e3a:	e006      	b.n	e4a <cbvprintf+0x482>
				value->sint = va_arg(ap, int);
     e3c:	9b05      	ldr	r3, [sp, #20]
     e3e:	1d1a      	adds	r2, r3, #4
     e40:	9205      	str	r2, [sp, #20]
     e42:	681b      	ldr	r3, [r3, #0]
     e44:	17da      	asrs	r2, r3, #31
     e46:	9308      	str	r3, [sp, #32]
     e48:	9209      	str	r2, [sp, #36]	; 0x24
			if (length_mod == LENGTH_HH) {
     e4a:	2901      	cmp	r1, #1
     e4c:	d01c      	beq.n	e88 <cbvprintf+0x4c0>
			} else if (length_mod == LENGTH_H) {
     e4e:	2902      	cmp	r1, #2
     e50:	d000      	beq.n	e54 <cbvprintf+0x48c>
     e52:	e74b      	b.n	cec <cbvprintf+0x324>
				value->sint = (short)value->sint;
     e54:	9b08      	ldr	r3, [sp, #32]
     e56:	b21b      	sxth	r3, r3
     e58:	17da      	asrs	r2, r3, #31
     e5a:	9308      	str	r3, [sp, #32]
     e5c:	9209      	str	r2, [sp, #36]	; 0x24
     e5e:	e745      	b.n	cec <cbvprintf+0x324>
					value->sint = va_arg(ap, long);
     e60:	9b05      	ldr	r3, [sp, #20]
     e62:	1d1a      	adds	r2, r3, #4
     e64:	9205      	str	r2, [sp, #20]
     e66:	681b      	ldr	r3, [r3, #0]
     e68:	17da      	asrs	r2, r3, #31
     e6a:	9308      	str	r3, [sp, #32]
     e6c:	9209      	str	r2, [sp, #36]	; 0x24
				break;
     e6e:	e7ec      	b.n	e4a <cbvprintf+0x482>
					(sint_value_type)va_arg(ap, intmax_t);
     e70:	9b05      	ldr	r3, [sp, #20]
     e72:	3307      	adds	r3, #7
     e74:	2207      	movs	r2, #7
     e76:	4393      	bics	r3, r2
     e78:	001a      	movs	r2, r3
     e7a:	3208      	adds	r2, #8
     e7c:	9205      	str	r2, [sp, #20]
     e7e:	681a      	ldr	r2, [r3, #0]
     e80:	685b      	ldr	r3, [r3, #4]
     e82:	9208      	str	r2, [sp, #32]
     e84:	9309      	str	r3, [sp, #36]	; 0x24
				break;
     e86:	e7e0      	b.n	e4a <cbvprintf+0x482>
				value->sint = (char)value->sint;
     e88:	23ff      	movs	r3, #255	; 0xff
     e8a:	9a08      	ldr	r2, [sp, #32]
     e8c:	4013      	ands	r3, r2
     e8e:	9308      	str	r3, [sp, #32]
     e90:	2300      	movs	r3, #0
     e92:	9309      	str	r3, [sp, #36]	; 0x24
     e94:	e72a      	b.n	cec <cbvprintf+0x324>
			switch (length_mod) {
     e96:	2b05      	cmp	r3, #5
     e98:	d044      	beq.n	f24 <cbvprintf+0x55c>
     e9a:	d80f      	bhi.n	ebc <cbvprintf+0x4f4>
     e9c:	2b03      	cmp	r3, #3
     e9e:	d02d      	beq.n	efc <cbvprintf+0x534>
     ea0:	2b04      	cmp	r3, #4
     ea2:	d118      	bne.n	ed6 <cbvprintf+0x50e>
					(uint_value_type)va_arg(ap,
     ea4:	9b05      	ldr	r3, [sp, #20]
     ea6:	3307      	adds	r3, #7
     ea8:	2207      	movs	r2, #7
     eaa:	4393      	bics	r3, r2
     eac:	001a      	movs	r2, r3
     eae:	3208      	adds	r2, #8
     eb0:	9205      	str	r2, [sp, #20]
     eb2:	681a      	ldr	r2, [r3, #0]
     eb4:	685b      	ldr	r3, [r3, #4]
     eb6:	9208      	str	r2, [sp, #32]
     eb8:	9309      	str	r3, [sp, #36]	; 0x24
				break;
     eba:	e013      	b.n	ee4 <cbvprintf+0x51c>
			switch (length_mod) {
     ebc:	330a      	adds	r3, #10
     ebe:	220f      	movs	r2, #15
     ec0:	4013      	ands	r3, r2
     ec2:	2b01      	cmp	r3, #1
     ec4:	d807      	bhi.n	ed6 <cbvprintf+0x50e>
					(uint_value_type)va_arg(ap, size_t);
     ec6:	9b05      	ldr	r3, [sp, #20]
     ec8:	1d1a      	adds	r2, r3, #4
     eca:	9205      	str	r2, [sp, #20]
     ecc:	681b      	ldr	r3, [r3, #0]
     ece:	9308      	str	r3, [sp, #32]
				value->uint =
     ed0:	2300      	movs	r3, #0
     ed2:	9309      	str	r3, [sp, #36]	; 0x24
				break;
     ed4:	e006      	b.n	ee4 <cbvprintf+0x51c>
				value->uint = va_arg(ap, unsigned int);
     ed6:	9b05      	ldr	r3, [sp, #20]
     ed8:	1d1a      	adds	r2, r3, #4
     eda:	9205      	str	r2, [sp, #20]
     edc:	681b      	ldr	r3, [r3, #0]
     ede:	9308      	str	r3, [sp, #32]
     ee0:	2300      	movs	r3, #0
     ee2:	9309      	str	r3, [sp, #36]	; 0x24
			if (length_mod == LENGTH_HH) {
     ee4:	2901      	cmp	r1, #1
     ee6:	d029      	beq.n	f3c <cbvprintf+0x574>
			} else if (length_mod == LENGTH_H) {
     ee8:	2902      	cmp	r1, #2
     eea:	d000      	beq.n	eee <cbvprintf+0x526>
     eec:	e6fe      	b.n	cec <cbvprintf+0x324>
				value->uint = (unsigned short)value->uint;
     eee:	9b08      	ldr	r3, [sp, #32]
     ef0:	041b      	lsls	r3, r3, #16
     ef2:	0c1b      	lsrs	r3, r3, #16
     ef4:	9308      	str	r3, [sp, #32]
     ef6:	2300      	movs	r3, #0
     ef8:	9309      	str	r3, [sp, #36]	; 0x24
     efa:	e6f7      	b.n	cec <cbvprintf+0x324>
				    && (conv->specifier == 'c')) {
     efc:	ab08      	add	r3, sp, #32
     efe:	7adb      	ldrb	r3, [r3, #11]
				if ((!WCHAR_IS_SIGNED)
     f00:	2b63      	cmp	r3, #99	; 0x63
     f02:	d007      	beq.n	f14 <cbvprintf+0x54c>
					value->uint = va_arg(ap, unsigned long);
     f04:	9b05      	ldr	r3, [sp, #20]
     f06:	1d1a      	adds	r2, r3, #4
     f08:	9205      	str	r2, [sp, #20]
     f0a:	681b      	ldr	r3, [r3, #0]
     f0c:	9308      	str	r3, [sp, #32]
     f0e:	2300      	movs	r3, #0
     f10:	9309      	str	r3, [sp, #36]	; 0x24
     f12:	e7e7      	b.n	ee4 <cbvprintf+0x51c>
					value->uint = (wchar_t)va_arg(ap,
     f14:	9b05      	ldr	r3, [sp, #20]
     f16:	1d1a      	adds	r2, r3, #4
     f18:	9205      	str	r2, [sp, #20]
     f1a:	681b      	ldr	r3, [r3, #0]
     f1c:	9308      	str	r3, [sp, #32]
     f1e:	2300      	movs	r3, #0
     f20:	9309      	str	r3, [sp, #36]	; 0x24
     f22:	e7df      	b.n	ee4 <cbvprintf+0x51c>
					(uint_value_type)va_arg(ap,
     f24:	9b05      	ldr	r3, [sp, #20]
     f26:	3307      	adds	r3, #7
     f28:	2207      	movs	r2, #7
     f2a:	4393      	bics	r3, r2
     f2c:	001a      	movs	r2, r3
     f2e:	3208      	adds	r2, #8
     f30:	9205      	str	r2, [sp, #20]
     f32:	681a      	ldr	r2, [r3, #0]
     f34:	685b      	ldr	r3, [r3, #4]
     f36:	9208      	str	r2, [sp, #32]
     f38:	9309      	str	r3, [sp, #36]	; 0x24
				break;
     f3a:	e7d3      	b.n	ee4 <cbvprintf+0x51c>
				value->uint = (unsigned char)value->uint;
     f3c:	23ff      	movs	r3, #255	; 0xff
     f3e:	9a08      	ldr	r2, [sp, #32]
     f40:	4013      	ands	r3, r2
     f42:	9308      	str	r3, [sp, #32]
     f44:	2300      	movs	r3, #0
     f46:	9309      	str	r3, [sp, #36]	; 0x24
     f48:	e6d0      	b.n	cec <cbvprintf+0x324>
			if (length_mod == LENGTH_UPPER_L) {
     f4a:	2b08      	cmp	r3, #8
     f4c:	d00b      	beq.n	f66 <cbvprintf+0x59e>
				value->dbl = va_arg(ap, double);
     f4e:	9b05      	ldr	r3, [sp, #20]
     f50:	3307      	adds	r3, #7
     f52:	2207      	movs	r2, #7
     f54:	4393      	bics	r3, r2
     f56:	001a      	movs	r2, r3
     f58:	3208      	adds	r2, #8
     f5a:	9205      	str	r2, [sp, #20]
     f5c:	681a      	ldr	r2, [r3, #0]
     f5e:	685b      	ldr	r3, [r3, #4]
     f60:	9208      	str	r2, [sp, #32]
     f62:	9309      	str	r3, [sp, #36]	; 0x24
     f64:	e6c2      	b.n	cec <cbvprintf+0x324>
				value->ldbl = va_arg(ap, long double);
     f66:	9b05      	ldr	r3, [sp, #20]
     f68:	3307      	adds	r3, #7
     f6a:	3203      	adds	r2, #3
     f6c:	4393      	bics	r3, r2
     f6e:	001a      	movs	r2, r3
     f70:	3208      	adds	r2, #8
     f72:	9205      	str	r2, [sp, #20]
     f74:	681a      	ldr	r2, [r3, #0]
     f76:	685b      	ldr	r3, [r3, #4]
     f78:	9208      	str	r2, [sp, #32]
     f7a:	9309      	str	r3, [sp, #36]	; 0x24
     f7c:	e6b6      	b.n	cec <cbvprintf+0x324>
			value->ptr = va_arg(ap, void *);
     f7e:	9b05      	ldr	r3, [sp, #20]
     f80:	1d1a      	adds	r2, r3, #4
     f82:	9205      	str	r2, [sp, #20]
     f84:	681b      	ldr	r3, [r3, #0]
     f86:	9308      	str	r3, [sp, #32]
     f88:	e6b0      	b.n	cec <cbvprintf+0x324>
			OUTS(sp, fp);
     f8a:	9e03      	ldr	r6, [sp, #12]
     f8c:	0033      	movs	r3, r6
     f8e:	003a      	movs	r2, r7
     f90:	4649      	mov	r1, r9
     f92:	0028      	movs	r0, r5
     f94:	f003 fa5d 	bl	4452 <outs>
     f98:	2800      	cmp	r0, #0
     f9a:	da00      	bge.n	f9e <cbvprintf+0x5d6>
     f9c:	e14c      	b.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
     f9e:	1824      	adds	r4, r4, r0
		fp = extract_conversion(conv, sp);
     fa0:	0037      	movs	r7, r6
			continue;
     fa2:	e51d      	b.n	9e0 <cbvprintf+0x18>
		case '%':
			OUTC('%');
     fa4:	4649      	mov	r1, r9
     fa6:	2025      	movs	r0, #37	; 0x25
     fa8:	47a8      	blx	r5
     faa:	2800      	cmp	r0, #0
     fac:	da00      	bge.n	fb0 <cbvprintf+0x5e8>
     fae:	e143      	b.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
     fb0:	3401      	adds	r4, #1
		char sign = 0;
     fb2:	465e      	mov	r6, fp
		const char *bpe = buf + sizeof(buf);
     fb4:	2346      	movs	r3, #70	; 0x46
     fb6:	aa02      	add	r2, sp, #8
     fb8:	4694      	mov	ip, r2
     fba:	4463      	add	r3, ip
     fbc:	469a      	mov	sl, r3
		const char *bps = NULL;
     fbe:	2700      	movs	r7, #0
			break;
     fc0:	e09f      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
		case 's': {
			bps = (const char *)value->ptr;
     fc2:	9f08      	ldr	r7, [sp, #32]

			size_t len;

			if (precision >= 0) {
     fc4:	4653      	mov	r3, sl
     fc6:	2b00      	cmp	r3, #0
     fc8:	db07      	blt.n	fda <cbvprintf+0x612>
				len = strnlen(bps, precision);
     fca:	4651      	mov	r1, sl
     fcc:	0038      	movs	r0, r7
     fce:	f003 fab1 	bl	4534 <strnlen>
			} else {
				len = strlen(bps);
			}

			bpe = bps + len;
     fd2:	4682      	mov	sl, r0
     fd4:	44ba      	add	sl, r7
		char sign = 0;
     fd6:	465e      	mov	r6, fp
			precision = -1;

			break;
     fd8:	e093      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
				len = strlen(bps);
     fda:	0038      	movs	r0, r7
     fdc:	f003 faa1 	bl	4522 <strlen>
     fe0:	e7f7      	b.n	fd2 <cbvprintf+0x60a>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
     fe2:	af0e      	add	r7, sp, #56	; 0x38
     fe4:	9b08      	ldr	r3, [sp, #32]
     fe6:	703b      	strb	r3, [r7, #0]
		char sign = 0;
     fe8:	465e      	mov	r6, fp
			bpe = buf + 1;
     fea:	2331      	movs	r3, #49	; 0x31
     fec:	aa02      	add	r2, sp, #8
     fee:	4694      	mov	ip, r2
     ff0:	4463      	add	r3, ip
     ff2:	469a      	mov	sl, r3
			break;
     ff4:	e085      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
     ff6:	0713      	lsls	r3, r2, #28
     ff8:	d406      	bmi.n	1008 <CONFIG_FPROTECT_BLOCK_SIZE+0x8>
				sign = '+';
			} else if (conv->flag_space) {
     ffa:	2310      	movs	r3, #16
     ffc:	001e      	movs	r6, r3
     ffe:	4016      	ands	r6, r2
    1000:	4213      	tst	r3, r2
    1002:	d002      	beq.n	100a <CONFIG_FPROTECT_BLOCK_SIZE+0xa>
				sign = ' ';
    1004:	2620      	movs	r6, #32
    1006:	e000      	b.n	100a <CONFIG_FPROTECT_BLOCK_SIZE+0xa>
				sign = '+';
    1008:	262b      	movs	r6, #43	; 0x2b

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    100a:	9a08      	ldr	r2, [sp, #32]
    100c:	9b09      	ldr	r3, [sp, #36]	; 0x24
			if (sint < 0) {
    100e:	2b00      	cmp	r3, #0
    1010:	db02      	blt.n	1018 <CONFIG_FPROTECT_BLOCK_SIZE+0x18>
				sign = '-';
				value->uint = (uint_value_type)-sint;
			} else {
				value->uint = (uint_value_type)sint;
    1012:	9208      	str	r2, [sp, #32]
    1014:	9309      	str	r3, [sp, #36]	; 0x24
    1016:	e007      	b.n	1028 <CONFIG_FPROTECT_BLOCK_SIZE+0x28>
				value->uint = (uint_value_type)-sint;
    1018:	2700      	movs	r7, #0
    101a:	4256      	negs	r6, r2
    101c:	419f      	sbcs	r7, r3
    101e:	9608      	str	r6, [sp, #32]
    1020:	9709      	str	r7, [sp, #36]	; 0x24
				sign = '-';
    1022:	262d      	movs	r6, #45	; 0x2d
    1024:	e000      	b.n	1028 <CONFIG_FPROTECT_BLOCK_SIZE+0x28>
		switch (conv->specifier) {
    1026:	465e      	mov	r6, fp
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    1028:	2346      	movs	r3, #70	; 0x46
    102a:	aa02      	add	r2, sp, #8
    102c:	4694      	mov	ip, r2
    102e:	4463      	add	r3, ip
    1030:	9300      	str	r3, [sp, #0]
    1032:	ab0e      	add	r3, sp, #56	; 0x38
    1034:	aa0a      	add	r2, sp, #40	; 0x28
    1036:	9808      	ldr	r0, [sp, #32]
    1038:	9909      	ldr	r1, [sp, #36]	; 0x24
    103a:	f003 f998 	bl	436e <encode_uint>
    103e:	0007      	movs	r7, r0
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    1040:	4653      	mov	r3, sl
    1042:	2b00      	cmp	r3, #0
    1044:	da00      	bge.n	1048 <CONFIG_FPROTECT_BLOCK_SIZE+0x48>
    1046:	e08a      	b.n	115e <CONFIG_FPROTECT_BLOCK_SIZE+0x15e>
				size_t len = bpe - bps;
    1048:	2346      	movs	r3, #70	; 0x46
    104a:	aa02      	add	r2, sp, #8
    104c:	4694      	mov	ip, r2
    104e:	4463      	add	r3, ip
    1050:	1bdb      	subs	r3, r3, r7

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
    1052:	a908      	add	r1, sp, #32
    1054:	7a0a      	ldrb	r2, [r1, #8]
    1056:	2040      	movs	r0, #64	; 0x40
    1058:	4382      	bics	r2, r0
    105a:	720a      	strb	r2, [r1, #8]

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    105c:	459a      	cmp	sl, r3
    105e:	d800      	bhi.n	1062 <CONFIG_FPROTECT_BLOCK_SIZE+0x62>
    1060:	e083      	b.n	116a <CONFIG_FPROTECT_BLOCK_SIZE+0x16a>
					conv->pad0_value = precision - (int)len;
    1062:	4652      	mov	r2, sl
    1064:	1ad3      	subs	r3, r2, r3
    1066:	930b      	str	r3, [sp, #44]	; 0x2c
		const char *bpe = buf + sizeof(buf);
    1068:	2346      	movs	r3, #70	; 0x46
    106a:	4463      	add	r3, ip
    106c:	469a      	mov	sl, r3
    106e:	e048      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    1070:	9808      	ldr	r0, [sp, #32]
    1072:	2800      	cmp	r0, #0
    1074:	d104      	bne.n	1080 <CONFIG_FPROTECT_BLOCK_SIZE+0x80>
		char sign = 0;
    1076:	465e      	mov	r6, fp

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
    1078:	4b73      	ldr	r3, [pc, #460]	; (1248 <CONFIG_FPROTECT_BLOCK_SIZE+0x248>)
    107a:	469a      	mov	sl, r3
			bps = "(nil)";
    107c:	1f5f      	subs	r7, r3, #5
    107e:	e040      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    1080:	ae08      	add	r6, sp, #32
    1082:	2346      	movs	r3, #70	; 0x46
    1084:	aa02      	add	r2, sp, #8
    1086:	4694      	mov	ip, r2
    1088:	4463      	add	r3, ip
    108a:	9300      	str	r3, [sp, #0]
    108c:	ab0e      	add	r3, sp, #56	; 0x38
    108e:	aa0a      	add	r2, sp, #40	; 0x28
    1090:	2100      	movs	r1, #0
    1092:	f003 f96c 	bl	436e <encode_uint>
    1096:	0007      	movs	r7, r0
				conv->altform_0c = true;
    1098:	7ab3      	ldrb	r3, [r6, #10]
    109a:	2210      	movs	r2, #16
    109c:	4313      	orrs	r3, r2
    109e:	72b3      	strb	r3, [r6, #10]
				conv->specifier = 'x';
    10a0:	2378      	movs	r3, #120	; 0x78
    10a2:	72f3      	strb	r3, [r6, #11]
		char sign = 0;
    10a4:	465e      	mov	r6, fp
				goto prec_int_pad0;
    10a6:	e7cb      	b.n	1040 <CONFIG_FPROTECT_BLOCK_SIZE+0x40>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    10a8:	9808      	ldr	r0, [sp, #32]
	switch ((enum length_mod_enum)conv->length_mod) {
    10aa:	ab08      	add	r3, sp, #32
    10ac:	7a5b      	ldrb	r3, [r3, #9]
    10ae:	065b      	lsls	r3, r3, #25
    10b0:	0f19      	lsrs	r1, r3, #28
    10b2:	2b00      	cmp	r3, #0
    10b4:	db04      	blt.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
    10b6:	008b      	lsls	r3, r1, #2
    10b8:	4964      	ldr	r1, [pc, #400]	; (124c <CONFIG_FPROTECT_BLOCK_SIZE+0x24c>)
    10ba:	58cb      	ldr	r3, [r1, r3]
    10bc:	469f      	mov	pc, r3
		*(int *)dp = count;
    10be:	6004      	str	r4, [r0, #0]
		char sign = 0;
    10c0:	465e      	mov	r6, fp
		const char *bpe = buf + sizeof(buf);
    10c2:	2346      	movs	r3, #70	; 0x46
    10c4:	aa02      	add	r2, sp, #8
    10c6:	4694      	mov	ip, r2
    10c8:	4463      	add	r3, ip
    10ca:	469a      	mov	sl, r3
		const char *bps = NULL;
    10cc:	2700      	movs	r7, #0
}
    10ce:	e018      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
		*(signed char *)dp = (signed char)count;
    10d0:	7004      	strb	r4, [r0, #0]
		break;
    10d2:	e7f5      	b.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
		*(short *)dp = (short)count;
    10d4:	8004      	strh	r4, [r0, #0]
		break;
    10d6:	e7f3      	b.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
		*(long *)dp = (long)count;
    10d8:	6004      	str	r4, [r0, #0]
		break;
    10da:	e7f1      	b.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
		*(long long *)dp = (long long)count;
    10dc:	17e3      	asrs	r3, r4, #31
    10de:	6004      	str	r4, [r0, #0]
    10e0:	6043      	str	r3, [r0, #4]
		break;
    10e2:	e7ed      	b.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
		*(intmax_t *)dp = (intmax_t)count;
    10e4:	17e3      	asrs	r3, r4, #31
    10e6:	6004      	str	r4, [r0, #0]
    10e8:	6043      	str	r3, [r0, #4]
		break;
    10ea:	e7e9      	b.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
		*(size_t *)dp = (size_t)count;
    10ec:	6004      	str	r4, [r0, #0]
		break;
    10ee:	e7e7      	b.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    10f0:	6004      	str	r4, [r0, #0]
		break;
    10f2:	e7e5      	b.n	10c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>
		switch (conv->specifier) {
    10f4:	465e      	mov	r6, fp
    10f6:	2346      	movs	r3, #70	; 0x46
    10f8:	aa02      	add	r2, sp, #8
    10fa:	4694      	mov	ip, r2
    10fc:	4463      	add	r3, ip
    10fe:	469a      	mov	sl, r3
    1100:	2700      	movs	r7, #0
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    1102:	2f00      	cmp	r7, #0
    1104:	d100      	bne.n	1108 <CONFIG_FPROTECT_BLOCK_SIZE+0x108>
    1106:	e093      	b.n	1230 <CONFIG_FPROTECT_BLOCK_SIZE+0x230>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    1108:	4653      	mov	r3, sl
    110a:	1bdb      	subs	r3, r3, r7
		int pad_len = 0;

		if (sign != 0) {
    110c:	2e00      	cmp	r6, #0
    110e:	d000      	beq.n	1112 <CONFIG_FPROTECT_BLOCK_SIZE+0x112>
			nj_len += 1U;
    1110:	3301      	adds	r3, #1
		}

		if (conv->altform_0c) {
    1112:	aa08      	add	r2, sp, #32
    1114:	7a92      	ldrb	r2, [r2, #10]
    1116:	06d1      	lsls	r1, r2, #27
    1118:	d52d      	bpl.n	1176 <CONFIG_FPROTECT_BLOCK_SIZE+0x176>
			nj_len += 2U;
    111a:	3302      	adds	r3, #2
		} else if (conv->altform_0) {
			nj_len += 1U;
		}

		nj_len += conv->pad0_value;
    111c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    111e:	468c      	mov	ip, r1
    1120:	4463      	add	r3, ip
		if (conv->pad_fp) {
    1122:	0652      	lsls	r2, r2, #25
    1124:	d502      	bpl.n	112c <CONFIG_FPROTECT_BLOCK_SIZE+0x12c>
			nj_len += conv->pad0_pre_exp;
    1126:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    1128:	4694      	mov	ip, r2
    112a:	4463      	add	r3, ip
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    112c:	4642      	mov	r2, r8
    112e:	2a00      	cmp	r2, #0
    1130:	dd37      	ble.n	11a2 <CONFIG_FPROTECT_BLOCK_SIZE+0x1a2>
			width -= (int)nj_len;
    1132:	1ad3      	subs	r3, r2, r3
    1134:	4698      	mov	r8, r3

			if (!conv->flag_dash) {
    1136:	ab08      	add	r3, sp, #32
    1138:	7a1b      	ldrb	r3, [r3, #8]
    113a:	075b      	lsls	r3, r3, #29
    113c:	d431      	bmi.n	11a2 <CONFIG_FPROTECT_BLOCK_SIZE+0x1a2>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    113e:	ab08      	add	r3, sp, #32
    1140:	7a1b      	ldrb	r3, [r3, #8]
    1142:	065b      	lsls	r3, r3, #25
    1144:	d51b      	bpl.n	117e <CONFIG_FPROTECT_BLOCK_SIZE+0x17e>
					if (sign != 0) {
    1146:	2e00      	cmp	r6, #0
    1148:	d01c      	beq.n	1184 <CONFIG_FPROTECT_BLOCK_SIZE+0x184>
						OUTC(sign);
    114a:	4649      	mov	r1, r9
    114c:	0030      	movs	r0, r6
    114e:	47a8      	blx	r5
    1150:	2800      	cmp	r0, #0
    1152:	db71      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    1154:	3401      	adds	r4, #1
						sign = 0;
    1156:	465e      	mov	r6, fp
					}
					pad = '0';
    1158:	2330      	movs	r3, #48	; 0x30
    115a:	469b      	mov	fp, r3
    115c:	e014      	b.n	1188 <CONFIG_FPROTECT_BLOCK_SIZE+0x188>
		const char *bpe = buf + sizeof(buf);
    115e:	2346      	movs	r3, #70	; 0x46
    1160:	aa02      	add	r2, sp, #8
    1162:	4694      	mov	ip, r2
    1164:	4463      	add	r3, ip
    1166:	469a      	mov	sl, r3
    1168:	e7cb      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
    116a:	2346      	movs	r3, #70	; 0x46
    116c:	aa02      	add	r2, sp, #8
    116e:	4694      	mov	ip, r2
    1170:	4463      	add	r3, ip
    1172:	469a      	mov	sl, r3
    1174:	e7c5      	b.n	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
		} else if (conv->altform_0) {
    1176:	0711      	lsls	r1, r2, #28
    1178:	d5d0      	bpl.n	111c <CONFIG_FPROTECT_BLOCK_SIZE+0x11c>
			nj_len += 1U;
    117a:	3301      	adds	r3, #1
    117c:	e7ce      	b.n	111c <CONFIG_FPROTECT_BLOCK_SIZE+0x11c>
				char pad = ' ';
    117e:	2320      	movs	r3, #32
    1180:	469b      	mov	fp, r3
    1182:	e001      	b.n	1188 <CONFIG_FPROTECT_BLOCK_SIZE+0x188>
					pad = '0';
    1184:	2330      	movs	r3, #48	; 0x30
    1186:	469b      	mov	fp, r3
    1188:	4643      	mov	r3, r8
				}

				while (width-- > 0) {
    118a:	1e5a      	subs	r2, r3, #1
    118c:	4690      	mov	r8, r2
    118e:	2b00      	cmp	r3, #0
    1190:	dd07      	ble.n	11a2 <CONFIG_FPROTECT_BLOCK_SIZE+0x1a2>
					OUTC(pad);
    1192:	4649      	mov	r1, r9
    1194:	4658      	mov	r0, fp
    1196:	47a8      	blx	r5
    1198:	2800      	cmp	r0, #0
    119a:	db4d      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    119c:	3401      	adds	r4, #1
				while (width-- > 0) {
    119e:	4643      	mov	r3, r8
    11a0:	e7f3      	b.n	118a <CONFIG_FPROTECT_BLOCK_SIZE+0x18a>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    11a2:	2e00      	cmp	r6, #0
    11a4:	d005      	beq.n	11b2 <CONFIG_FPROTECT_BLOCK_SIZE+0x1b2>
			OUTC(sign);
    11a6:	4649      	mov	r1, r9
    11a8:	0030      	movs	r0, r6
    11aa:	47a8      	blx	r5
    11ac:	2800      	cmp	r0, #0
    11ae:	db43      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    11b0:	3401      	adds	r4, #1
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    11b2:	ab08      	add	r3, sp, #32
    11b4:	7a9b      	ldrb	r3, [r3, #10]
    11b6:	06da      	lsls	r2, r3, #27
    11b8:	0fd2      	lsrs	r2, r2, #31
    11ba:	071b      	lsls	r3, r3, #28
    11bc:	0fdb      	lsrs	r3, r3, #31
    11be:	4313      	orrs	r3, r2
    11c0:	d005      	beq.n	11ce <CONFIG_FPROTECT_BLOCK_SIZE+0x1ce>
				OUTC('0');
    11c2:	4649      	mov	r1, r9
    11c4:	2030      	movs	r0, #48	; 0x30
    11c6:	47a8      	blx	r5
    11c8:	2800      	cmp	r0, #0
    11ca:	db35      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    11cc:	3401      	adds	r4, #1
			}

			if (conv->altform_0c) {
    11ce:	ab08      	add	r3, sp, #32
    11d0:	7a9b      	ldrb	r3, [r3, #10]
    11d2:	06db      	lsls	r3, r3, #27
    11d4:	d506      	bpl.n	11e4 <CONFIG_FPROTECT_BLOCK_SIZE+0x1e4>
				OUTC(conv->specifier);
    11d6:	ab08      	add	r3, sp, #32
    11d8:	7ad8      	ldrb	r0, [r3, #11]
    11da:	4649      	mov	r1, r9
    11dc:	47a8      	blx	r5
    11de:	2800      	cmp	r0, #0
    11e0:	db2a      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    11e2:	3401      	adds	r4, #1
			}

			pad_len = conv->pad0_value;
    11e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			while (pad_len-- > 0) {
    11e6:	1e5e      	subs	r6, r3, #1
    11e8:	2b00      	cmp	r3, #0
    11ea:	dd07      	ble.n	11fc <CONFIG_FPROTECT_BLOCK_SIZE+0x1fc>
				OUTC('0');
    11ec:	4649      	mov	r1, r9
    11ee:	2030      	movs	r0, #48	; 0x30
    11f0:	47a8      	blx	r5
    11f2:	2800      	cmp	r0, #0
    11f4:	db20      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    11f6:	3401      	adds	r4, #1
			while (pad_len-- > 0) {
    11f8:	0033      	movs	r3, r6
    11fa:	e7f4      	b.n	11e6 <CONFIG_FPROTECT_BLOCK_SIZE+0x1e6>
			}

			OUTS(bps, bpe);
    11fc:	4653      	mov	r3, sl
    11fe:	003a      	movs	r2, r7
    1200:	4649      	mov	r1, r9
    1202:	0028      	movs	r0, r5
    1204:	f003 f925 	bl	4452 <outs>
    1208:	2800      	cmp	r0, #0
    120a:	db15      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    120c:	1824      	adds	r4, r4, r0
		}

		/* Finish left justification */
		while (width > 0) {
    120e:	4643      	mov	r3, r8
    1210:	2b00      	cmp	r3, #0
    1212:	dd0a      	ble.n	122a <CONFIG_FPROTECT_BLOCK_SIZE+0x22a>
			OUTC(' ');
    1214:	4649      	mov	r1, r9
    1216:	2020      	movs	r0, #32
    1218:	47a8      	blx	r5
    121a:	2800      	cmp	r0, #0
    121c:	db0c      	blt.n	1238 <CONFIG_FPROTECT_BLOCK_SIZE+0x238>
    121e:	3401      	adds	r4, #1
			--width;
    1220:	2301      	movs	r3, #1
    1222:	425b      	negs	r3, r3
    1224:	469c      	mov	ip, r3
    1226:	44e0      	add	r8, ip
    1228:	e7f1      	b.n	120e <CONFIG_FPROTECT_BLOCK_SIZE+0x20e>
		fp = extract_conversion(conv, sp);
    122a:	9f03      	ldr	r7, [sp, #12]
    122c:	f7ff fbd8 	bl	9e0 <cbvprintf+0x18>
    1230:	9f03      	ldr	r7, [sp, #12]
    1232:	f7ff fbd5 	bl	9e0 <cbvprintf+0x18>
		}
	}

	return count;
    1236:	0020      	movs	r0, r4
#undef OUTS
#undef OUTC
}
    1238:	b015      	add	sp, #84	; 0x54
    123a:	bc3c      	pop	{r2, r3, r4, r5}
    123c:	4690      	mov	r8, r2
    123e:	4699      	mov	r9, r3
    1240:	46a2      	mov	sl, r4
    1242:	46ab      	mov	fp, r5
    1244:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1246:	46c0      	nop			; (mov r8, r8)
    1248:	00005331 	.word	0x00005331
    124c:	00005664 	.word	0x00005664

00001250 <pm_system_resume>:
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}

void pm_system_resume(void)
{
    1250:	b530      	push	{r4, r5, lr}
    1252:	b085      	sub	sp, #20
	 * and it may schedule another thread.
	 *
	 * Call pm_idle_exit_notification_disable() if this
	 * notification is not required.
	 */
	if (!post_ops_done) {
    1254:	4b19      	ldr	r3, [pc, #100]	; (12bc <pm_system_resume+0x6c>)
    1256:	681b      	ldr	r3, [r3, #0]
    1258:	2b00      	cmp	r3, #0
    125a:	d12c      	bne.n	12b6 <pm_system_resume+0x66>
		post_ops_done = 1;
    125c:	4b17      	ldr	r3, [pc, #92]	; (12bc <pm_system_resume+0x6c>)
    125e:	2201      	movs	r2, #1
    1260:	601a      	str	r2, [r3, #0]
		exit_pos_ops(z_power_state);
    1262:	aa01      	add	r2, sp, #4
    1264:	4b16      	ldr	r3, [pc, #88]	; (12c0 <pm_system_resume+0x70>)
    1266:	cb13      	ldmia	r3!, {r0, r1, r4}
    1268:	c213      	stmia	r2!, {r0, r1, r4}
	if (pm_power_state_exit_post_ops != NULL) {
    126a:	4b16      	ldr	r3, [pc, #88]	; (12c4 <pm_system_resume+0x74>)
    126c:	2b00      	cmp	r3, #0
    126e:	d00a      	beq.n	1286 <pm_system_resume+0x36>
		pm_power_state_exit_post_ops(info);
    1270:	9801      	ldr	r0, [sp, #4]
    1272:	9902      	ldr	r1, [sp, #8]
    1274:	9a03      	ldr	r2, [sp, #12]
    1276:	f003 f9cf 	bl	4618 <pm_power_state_exit_post_ops>
	__asm__ volatile("mrs %0, PRIMASK;"
    127a:	f3ef 8510 	mrs	r5, PRIMASK
    127e:	b672      	cpsid	i
	return list->head;
    1280:	4b11      	ldr	r3, [pc, #68]	; (12c8 <pm_system_resume+0x78>)
    1282:	681c      	ldr	r4, [r3, #0]
    1284:	e009      	b.n	129a <pm_system_resume+0x4a>
	__asm__ volatile(
    1286:	b662      	cpsie	i
    1288:	f3bf 8f6f 	isb	sy
    128c:	e7f5      	b.n	127a <pm_system_resume+0x2a>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    128e:	1e23      	subs	r3, r4, #0
Z_GENLIST_PEEK_NEXT(slist, snode)
    1290:	d002      	beq.n	1298 <pm_system_resume+0x48>
	return node->next;
    1292:	6823      	ldr	r3, [r4, #0]
    1294:	2b00      	cmp	r3, #0
    1296:	d009      	beq.n	12ac <pm_system_resume+0x5c>
{
    1298:	001c      	movs	r4, r3
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    129a:	2c00      	cmp	r4, #0
    129c:	d006      	beq.n	12ac <pm_system_resume+0x5c>
			callback = notifier->state_exit;
    129e:	68a3      	ldr	r3, [r4, #8]
		if (callback) {
    12a0:	2b00      	cmp	r3, #0
    12a2:	d0f4      	beq.n	128e <pm_system_resume+0x3e>
			callback(z_power_state.state);
    12a4:	4a06      	ldr	r2, [pc, #24]	; (12c0 <pm_system_resume+0x70>)
    12a6:	7810      	ldrb	r0, [r2, #0]
    12a8:	4798      	blx	r3
    12aa:	e7f0      	b.n	128e <pm_system_resume+0x3e>
	if (key != 0U) {
    12ac:	2d00      	cmp	r5, #0
    12ae:	d102      	bne.n	12b6 <pm_system_resume+0x66>
	__asm__ volatile(
    12b0:	b662      	cpsie	i
    12b2:	f3bf 8f6f 	isb	sy
		pm_state_notify(false);
	}
}
    12b6:	b005      	add	sp, #20
    12b8:	bd30      	pop	{r4, r5, pc}
    12ba:	46c0      	nop			; (mov r8, r8)
    12bc:	20000004 	.word	0x20000004
    12c0:	200001d0 	.word	0x200001d0
    12c4:	00004619 	.word	0x00004619
    12c8:	200001c8 	.word	0x200001c8

000012cc <pm_system_suspend>:
	return PM_STATE_ACTIVE;
}
#endif

enum pm_state pm_system_suspend(int32_t ticks)
{
    12cc:	b570      	push	{r4, r5, r6, lr}
    12ce:	b088      	sub	sp, #32
    12d0:	0006      	movs	r6, r0
	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);
	z_power_state = pm_policy_next_state(ticks);
    12d2:	4d29      	ldr	r5, [pc, #164]	; (1378 <pm_system_suspend+0xac>)
    12d4:	466c      	mov	r4, sp
    12d6:	0001      	movs	r1, r0
    12d8:	0020      	movs	r0, r4
    12da:	f003 f8d7 	bl	448c <pm_policy_next_state>
    12de:	002b      	movs	r3, r5
    12e0:	cc07      	ldmia	r4!, {r0, r1, r2}
    12e2:	c307      	stmia	r3!, {r0, r1, r2}
	if (z_power_state.state == PM_STATE_ACTIVE) {
    12e4:	7828      	ldrb	r0, [r5, #0]
    12e6:	2800      	cmp	r0, #0
    12e8:	d043      	beq.n	1372 <pm_system_suspend+0xa6>
		LOG_DBG("No PM operations done.");
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks, z_power_state.state);
		return z_power_state.state;
	}
	post_ops_done = 0;
    12ea:	4b24      	ldr	r3, [pc, #144]	; (137c <pm_system_suspend+0xb0>)
    12ec:	2200      	movs	r2, #0
    12ee:	601a      	str	r2, [r3, #0]

	if (ticks != K_TICKS_FOREVER) {
    12f0:	1c73      	adds	r3, r6, #1
    12f2:	d107      	bne.n	1304 <pm_system_suspend+0x38>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    12f4:	f002 f900 	bl	34f8 <k_sched_lock>
	__asm__ volatile("mrs %0, PRIMASK;"
    12f8:	f3ef 8510 	mrs	r5, PRIMASK
    12fc:	b672      	cpsid	i
	return list->head;
    12fe:	4b20      	ldr	r3, [pc, #128]	; (1380 <pm_system_suspend+0xb4>)
    1300:	681c      	ldr	r4, [r3, #0]
    1302:	e016      	b.n	1332 <pm_system_suspend+0x66>
		     k_us_to_ticks_ceil32(z_power_state.exit_latency_us), true);
    1304:	4b1c      	ldr	r3, [pc, #112]	; (1378 <pm_system_suspend+0xac>)
    1306:	689b      	ldr	r3, [r3, #8]
			return (uint32_t)((t * to_hz + off) / from_hz);
    1308:	0c59      	lsrs	r1, r3, #17
    130a:	03d8      	lsls	r0, r3, #15
    130c:	4a1d      	ldr	r2, [pc, #116]	; (1384 <pm_system_suspend+0xb8>)
    130e:	2300      	movs	r3, #0
    1310:	1880      	adds	r0, r0, r2
    1312:	4159      	adcs	r1, r3
    1314:	4a1c      	ldr	r2, [pc, #112]	; (1388 <pm_system_suspend+0xbc>)
    1316:	2300      	movs	r3, #0
    1318:	f7fe fee6 	bl	e8 <__aeabi_uldivmod>
		z_set_timeout_expiry(ticks -
    131c:	1a30      	subs	r0, r6, r0
    131e:	2101      	movs	r1, #1
    1320:	f003 fd04 	bl	4d2c <z_set_timeout_expiry>
    1324:	e7e6      	b.n	12f4 <pm_system_suspend+0x28>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    1326:	1e23      	subs	r3, r4, #0
Z_GENLIST_PEEK_NEXT(slist, snode)
    1328:	d002      	beq.n	1330 <pm_system_suspend+0x64>
	return node->next;
    132a:	6823      	ldr	r3, [r4, #0]
    132c:	2b00      	cmp	r3, #0
    132e:	d009      	beq.n	1344 <pm_system_suspend+0x78>
{
    1330:	001c      	movs	r4, r3
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    1332:	2c00      	cmp	r4, #0
    1334:	d006      	beq.n	1344 <pm_system_suspend+0x78>
			callback = notifier->state_entry;
    1336:	6863      	ldr	r3, [r4, #4]
		if (callback) {
    1338:	2b00      	cmp	r3, #0
    133a:	d0f4      	beq.n	1326 <pm_system_suspend+0x5a>
			callback(z_power_state.state);
    133c:	4a0e      	ldr	r2, [pc, #56]	; (1378 <pm_system_suspend+0xac>)
    133e:	7810      	ldrb	r0, [r2, #0]
    1340:	4798      	blx	r3
    1342:	e7f0      	b.n	1326 <pm_system_suspend+0x5a>
	if (key != 0U) {
    1344:	2d00      	cmp	r5, #0
    1346:	d102      	bne.n	134e <pm_system_suspend+0x82>
	__asm__ volatile(
    1348:	b662      	cpsie	i
    134a:	f3bf 8f6f 	isb	sy
	pm_debug_start_timer();
	/* Enter power state */
	pm_state_notify(true);
	pm_state_set(z_power_state);
    134e:	aa05      	add	r2, sp, #20
    1350:	4b09      	ldr	r3, [pc, #36]	; (1378 <pm_system_suspend+0xac>)
    1352:	cb13      	ldmia	r3!, {r0, r1, r4}
    1354:	c213      	stmia	r2!, {r0, r1, r4}
	if (pm_power_state_set != NULL) {
    1356:	4b0d      	ldr	r3, [pc, #52]	; (138c <pm_system_suspend+0xc0>)
    1358:	2b00      	cmp	r3, #0
    135a:	d004      	beq.n	1366 <pm_system_suspend+0x9a>
		pm_power_state_set(info);
    135c:	9805      	ldr	r0, [sp, #20]
    135e:	9906      	ldr	r1, [sp, #24]
    1360:	9a07      	ldr	r2, [sp, #28]
    1362:	f003 f946 	bl	45f2 <pm_power_state_set>
		/* Turn on peripherals and restore device states as necessary */
		pm_resume_devices();
	}
#endif
	pm_log_debug_info(z_power_state.state);
	pm_system_resume();
    1366:	f7ff ff73 	bl	1250 <pm_system_resume>
	k_sched_unlock();
    136a:	f002 fa5b 	bl	3824 <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks, z_power_state.state);
	return z_power_state.state;
    136e:	4b02      	ldr	r3, [pc, #8]	; (1378 <pm_system_suspend+0xac>)
    1370:	7818      	ldrb	r0, [r3, #0]
}
    1372:	b008      	add	sp, #32
    1374:	bd70      	pop	{r4, r5, r6, pc}
    1376:	46c0      	nop			; (mov r8, r8)
    1378:	200001d0 	.word	0x200001d0
    137c:	20000004 	.word	0x20000004
    1380:	200001c8 	.word	0x200001c8
    1384:	000f423f 	.word	0x000f423f
    1388:	000f4240 	.word	0x000f4240
    138c:	000045f3 	.word	0x000045f3

00001390 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    1390:	4901      	ldr	r1, [pc, #4]	; (1398 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    1392:	2210      	movs	r2, #16
	str	r2, [r1]
    1394:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    1396:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    1398:	e000ed10 	.word	0xe000ed10

0000139c <arch_cpu_idle>:

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    139c:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    13a0:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    13a2:	b662      	cpsie	i
	isb
    13a4:	f3bf 8f6f 	isb	sy

	bx	lr
    13a8:	4770      	bx	lr
    13aa:	46c0      	nop			; (mov r8, r8)

000013ac <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    13ac:	b672      	cpsid	i
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	/* No BASEPRI, call wfe directly
	 * (SEVONPEND is set in z_arm_cpu_idle_init())
	 */
	wfe
    13ae:	bf20      	wfe

	cmp	r0, #0
    13b0:	2800      	cmp	r0, #0
	bne	_irq_disabled
    13b2:	d100      	bne.n	13b6 <_irq_disabled>
	cpsie	i
    13b4:	b662      	cpsie	i

000013b6 <_irq_disabled>:
	msr	BASEPRI, r0
	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    13b6:	4770      	bx	lr

000013b8 <arch_irq_enable>:
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    13b8:	0603      	lsls	r3, r0, #24
    13ba:	d405      	bmi.n	13c8 <arch_irq_enable+0x10>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    13bc:	231f      	movs	r3, #31
    13be:	4018      	ands	r0, r3
    13c0:	3b1e      	subs	r3, #30
    13c2:	4083      	lsls	r3, r0
    13c4:	4a01      	ldr	r2, [pc, #4]	; (13cc <arch_irq_enable+0x14>)
    13c6:	6013      	str	r3, [r2, #0]
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
}
    13c8:	4770      	bx	lr
    13ca:	46c0      	nop			; (mov r8, r8)
    13cc:	e000e100 	.word	0xe000e100

000013d0 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    13d0:	0943      	lsrs	r3, r0, #5
    13d2:	009b      	lsls	r3, r3, #2
    13d4:	4a03      	ldr	r2, [pc, #12]	; (13e4 <arch_irq_is_enabled+0x14>)
    13d6:	589a      	ldr	r2, [r3, r2]
    13d8:	231f      	movs	r3, #31
    13da:	4003      	ands	r3, r0
    13dc:	2001      	movs	r0, #1
    13de:	4098      	lsls	r0, r3
    13e0:	4010      	ands	r0, r2
}
    13e2:	4770      	bx	lr
    13e4:	e000e100 	.word	0xe000e100

000013e8 <z_arm_irq_priority_set>:
 * priority levels which are reserved.
 *
 * @return N/A
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    13e8:	b570      	push	{r4, r5, r6, lr}
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    13ea:	b242      	sxtb	r2, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    13ec:	0603      	lsls	r3, r0, #24
    13ee:	d411      	bmi.n	1414 <z_arm_irq_priority_set+0x2c>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    13f0:	0893      	lsrs	r3, r2, #2
    13f2:	4e14      	ldr	r6, [pc, #80]	; (1444 <z_arm_irq_priority_set+0x5c>)
    13f4:	33c0      	adds	r3, #192	; 0xc0
    13f6:	009b      	lsls	r3, r3, #2
    13f8:	599d      	ldr	r5, [r3, r6]
    13fa:	2403      	movs	r4, #3
    13fc:	4022      	ands	r2, r4
    13fe:	00d2      	lsls	r2, r2, #3
    1400:	20ff      	movs	r0, #255	; 0xff
    1402:	0004      	movs	r4, r0
    1404:	4094      	lsls	r4, r2
    1406:	43a5      	bics	r5, r4
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    1408:	0189      	lsls	r1, r1, #6
    140a:	4008      	ands	r0, r1
    140c:	4090      	lsls	r0, r2
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    140e:	4328      	orrs	r0, r5
    1410:	5198      	str	r0, [r3, r6]
}
    1412:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1414:	230f      	movs	r3, #15
    1416:	4013      	ands	r3, r2
    1418:	3b08      	subs	r3, #8
    141a:	089b      	lsrs	r3, r3, #2
    141c:	3306      	adds	r3, #6
    141e:	009b      	lsls	r3, r3, #2
    1420:	4809      	ldr	r0, [pc, #36]	; (1448 <z_arm_irq_priority_set+0x60>)
    1422:	4684      	mov	ip, r0
    1424:	4463      	add	r3, ip
    1426:	685c      	ldr	r4, [r3, #4]
    1428:	2003      	movs	r0, #3
    142a:	4002      	ands	r2, r0
    142c:	00d2      	lsls	r2, r2, #3
    142e:	30fc      	adds	r0, #252	; 0xfc
    1430:	0005      	movs	r5, r0
    1432:	4095      	lsls	r5, r2
    1434:	43ac      	bics	r4, r5
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    1436:	0189      	lsls	r1, r1, #6
    1438:	4008      	ands	r0, r1
    143a:	4090      	lsls	r0, r2
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    143c:	4320      	orrs	r0, r4
    143e:	6058      	str	r0, [r3, #4]
    1440:	e7e7      	b.n	1412 <z_arm_irq_priority_set+0x2a>
    1442:	46c0      	nop			; (mov r8, r8)
    1444:	e000e100 	.word	0xe000e100
    1448:	e000ed00 	.word	0xe000ed00

0000144c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    144c:	bf30      	wfi
    b z_SysNmiOnReset
    144e:	e7fd      	b.n	144c <z_SysNmiOnReset>

00001450 <arch_swap>:
 *
 * On ARMv6-M, the intlock key is represented by the PRIMASK register,
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
    1450:	b510      	push	{r4, lr}
	/* store off key and return value */
	_current->arch.basepri = key;
    1452:	490a      	ldr	r1, [pc, #40]	; (147c <arch_swap+0x2c>)
    1454:	688b      	ldr	r3, [r1, #8]
    1456:	229c      	movs	r2, #156	; 0x9c
    1458:	5098      	str	r0, [r3, r2]
	_current->arch.swap_return_value = _k_neg_eagain;
    145a:	3204      	adds	r2, #4
    145c:	4808      	ldr	r0, [pc, #32]	; (1480 <arch_swap+0x30>)
    145e:	6800      	ldr	r0, [r0, #0]
    1460:	5098      	str	r0, [r3, r2]

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1462:	4808      	ldr	r0, [pc, #32]	; (1484 <arch_swap+0x34>)
    1464:	6844      	ldr	r4, [r0, #4]
    1466:	2380      	movs	r3, #128	; 0x80
    1468:	055b      	lsls	r3, r3, #21
    146a:	4323      	orrs	r3, r4
    146c:	6043      	str	r3, [r0, #4]
    146e:	b662      	cpsie	i
    1470:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    1474:	688b      	ldr	r3, [r1, #8]
    1476:	5898      	ldr	r0, [r3, r2]
}
    1478:	bd10      	pop	{r4, pc}
    147a:	46c0      	nop			; (mov r8, r8)
    147c:	200002c4 	.word	0x200002c4
    1480:	000057a4 	.word	0x000057a4
    1484:	e000ed00 	.word	0xe000ed00

00001488 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    1488:	4914      	ldr	r1, [pc, #80]	; (14dc <_thread_irq_disabled+0x1e>)
    ldr r2, [r1, #_kernel_offset_to_current]
    148a:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    148c:	4814      	ldr	r0, [pc, #80]	; (14e0 <_thread_irq_disabled+0x22>)
    add r0, r2
    148e:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    1490:	f3ef 8c09 	mrs	ip, PSP
#endif

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    /* Store current r4-r7 */
    stmea r0!, {r4-r7}
    1494:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    /* copy r8-r12 into r3-r7 */
    mov r3, r8
    1496:	4643      	mov	r3, r8
    mov r4, r9
    1498:	464c      	mov	r4, r9
    mov r5, r10
    149a:	4655      	mov	r5, sl
    mov r6, r11
    149c:	465e      	mov	r6, fp
    mov r7, ip
    149e:	4667      	mov	r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
    14a0:	c0f8      	stmia	r0!, {r3, r4, r5, r6, r7}
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
    14a2:	b672      	cpsid	i
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    14a4:	4f0f      	ldr	r7, [pc, #60]	; (14e4 <_thread_irq_disabled+0x26>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    14a6:	4e10      	ldr	r6, [pc, #64]	; (14e8 <_thread_irq_disabled+0x2a>)
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    14a8:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
    14aa:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    14ac:	603e      	str	r6, [r7, #0]
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) && (_thread_offset_to_basepri > 124)
    /* Doing it this way since the offset to thread->arch.basepri can in
     * some configurations be larger than the maximum of 124 for ldr/str
     * immediate offsets.
     */
    ldr r4, =_thread_offset_to_basepri
    14ae:	4c0f      	ldr	r4, [pc, #60]	; (14ec <_thread_irq_disabled+0x2e>)
    adds r4, r2, r4
    14b0:	1914      	adds	r4, r2, r4

    ldr r0, [r4]
    14b2:	6820      	ldr	r0, [r4, #0]
    movs.n r3, #0
    14b4:	2300      	movs	r3, #0
    str r3, [r4]
    14b6:	6023      	str	r3, [r4, #0]
     * maps to PRIMASK.
     *
     * Only enable interrupts if value is 0, meaning interrupts
     * were enabled before irq_lock was called.
     */
    cmp r0, #0
    14b8:	2800      	cmp	r0, #0
    bne _thread_irq_disabled
    14ba:	d100      	bne.n	14be <_thread_irq_disabled>
    cpsie i
    14bc:	b662      	cpsie	i

000014be <_thread_irq_disabled>:
     */
    isb

#endif

    ldr r4, =_thread_offset_to_callee_saved
    14be:	4c08      	ldr	r4, [pc, #32]	; (14e0 <_thread_irq_disabled+0x22>)
    adds r0, r2, r4
    14c0:	1910      	adds	r0, r2, r4

    /* restore r4-r12 for new thread */
    /* first restore r8-r12 located after r4-r7 (4*4bytes) */
    adds r0, #16
    14c2:	3010      	adds	r0, #16
    ldmia r0!, {r3-r7}
    14c4:	c8f8      	ldmia	r0!, {r3, r4, r5, r6, r7}
    /* move to correct registers */
    mov r8, r3
    14c6:	4698      	mov	r8, r3
    mov r9, r4
    14c8:	46a1      	mov	r9, r4
    mov r10, r5
    14ca:	46aa      	mov	sl, r5
    mov r11, r6
    14cc:	46b3      	mov	fp, r6
    mov ip, r7
    14ce:	46bc      	mov	ip, r7
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    14d0:	3824      	subs	r0, #36	; 0x24
    ldmia r0!, {r4-r7}
    14d2:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    14d4:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    14d8:	4770      	bx	lr
    14da:	0000      	.short	0x0000
    ldr r1, =_kernel
    14dc:	200002c4 	.word	0x200002c4
    ldr r0, =_thread_offset_to_callee_saved
    14e0:	00000030 	.word	0x00000030
    ldr v4, =_SCS_ICSR
    14e4:	e000ed04 	.word	0xe000ed04
    ldr v3, =_SCS_ICSR_UNPENDSV
    14e8:	08000000 	.word	0x08000000
    ldr r4, =_thread_offset_to_basepri
    14ec:	0000009c 	.word	0x0000009c

000014f0 <z_arm_svc>:
SECTION_FUNC(TEXT, z_arm_svc)
  /* Use EXC_RETURN state to find out if stack frame is on the
   * MSP or PSP
   */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
  movs r0, #_EXC_RETURN_SPSEL_Msk
    14f0:	2004      	movs	r0, #4
  mov r1, lr
    14f2:	4671      	mov	r1, lr
  tst r1, r0
    14f4:	4201      	tst	r1, r0
  beq _stack_frame_msp
    14f6:	d002      	beq.n	14fe <_stack_frame_msp>
  mrs r0, PSP
    14f8:	f3ef 8009 	mrs	r0, PSP
  bne _stack_frame_endif
    14fc:	d101      	bne.n	1502 <_stack_frame_endif>

000014fe <_stack_frame_msp>:
_stack_frame_msp:
  mrs r0, MSP
    14fe:	f3ef 8008 	mrs	r0, MSP

00001502 <_stack_frame_endif>:
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    1502:	6981      	ldr	r1, [r0, #24]
    /* SVC is a two-byte instruction, point to it and read the
     * SVC number (lower byte of SCV instruction)
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    1504:	3902      	subs	r1, #2
    ldrb r1, [r1]
    1506:	7809      	ldrb	r1, [r1, #0]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    1508:	2902      	cmp	r1, #2
    beq _oops
    150a:	d0ff      	beq.n	150c <_oops>

0000150c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    150c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    150e:	f002 ffc9 	bl	44a4 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    1512:	bd01      	pop	{r0, pc}

00001514 <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    1514:	b510      	push	{r4, lr}
		thread->stack_info.size -= FP_GUARD_EXTRA_SIZE;
	}
#endif /* FP_GUARD_EXTRA_SIZE */
#endif /* CONFIG_MPU_STACK_GUARD */

	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    1516:	3a20      	subs	r2, #32
	iframe->pc = (uint32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
    1518:	4909      	ldr	r1, [pc, #36]	; (1540 <arch_new_thread+0x2c>)
    151a:	2401      	movs	r4, #1
    151c:	43a1      	bics	r1, r4
    151e:	6191      	str	r1, [r2, #24]
#endif
	iframe->a1 = (uint32_t)entry;
    1520:	6013      	str	r3, [r2, #0]
	iframe->a2 = (uint32_t)p1;
    1522:	9b02      	ldr	r3, [sp, #8]
    1524:	6053      	str	r3, [r2, #4]
	iframe->a3 = (uint32_t)p2;
    1526:	9b03      	ldr	r3, [sp, #12]
    1528:	6093      	str	r3, [r2, #8]
	iframe->a4 = (uint32_t)p3;
    152a:	9b04      	ldr	r3, [sp, #16]
    152c:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    152e:	2380      	movs	r3, #128	; 0x80
    1530:	045b      	lsls	r3, r3, #17
    1532:	61d3      	str	r3, [r2, #28]
#if defined(CONFIG_COMPILER_ISA_THUMB2)
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
    1534:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    1536:	239c      	movs	r3, #156	; 0x9c
    1538:	2200      	movs	r2, #0
    153a:	50c2      	str	r2, [r0, r3]
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    153c:	bd10      	pop	{r4, pc}
    153e:	46c0      	nop			; (mov r8, r8)
    1540:	00004109 	.word	0x00004109

00001544 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    1544:	4b06      	ldr	r3, [pc, #24]	; (1560 <arch_switch_to_main_thread+0x1c>)
    1546:	6098      	str	r0, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    1548:	1c10      	adds	r0, r2, #0
    154a:	f381 8809 	msr	PSP, r1
    154e:	2100      	movs	r1, #0
    1550:	b662      	cpsie	i
    1552:	f3bf 8f6f 	isb	sy
    1556:	2200      	movs	r2, #0
    1558:	2300      	movs	r3, #0
    155a:	f002 fdd5 	bl	4108 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    155e:	46c0      	nop			; (mov r8, r8)
    1560:	200002c4 	.word	0x200002c4

00001564 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    1564:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    1566:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    1568:	4a0a      	ldr	r2, [pc, #40]	; (1594 <_idle_state_cleared+0x1c>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    156a:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
    156c:	2800      	cmp	r0, #0

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	beq _idle_state_cleared
    156e:	d003      	beq.n	1578 <_idle_state_cleared>
	movs.n r1, #0
    1570:	2100      	movs	r1, #0
	/* clear kernel idle state */
	str r1, [r2, #_kernel_offset_to_idle]
    1572:	6191      	str	r1, [r2, #24]
	bl z_pm_save_idle_exit
    1574:	f003 fa8f 	bl	4a96 <z_pm_save_idle_exit>

00001578 <_idle_state_cleared>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    1578:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    157a:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
    157e:	4906      	ldr	r1, [pc, #24]	; (1598 <_idle_state_cleared+0x20>)
	subs r0, r1	/* get IRQ number */
    1580:	1a40      	subs	r0, r0, r1
	lsls r0, #3	/* table is 8-byte wide */
    1582:	00c0      	lsls	r0, r0, #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    1584:	4905      	ldr	r1, [pc, #20]	; (159c <_idle_state_cleared+0x24>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    1586:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    1588:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    158a:	4798      	blx	r3
#ifdef CONFIG_TRACING_ISR
	bl sys_trace_isr_exit
#endif

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
    158c:	bc09      	pop	{r0, r3}
	mov lr, r3
    158e:	469e      	mov	lr, r3
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    1590:	4903      	ldr	r1, [pc, #12]	; (15a0 <_idle_state_cleared+0x28>)
	bx r1
    1592:	4708      	bx	r1
	ldr r2, =_kernel
    1594:	200002c4 	.word	0x200002c4
	ldr r1, =16
    1598:	00000010 	.word	0x00000010
	ldr r1, =_sw_isr_table
    159c:	00004ec4 	.word	0x00004ec4
	ldr r1, =z_arm_int_exit
    15a0:	000015a5 	.word	0x000015a5

000015a4 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    15a4:	4b04      	ldr	r3, [pc, #16]	; (15b8 <_EXIT_EXC+0x4>)

	ldr r1, [r3, #_kernel_offset_to_current]
    15a6:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    15a8:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
    15aa:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    15ac:	d002      	beq.n	15b4 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    15ae:	4903      	ldr	r1, [pc, #12]	; (15bc <_EXIT_EXC+0x8>)
	ldr r2, =_SCS_ICSR_PENDSV
    15b0:	4a03      	ldr	r2, [pc, #12]	; (15c0 <_EXIT_EXC+0xc>)
	str r2, [r1]
    15b2:	600a      	str	r2, [r1, #0]

000015b4 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    15b4:	4770      	bx	lr
    15b6:	0000      	.short	0x0000
	ldr r3, =_kernel
    15b8:	200002c4 	.word	0x200002c4
	ldr r1, =_SCS_ICSR
    15bc:	e000ed04 	.word	0xe000ed04
	ldr r2, =_SCS_ICSR_PENDSV
    15c0:	10000000 	.word	0x10000000

000015c4 <hard_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t hard_fault(z_arch_esf_t *esf, bool *recoverable)
{
    15c4:	b570      	push	{r4, r5, r6, lr}
    15c6:	000c      	movs	r4, r1
	uint16_t fault_insn = *(ret_addr - 1);
    15c8:	6983      	ldr	r3, [r0, #24]
    15ca:	3b02      	subs	r3, #2
    15cc:	881a      	ldrh	r2, [r3, #0]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    15ce:	4b06      	ldr	r3, [pc, #24]	; (15e8 <hard_fault+0x24>)
    15d0:	429a      	cmp	r2, r3
    15d2:	d006      	beq.n	15e2 <hard_fault+0x1e>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    15d4:	2500      	movs	r5, #0

		PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
		reason = esf->basic.r0;
	}

	*recoverable = memory_fault_recoverable(esf, true);
    15d6:	2101      	movs	r1, #1
    15d8:	f002 ff82 	bl	44e0 <memory_fault_recoverable>
    15dc:	7020      	strb	r0, [r4, #0]
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	return reason;
}
    15de:	0028      	movs	r0, r5
    15e0:	bd70      	pop	{r4, r5, r6, pc}
		reason = esf->basic.r0;
    15e2:	6805      	ldr	r5, [r0, #0]
    15e4:	e7f7      	b.n	15d6 <hard_fault+0x12>
    15e6:	46c0      	nop			; (mov r8, r8)
    15e8:	0000df02 	.word	0x0000df02

000015ec <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    15ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    15ee:	b08d      	sub	sp, #52	; 0x34
    15f0:	000b      	movs	r3, r1
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    15f2:	4922      	ldr	r1, [pc, #136]	; (167c <z_arm_fault+0x90>)
    15f4:	6849      	ldr	r1, [r1, #4]
    15f6:	05c9      	lsls	r1, r1, #23
    15f8:	0dc9      	lsrs	r1, r1, #23
    15fa:	b662      	cpsie	i
    15fc:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    1600:	0e14      	lsrs	r4, r2, #24
    1602:	0624      	lsls	r4, r4, #24
    1604:	25ff      	movs	r5, #255	; 0xff
    1606:	062d      	lsls	r5, r5, #24
    1608:	42ac      	cmp	r4, r5
    160a:	d118      	bne.n	163e <z_arm_fault+0x52>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    160c:	240c      	movs	r4, #12
    160e:	4014      	ands	r4, r2
    1610:	2c08      	cmp	r4, #8
    1612:	d017      	beq.n	1644 <z_arm_fault+0x58>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    1614:	0712      	lsls	r2, r2, #28
    1616:	d50f      	bpl.n	1638 <z_arm_fault+0x4c>
			ptr_esf =  (z_arch_esf_t *)psp;
    1618:	001c      	movs	r4, r3
	*nested_exc = false;
    161a:	2700      	movs	r7, #0

#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
    161c:	2527      	movs	r5, #39	; 0x27
    161e:	ab02      	add	r3, sp, #8
    1620:	469c      	mov	ip, r3
    1622:	4465      	add	r5, ip
    1624:	002a      	movs	r2, r5
    1626:	0020      	movs	r0, r4
    1628:	f002 ff5c 	bl	44e4 <fault_handle>
    162c:	0006      	movs	r6, r0
	if (recoverable) {
    162e:	782b      	ldrb	r3, [r5, #0]
    1630:	2b00      	cmp	r3, #0
    1632:	d00a      	beq.n	164a <z_arm_fault+0x5e>
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
	}

	z_arm_fatal_error(reason, &esf_copy);
}
    1634:	b00d      	add	sp, #52	; 0x34
    1636:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ptr_esf = (z_arch_esf_t *)msp;
    1638:	0004      	movs	r4, r0
			*nested_exc = true;
    163a:	2701      	movs	r7, #1
    163c:	e7ee      	b.n	161c <z_arm_fault+0x30>
	*nested_exc = false;
    163e:	2700      	movs	r7, #0
		return NULL;
    1640:	2400      	movs	r4, #0
    1642:	e7eb      	b.n	161c <z_arm_fault+0x30>
	*nested_exc = false;
    1644:	2700      	movs	r7, #0
		return NULL;
    1646:	2400      	movs	r4, #0
    1648:	e7e8      	b.n	161c <z_arm_fault+0x30>
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    164a:	2220      	movs	r2, #32
    164c:	0021      	movs	r1, r4
    164e:	a803      	add	r0, sp, #12
    1650:	f002 ff86 	bl	4560 <memcpy>
	if (nested_exc) {
    1654:	2f00      	cmp	r7, #0
    1656:	d006      	beq.n	1666 <z_arm_fault+0x7a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    1658:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    165a:	05da      	lsls	r2, r3, #23
    165c:	d108      	bne.n	1670 <z_arm_fault+0x84>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    165e:	4a08      	ldr	r2, [pc, #32]	; (1680 <z_arm_fault+0x94>)
    1660:	4313      	orrs	r3, r2
    1662:	930a      	str	r3, [sp, #40]	; 0x28
    1664:	e004      	b.n	1670 <z_arm_fault+0x84>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    1666:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1668:	9301      	str	r3, [sp, #4]
    166a:	0a5b      	lsrs	r3, r3, #9
    166c:	025b      	lsls	r3, r3, #9
    166e:	930a      	str	r3, [sp, #40]	; 0x28
	z_arm_fatal_error(reason, &esf_copy);
    1670:	a903      	add	r1, sp, #12
    1672:	0030      	movs	r0, r6
    1674:	f002 ff12 	bl	449c <z_arm_fatal_error>
    1678:	e7dc      	b.n	1634 <z_arm_fault+0x48>
    167a:	46c0      	nop			; (mov r8, r8)
    167c:	e000ed00 	.word	0xe000ed00
    1680:	000001ff 	.word	0x000001ff

00001684 <z_arm_exc_spurious>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    1684:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    1688:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    168c:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    168e:	4672      	mov	r2, lr
	bl z_arm_fault
    1690:	f7ff ffac 	bl	15ec <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    1694:	bd01      	pop	{r0, pc}
    1696:	46c0      	nop			; (mov r8, r8)

00001698 <z_arm_interrupt_init>:
 *
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
    1698:	b530      	push	{r4, r5, lr}
	int irq = 0;
    169a:	2200      	movs	r2, #0

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    169c:	e011      	b.n	16c2 <z_arm_interrupt_init+0x2a>
    169e:	230f      	movs	r3, #15
    16a0:	400b      	ands	r3, r1
    16a2:	3b08      	subs	r3, #8
    16a4:	089b      	lsrs	r3, r3, #2
    16a6:	3306      	adds	r3, #6
    16a8:	009b      	lsls	r3, r3, #2
    16aa:	480f      	ldr	r0, [pc, #60]	; (16e8 <z_arm_interrupt_init+0x50>)
    16ac:	4684      	mov	ip, r0
    16ae:	4463      	add	r3, ip
    16b0:	6858      	ldr	r0, [r3, #4]
    16b2:	2403      	movs	r4, #3
    16b4:	4021      	ands	r1, r4
    16b6:	00c9      	lsls	r1, r1, #3
    16b8:	34fc      	adds	r4, #252	; 0xfc
    16ba:	408c      	lsls	r4, r1
    16bc:	43a0      	bics	r0, r4
    16be:	6058      	str	r0, [r3, #4]
    16c0:	3201      	adds	r2, #1
    16c2:	2a19      	cmp	r2, #25
    16c4:	dc0f      	bgt.n	16e6 <z_arm_interrupt_init+0x4e>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
    16c6:	b251      	sxtb	r1, r2
  if ((int32_t)(IRQn) >= 0)
    16c8:	0613      	lsls	r3, r2, #24
    16ca:	d4e8      	bmi.n	169e <z_arm_interrupt_init+0x6>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    16cc:	088b      	lsrs	r3, r1, #2
    16ce:	4d07      	ldr	r5, [pc, #28]	; (16ec <z_arm_interrupt_init+0x54>)
    16d0:	33c0      	adds	r3, #192	; 0xc0
    16d2:	009b      	lsls	r3, r3, #2
    16d4:	595c      	ldr	r4, [r3, r5]
    16d6:	2003      	movs	r0, #3
    16d8:	4001      	ands	r1, r0
    16da:	00c9      	lsls	r1, r1, #3
    16dc:	30fc      	adds	r0, #252	; 0xfc
    16de:	4088      	lsls	r0, r1
    16e0:	4384      	bics	r4, r0
    16e2:	515c      	str	r4, [r3, r5]
    16e4:	e7ec      	b.n	16c0 <z_arm_interrupt_init+0x28>
	}
}
    16e6:	bd30      	pop	{r4, r5, pc}
    16e8:	e000ed00 	.word	0xe000ed00
    16ec:	e000e100 	.word	0xe000e100

000016f0 <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
    16f0:	2000      	movs	r0, #0
    msr CONTROL, r0
    16f2:	f380 8814 	msr	CONTROL, r0
    isb
    16f6:	f3bf 8f6f 	isb	sy
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    16fa:	f003 fb8f 	bl	4e1c <z_arm_platform_init>
    movs.n r0, #0
    ldr r1, =_SCS_MPU_CTRL
    str r0, [r1]
    dsb
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    16fe:	480a      	ldr	r0, [pc, #40]	; (1728 <__start+0x38>)
    msr msp, r0
    1700:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
    1704:	f000 f816 	bl	1734 <z_arm_init_arch_hw_at_boot>
#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
    1708:	b672      	cpsid	i

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    170a:	4808      	ldr	r0, [pc, #32]	; (172c <__start+0x3c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    170c:	4908      	ldr	r1, [pc, #32]	; (1730 <__start+0x40>)
    adds r0, r0, r1
    170e:	1840      	adds	r0, r0, r1
    msr PSP, r0
    1710:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    1714:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    1718:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    171a:	4308      	orrs	r0, r1
    msr CONTROL, r0
    171c:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    1720:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    1724:	f002 fed1 	bl	44ca <z_arm_prep_c>
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    1728:	20000708 	.word	0x20000708
    ldr r0, =z_interrupt_stacks
    172c:	20000808 	.word	0x20000808
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    1730:	00000800 	.word	0x00000800

00001734 <z_arm_init_arch_hw_at_boot>:
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    1734:	b672      	cpsid	i
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    1736:	2300      	movs	r3, #0
    1738:	2b00      	cmp	r3, #0
    173a:	d001      	beq.n	1740 <z_arm_init_arch_hw_at_boot+0xc>
		NVIC->ICER[i] = 0xFFFFFFFF;
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    173c:	2300      	movs	r3, #0
    173e:	e012      	b.n	1766 <z_arm_init_arch_hw_at_boot+0x32>
		NVIC->ICER[i] = 0xFFFFFFFF;
    1740:	001a      	movs	r2, r3
    1742:	3220      	adds	r2, #32
    1744:	0092      	lsls	r2, r2, #2
    1746:	490c      	ldr	r1, [pc, #48]	; (1778 <z_arm_init_arch_hw_at_boot+0x44>)
    1748:	2001      	movs	r0, #1
    174a:	4240      	negs	r0, r0
    174c:	5050      	str	r0, [r2, r1]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    174e:	3301      	adds	r3, #1
    1750:	b2db      	uxtb	r3, r3
    1752:	e7f1      	b.n	1738 <z_arm_init_arch_hw_at_boot+0x4>
		NVIC->ICPR[i] = 0xFFFFFFFF;
    1754:	001a      	movs	r2, r3
    1756:	3260      	adds	r2, #96	; 0x60
    1758:	0092      	lsls	r2, r2, #2
    175a:	4907      	ldr	r1, [pc, #28]	; (1778 <z_arm_init_arch_hw_at_boot+0x44>)
    175c:	2001      	movs	r0, #1
    175e:	4240      	negs	r0, r0
    1760:	5050      	str	r0, [r2, r1]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    1762:	3301      	adds	r3, #1
    1764:	b2db      	uxtb	r3, r3
    1766:	2b00      	cmp	r3, #0
    1768:	d0f4      	beq.n	1754 <z_arm_init_arch_hw_at_boot+0x20>
  __ASM volatile ("cpsie i" : : : "memory");
    176a:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
    176c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1770:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
    1774:	4770      	bx	lr
    1776:	46c0      	nop			; (mov r8, r8)
    1778:	e000e100 	.word	0xe000e100

0000177c <z_impl_k_thread_abort>:
#include <kswap.h>
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    177c:	b510      	push	{r4, lr}
	if (_current == thread) {
    177e:	4b09      	ldr	r3, [pc, #36]	; (17a4 <z_impl_k_thread_abort+0x28>)
    1780:	689b      	ldr	r3, [r3, #8]
    1782:	4283      	cmp	r3, r0
    1784:	d002      	beq.n	178c <z_impl_k_thread_abort+0x10>
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
		}
	}

	z_thread_abort(thread);
    1786:	f002 f97f 	bl	3a88 <z_thread_abort>
}
    178a:	bd10      	pop	{r4, pc}
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    178c:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    1790:	2b00      	cmp	r3, #0
    1792:	d0f8      	beq.n	1786 <z_impl_k_thread_abort+0xa>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1794:	4a04      	ldr	r2, [pc, #16]	; (17a8 <z_impl_k_thread_abort+0x2c>)
    1796:	6851      	ldr	r1, [r2, #4]
    1798:	2380      	movs	r3, #128	; 0x80
    179a:	055b      	lsls	r3, r3, #21
    179c:	430b      	orrs	r3, r1
    179e:	6053      	str	r3, [r2, #4]
    17a0:	e7f1      	b.n	1786 <z_impl_k_thread_abort+0xa>
    17a2:	46c0      	nop			; (mov r8, r8)
    17a4:	200002c4 	.word	0x200002c4
    17a8:	e000ed00 	.word	0xe000ed00

000017ac <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    17ac:	4b01      	ldr	r3, [pc, #4]	; (17b4 <__stdout_hook_install+0x8>)
    17ae:	6018      	str	r0, [r3, #0]
}
    17b0:	4770      	bx	lr
    17b2:	46c0      	nop			; (mov r8, r8)
    17b4:	20000008 	.word	0x20000008

000017b8 <sys_arch_reboot>:
    }
    else
    {
        p_gpregret = &((volatile uint32_t *)&p_reg->GPREGRET)[0];
    }
    *p_gpregret = val;
    17b8:	23ff      	movs	r3, #255	; 0xff
    17ba:	4003      	ands	r3, r0
    17bc:	2180      	movs	r1, #128	; 0x80
    17be:	05c9      	lsls	r1, r1, #23
    17c0:	4a05      	ldr	r2, [pc, #20]	; (17d8 <sys_arch_reboot+0x20>)
    17c2:	508b      	str	r3, [r1, r2]
  __ASM volatile ("dsb 0xF":::"memory");
    17c4:	f3bf 8f4f 	dsb	sy
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
    17c8:	4b04      	ldr	r3, [pc, #16]	; (17dc <sys_arch_reboot+0x24>)
    17ca:	4a05      	ldr	r2, [pc, #20]	; (17e0 <sys_arch_reboot+0x28>)
    17cc:	60da      	str	r2, [r3, #12]
    17ce:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    17d2:	46c0      	nop			; (mov r8, r8)
  for(;;)                                                           /* wait until reset */
    17d4:	e7fd      	b.n	17d2 <sys_arch_reboot+0x1a>
    17d6:	46c0      	nop			; (mov r8, r8)
    17d8:	0000051c 	.word	0x0000051c
    17dc:	e000ed00 	.word	0xe000ed00
    17e0:	05fa0004 	.word	0x05fa0004

000017e4 <arch_busy_wait>:
}

#define DELAY_CALL_OVERHEAD_US 2

void arch_busy_wait(uint32_t time_us)
{
    17e4:	b510      	push	{r4, lr}
	if (time_us <= DELAY_CALL_OVERHEAD_US) {
    17e6:	2802      	cmp	r0, #2
    17e8:	d907      	bls.n	17fa <arch_busy_wait+0x16>
		return;
	}

	time_us -= DELAY_CALL_OVERHEAD_US;
    17ea:	1e83      	subs	r3, r0, #2

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    17ec:	2802      	cmp	r0, #2
    17ee:	d004      	beq.n	17fa <arch_busy_wait+0x16>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    17f0:	4a02      	ldr	r2, [pc, #8]	; (17fc <arch_busy_wait+0x18>)
    17f2:	2101      	movs	r1, #1
    17f4:	430a      	orrs	r2, r1
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    17f6:	0118      	lsls	r0, r3, #4
    delay_cycles(cycles);
    17f8:	4790      	blx	r2
	nrfx_coredep_delay_us(time_us);
}
    17fa:	bd10      	pop	{r4, pc}
    17fc:	00004ff0 	.word	0x00004ff0

00001800 <get_hf_flags>:

static uint32_t *get_hf_flags(void)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;

	return &data->subsys[CLOCK_CONTROL_NRF_TYPE_HFCLK].flags;
    1800:	4801      	ldr	r0, [pc, #4]	; (1808 <get_hf_flags+0x8>)
}
    1802:	3040      	adds	r0, #64	; 0x40
    1804:	4770      	bx	lr
    1806:	46c0      	nop			; (mov r8, r8)
    1808:	200001ec 	.word	0x200001ec

0000180c <get_subsys>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    180c:	4a07      	ldr	r2, [pc, #28]	; (182c <get_subsys+0x20>)
    180e:	1a82      	subs	r2, r0, r2
    1810:	1092      	asrs	r2, r2, #2
    1812:	00d3      	lsls	r3, r2, #3
    1814:	189b      	adds	r3, r3, r2
    1816:	0199      	lsls	r1, r3, #6
    1818:	185b      	adds	r3, r3, r1
    181a:	00db      	lsls	r3, r3, #3
    181c:	189b      	adds	r3, r3, r2
    181e:	03d8      	lsls	r0, r3, #15
    1820:	1818      	adds	r0, r3, r0
    1822:	00c0      	lsls	r0, r0, #3
    1824:	1880      	adds	r0, r0, r2
    1826:	4240      	negs	r0, r0

	return (clock_control_subsys_t)offset;
}
    1828:	4770      	bx	lr
    182a:	46c0      	nop			; (mov r8, r8)
    182c:	200001ec 	.word	0x200001ec

00001830 <onoff_stop>:

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    1830:	b570      	push	{r4, r5, r6, lr}
    1832:	0004      	movs	r4, r0
    1834:	000d      	movs	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    1836:	f7ff ffe9 	bl	180c <get_subsys>
    183a:	0001      	movs	r1, r0
    183c:	2240      	movs	r2, #64	; 0x40
    183e:	4803      	ldr	r0, [pc, #12]	; (184c <onoff_stop+0x1c>)
    1840:	f002 ff62 	bl	4708 <stop>
    1844:	0001      	movs	r1, r0
	notify(mgr, res);
    1846:	0020      	movs	r0, r4
    1848:	47a8      	blx	r5
}
    184a:	bd70      	pop	{r4, r5, r6, pc}
    184c:	00004e64 	.word	0x00004e64

00001850 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    1850:	b530      	push	{r4, r5, lr}
    1852:	b083      	sub	sp, #12
    1854:	0005      	movs	r5, r0
    1856:	000c      	movs	r4, r1
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    1858:	f7ff ffd8 	bl	180c <get_subsys>
    185c:	0001      	movs	r1, r0
    185e:	2340      	movs	r3, #64	; 0x40
    1860:	9300      	str	r3, [sp, #0]
    1862:	0023      	movs	r3, r4
    1864:	4a05      	ldr	r2, [pc, #20]	; (187c <onoff_start+0x2c>)
    1866:	4806      	ldr	r0, [pc, #24]	; (1880 <onoff_start+0x30>)
    1868:	f002 ff68 	bl	473c <async_start>
    186c:	1e01      	subs	r1, r0, #0
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    186e:	db01      	blt.n	1874 <onoff_start+0x24>
		notify(mgr, err);
	}
}
    1870:	b003      	add	sp, #12
    1872:	bd30      	pop	{r4, r5, pc}
		notify(mgr, err);
    1874:	0028      	movs	r0, r5
    1876:	47a0      	blx	r4
}
    1878:	e7fa      	b.n	1870 <onoff_start+0x20>
    187a:	46c0      	nop			; (mov r8, r8)
    187c:	00004785 	.word	0x00004785
    1880:	00004e64 	.word	0x00004e64

00001884 <clock_event_handler>:
		__ASSERT_NO_MSG(false);
	}
}

static void clock_event_handler(nrfx_clock_evt_type_t event)
{
    1884:	b510      	push	{r4, lr}
	const struct device *dev = CLOCK_DEVICE;

	switch (event) {
    1886:	2800      	cmp	r0, #0
    1888:	d002      	beq.n	1890 <clock_event_handler+0xc>
    188a:	2801      	cmp	r0, #1
    188c:	d00c      	beq.n	18a8 <clock_event_handler+0x24>
		break;
	default:
		__ASSERT_NO_MSG(0);
		break;
	}
}
    188e:	bd10      	pop	{r4, pc}
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    1890:	2100      	movs	r1, #0
    1892:	4808      	ldr	r0, [pc, #32]	; (18b4 <clock_event_handler+0x30>)
    1894:	f002 fec9 	bl	462a <get_sub_data>
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    1898:	6883      	ldr	r3, [r0, #8]
    189a:	075b      	lsls	r3, r3, #29
    189c:	d1f7      	bne.n	188e <clock_event_handler+0xa>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    189e:	2100      	movs	r1, #0
    18a0:	4804      	ldr	r0, [pc, #16]	; (18b4 <clock_event_handler+0x30>)
    18a2:	f002 ff1e 	bl	46e2 <clkstarted_handle>
    18a6:	e7f2      	b.n	188e <clock_event_handler+0xa>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    18a8:	2101      	movs	r1, #1
    18aa:	4802      	ldr	r0, [pc, #8]	; (18b4 <clock_event_handler+0x30>)
    18ac:	f002 ff19 	bl	46e2 <clkstarted_handle>
}
    18b0:	e7ed      	b.n	188e <clock_event_handler+0xa>
    18b2:	46c0      	nop			; (mov r8, r8)
    18b4:	00004e64 	.word	0x00004e64

000018b8 <generic_hfclk_start>:
{
    18b8:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    18ba:	f3ef 8410 	mrs	r4, PRIMASK
    18be:	b672      	cpsid	i
	hfclk_users |= HF_USER_GENERIC;
    18c0:	4a12      	ldr	r2, [pc, #72]	; (190c <generic_hfclk_start+0x54>)
    18c2:	2302      	movs	r3, #2
    18c4:	6811      	ldr	r1, [r2, #0]
    18c6:	430b      	orrs	r3, r1
    18c8:	6013      	str	r3, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    18ca:	07db      	lsls	r3, r3, #31
    18cc:	d40a      	bmi.n	18e4 <generic_hfclk_start+0x2c>
	bool already_started = false;
    18ce:	2300      	movs	r3, #0
	if (key != 0U) {
    18d0:	2c00      	cmp	r4, #0
    18d2:	d102      	bne.n	18da <generic_hfclk_start+0x22>
	__asm__ volatile(
    18d4:	b662      	cpsie	i
    18d6:	f3bf 8f6f 	isb	sy
	if (already_started) {
    18da:	2b00      	cmp	r3, #0
    18dc:	d111      	bne.n	1902 <generic_hfclk_start+0x4a>
	hfclk_start();
    18de:	f002 ff59 	bl	4794 <hfclk_start>
}
    18e2:	bd10      	pop	{r4, pc}
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    18e4:	2280      	movs	r2, #128	; 0x80
    18e6:	05d2      	lsls	r2, r2, #23
    18e8:	4b09      	ldr	r3, [pc, #36]	; (1910 <generic_hfclk_start+0x58>)
    18ea:	58d1      	ldr	r1, [r2, r3]
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    18ec:	58d3      	ldr	r3, [r2, r3]
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    18ee:	07cb      	lsls	r3, r1, #31
    18f0:	d401      	bmi.n	18f6 <generic_hfclk_start+0x3e>
	bool already_started = false;
    18f2:	2300      	movs	r3, #0
    18f4:	e7ec      	b.n	18d0 <generic_hfclk_start+0x18>
			set_on_state(get_hf_flags());
    18f6:	f7ff ff83 	bl	1800 <get_hf_flags>
    18fa:	f002 fee3 	bl	46c4 <set_on_state>
			already_started = true;
    18fe:	2301      	movs	r3, #1
    1900:	e7e6      	b.n	18d0 <generic_hfclk_start+0x18>
		clkstarted_handle(CLOCK_DEVICE,
    1902:	2100      	movs	r1, #0
    1904:	4803      	ldr	r0, [pc, #12]	; (1914 <generic_hfclk_start+0x5c>)
    1906:	f002 feec 	bl	46e2 <clkstarted_handle>
		return;
    190a:	e7ea      	b.n	18e2 <generic_hfclk_start+0x2a>
    190c:	2000023c 	.word	0x2000023c
    1910:	0000040c 	.word	0x0000040c
    1914:	00004e64 	.word	0x00004e64

00001918 <generic_hfclk_stop>:
{
    1918:	b510      	push	{r4, lr}
		/* coverity[OVERRUN] */
		return (atomic_val_t) arch_syscall_invoke2(*(uintptr_t *)&target, *(uintptr_t *)&value, K_SYSCALL_ATOMIC_AND);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_and(target, value);
    191a:	2103      	movs	r1, #3
    191c:	4249      	negs	r1, r1
    191e:	4804      	ldr	r0, [pc, #16]	; (1930 <generic_hfclk_stop+0x18>)
    1920:	f003 fa66 	bl	4df0 <z_impl_atomic_and>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    1924:	07c3      	lsls	r3, r0, #31
    1926:	d500      	bpl.n	192a <generic_hfclk_stop+0x12>
}
    1928:	bd10      	pop	{r4, pc}
	hfclk_stop();
    192a:	f002 ff3d 	bl	47a8 <hfclk_stop>
    192e:	e7fb      	b.n	1928 <generic_hfclk_stop+0x10>
    1930:	2000023c 	.word	0x2000023c

00001934 <api_blocking_start>:
{
    1934:	b500      	push	{lr}
    1936:	b085      	sub	sp, #20
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    1938:	466b      	mov	r3, sp
    193a:	9300      	str	r3, [sp, #0]
    193c:	9301      	str	r3, [sp, #4]
    193e:	2300      	movs	r3, #0
    1940:	9302      	str	r3, [sp, #8]
    1942:	3301      	adds	r3, #1
    1944:	9303      	str	r3, [sp, #12]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    1946:	466b      	mov	r3, sp
    1948:	4a06      	ldr	r2, [pc, #24]	; (1964 <api_blocking_start+0x30>)
    194a:	f002 ff13 	bl	4774 <api_start>
	if (err < 0) {
    194e:	2800      	cmp	r0, #0
    1950:	db05      	blt.n	195e <api_blocking_start+0x2a>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    1952:	2280      	movs	r2, #128	; 0x80
    1954:	01d2      	lsls	r2, r2, #7
    1956:	2300      	movs	r3, #0
    1958:	4668      	mov	r0, sp
    195a:	f001 fd2b 	bl	33b4 <z_impl_k_sem_take>
}
    195e:	b005      	add	sp, #20
    1960:	bd00      	pop	{pc}
    1962:	46c0      	nop			; (mov r8, r8)
    1964:	000047bd 	.word	0x000047bd

00001968 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
    1968:	b570      	push	{r4, r5, r6, lr}
    196a:	0006      	movs	r6, r0
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    196c:	2200      	movs	r2, #0
    196e:	2101      	movs	r1, #1
    1970:	2000      	movs	r0, #0
    1972:	f7ff fd39 	bl	13e8 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    1976:	2000      	movs	r0, #0
    1978:	f7ff fd1e 	bl	13b8 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    197c:	4811      	ldr	r0, [pc, #68]	; (19c4 <clk_init+0x5c>)
    197e:	f001 f95d 	bl	2c3c <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    1982:	4b11      	ldr	r3, [pc, #68]	; (19c8 <clk_init+0x60>)
    1984:	4298      	cmp	r0, r3
    1986:	d11a      	bne.n	19be <clk_init+0x56>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    1988:	f003 f836 	bl	49f8 <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
    198c:	2400      	movs	r4, #0
    198e:	e003      	b.n	1998 <clk_init+0x30>
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    1990:	2301      	movs	r3, #1
    1992:	60ab      	str	r3, [r5, #8]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    1994:	3401      	adds	r4, #1
    1996:	b2e4      	uxtb	r4, r4
	for (enum clock_control_nrf_type i = 0;
    1998:	2c01      	cmp	r4, #1
    199a:	d80e      	bhi.n	19ba <clk_init+0x52>
						get_sub_data(dev, i);
    199c:	0021      	movs	r1, r4
    199e:	0030      	movs	r0, r6
    19a0:	f002 fe43 	bl	462a <get_sub_data>
    19a4:	0005      	movs	r5, r0
		err = onoff_manager_init(get_onoff_manager(dev, i),
    19a6:	0021      	movs	r1, r4
    19a8:	0030      	movs	r0, r6
    19aa:	f002 fe4a 	bl	4642 <get_onoff_manager>
    19ae:	4907      	ldr	r1, [pc, #28]	; (19cc <clk_init+0x64>)
    19b0:	f002 fb8a 	bl	40c8 <onoff_manager_init>
		if (err < 0) {
    19b4:	2800      	cmp	r0, #0
    19b6:	daeb      	bge.n	1990 <clk_init+0x28>
    19b8:	e000      	b.n	19bc <clk_init+0x54>
	}

	return 0;
    19ba:	2000      	movs	r0, #0
}
    19bc:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    19be:	2005      	movs	r0, #5
    19c0:	4240      	negs	r0, r0
    19c2:	e7fb      	b.n	19bc <clk_init+0x54>
    19c4:	00001885 	.word	0x00001885
    19c8:	0bad0000 	.word	0x0bad0000
    19cc:	000056b0 	.word	0x000056b0

000019d0 <lfclk_spinwait>:
{
    19d0:	b570      	push	{r4, r5, r6, lr}
    19d2:	0005      	movs	r5, r0
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    19d4:	2801      	cmp	r0, #1
    19d6:	d107      	bne.n	19e8 <lfclk_spinwait+0x18>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    19d8:	2280      	movs	r2, #128	; 0x80
    19da:	05d2      	lsls	r2, r2, #23
    19dc:	4b34      	ldr	r3, [pc, #208]	; (1ab0 <lfclk_spinwait+0xe0>)
    19de:	58d2      	ldr	r2, [r2, r3]
    19e0:	2303      	movs	r3, #3
    19e2:	4013      	ands	r3, r2
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    19e4:	2b01      	cmp	r3, #1
    19e6:	d062      	beq.n	1aae <lfclk_spinwait+0xde>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    19e8:	f003 f841 	bl	4a6e <k_is_in_isr>
    19ec:	2800      	cmp	r0, #0
    19ee:	d105      	bne.n	19fc <lfclk_spinwait+0x2c>
	return !z_sys_post_kernel;
    19f0:	4b30      	ldr	r3, [pc, #192]	; (1ab4 <lfclk_spinwait+0xe4>)
    19f2:	781b      	ldrb	r3, [r3, #0]
    19f4:	2b00      	cmp	r3, #0
    19f6:	d041      	beq.n	1a7c <lfclk_spinwait+0xac>
    19f8:	2400      	movs	r4, #0
    19fa:	e000      	b.n	19fe <lfclk_spinwait+0x2e>
    19fc:	2401      	movs	r4, #1
	int key = isr_mode ? irq_lock() : 0;
    19fe:	2c00      	cmp	r4, #0
    1a00:	d03e      	beq.n	1a80 <lfclk_spinwait+0xb0>
	__asm__ volatile("mrs %0, PRIMASK;"
    1a02:	f3ef 8610 	mrs	r6, PRIMASK
    1a06:	b672      	cpsid	i
	if (!isr_mode) {
    1a08:	2c00      	cmp	r4, #0
    1a0a:	d105      	bne.n	1a18 <lfclk_spinwait+0x48>
    p_reg->INTENCLR = mask;
    1a0c:	2280      	movs	r2, #128	; 0x80
    1a0e:	05d2      	lsls	r2, r2, #23
    1a10:	23c2      	movs	r3, #194	; 0xc2
    1a12:	009b      	lsls	r3, r3, #2
    1a14:	2102      	movs	r1, #2
    1a16:	50d1      	str	r1, [r2, r3]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    1a18:	2180      	movs	r1, #128	; 0x80
    1a1a:	05c9      	lsls	r1, r1, #23
    1a1c:	2283      	movs	r2, #131	; 0x83
    1a1e:	00d2      	lsls	r2, r2, #3
    1a20:	588b      	ldr	r3, [r1, r2]
    1a22:	2003      	movs	r0, #3
    1a24:	4003      	ands	r3, r0
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    1a26:	588a      	ldr	r2, [r1, r2]
    1a28:	03d2      	lsls	r2, r2, #15
    1a2a:	d430      	bmi.n	1a8e <lfclk_spinwait+0xbe>
    return false;
    1a2c:	2200      	movs	r2, #0
	while (!(nrfx_clock_is_running(d, (void *)&type)
    1a2e:	2a00      	cmp	r2, #0
    1a30:	d003      	beq.n	1a3a <lfclk_spinwait+0x6a>
    1a32:	2b01      	cmp	r3, #1
    1a34:	d02d      	beq.n	1a92 <lfclk_spinwait+0xc2>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    1a36:	2d01      	cmp	r5, #1
    1a38:	d02b      	beq.n	1a92 <lfclk_spinwait+0xc2>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    1a3a:	2c00      	cmp	r4, #0
    1a3c:	d022      	beq.n	1a84 <lfclk_spinwait+0xb4>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    1a3e:	0030      	movs	r0, r6
    1a40:	f7ff fcb4 	bl	13ac <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    1a44:	2280      	movs	r2, #128	; 0x80
    1a46:	05d2      	lsls	r2, r2, #23
    1a48:	23a3      	movs	r3, #163	; 0xa3
    1a4a:	00db      	lsls	r3, r3, #3
    1a4c:	58d3      	ldr	r3, [r2, r3]
    1a4e:	b2db      	uxtb	r3, r3
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    1a50:	2b00      	cmp	r3, #0
    1a52:	d1e1      	bne.n	1a18 <lfclk_spinwait+0x48>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    1a54:	4b18      	ldr	r3, [pc, #96]	; (1ab8 <lfclk_spinwait+0xe8>)
    1a56:	681b      	ldr	r3, [r3, #0]
		    && nrf_clock_event_check(NRF_CLOCK,
    1a58:	2b00      	cmp	r3, #0
    1a5a:	d0dd      	beq.n	1a18 <lfclk_spinwait+0x48>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    1a5c:	4b16      	ldr	r3, [pc, #88]	; (1ab8 <lfclk_spinwait+0xe8>)
    1a5e:	2200      	movs	r2, #0
    1a60:	601a      	str	r2, [r3, #0]
    p_reg->LFCLKSRC = (uint32_t)(source);
    1a62:	2301      	movs	r3, #1
    1a64:	2180      	movs	r1, #128	; 0x80
    1a66:	05c9      	lsls	r1, r1, #23
    1a68:	22a3      	movs	r2, #163	; 0xa3
    1a6a:	00d2      	lsls	r2, r2, #3
    1a6c:	508b      	str	r3, [r1, r2]
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1a6e:	4913      	ldr	r1, [pc, #76]	; (1abc <lfclk_spinwait+0xec>)
    1a70:	22c0      	movs	r2, #192	; 0xc0
    1a72:	0052      	lsls	r2, r2, #1
    1a74:	508b      	str	r3, [r1, r2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    1a76:	4a12      	ldr	r2, [pc, #72]	; (1ac0 <lfclk_spinwait+0xf0>)
    1a78:	6013      	str	r3, [r2, #0]
}
    1a7a:	e7cd      	b.n	1a18 <lfclk_spinwait+0x48>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    1a7c:	2401      	movs	r4, #1
    1a7e:	e7be      	b.n	19fe <lfclk_spinwait+0x2e>
	int key = isr_mode ? irq_lock() : 0;
    1a80:	2600      	movs	r6, #0
    1a82:	e7c1      	b.n	1a08 <lfclk_spinwait+0x38>
	return z_impl_k_sleep(timeout);
    1a84:	2021      	movs	r0, #33	; 0x21
    1a86:	2100      	movs	r1, #0
    1a88:	f001 ffdc 	bl	3a44 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    1a8c:	e7da      	b.n	1a44 <lfclk_spinwait+0x74>
                return true;
    1a8e:	2201      	movs	r2, #1
    1a90:	e7cd      	b.n	1a2e <lfclk_spinwait+0x5e>
	if (isr_mode) {
    1a92:	2c00      	cmp	r4, #0
    1a94:	d005      	beq.n	1aa2 <lfclk_spinwait+0xd2>
	if (key != 0U) {
    1a96:	2e00      	cmp	r6, #0
    1a98:	d109      	bne.n	1aae <lfclk_spinwait+0xde>
	__asm__ volatile(
    1a9a:	b662      	cpsie	i
    1a9c:	f3bf 8f6f 	isb	sy
    1aa0:	e005      	b.n	1aae <lfclk_spinwait+0xde>
    p_reg->INTENSET = mask;
    1aa2:	2280      	movs	r2, #128	; 0x80
    1aa4:	05d2      	lsls	r2, r2, #23
    1aa6:	23c1      	movs	r3, #193	; 0xc1
    1aa8:	009b      	lsls	r3, r3, #2
    1aaa:	2102      	movs	r1, #2
    1aac:	50d1      	str	r1, [r2, r3]
}
    1aae:	bd70      	pop	{r4, r5, r6, pc}
    1ab0:	0000041c 	.word	0x0000041c
    1ab4:	20000303 	.word	0x20000303
    1ab8:	40000104 	.word	0x40000104
    1abc:	e000e100 	.word	0xe000e100
    1ac0:	40000008 	.word	0x40000008

00001ac4 <z_nrf_clock_control_lf_on>:
{
    1ac4:	b570      	push	{r4, r5, r6, lr}
    1ac6:	0004      	movs	r4, r0
	return z_impl_atomic_set(target, value);
    1ac8:	2101      	movs	r1, #1
    1aca:	480f      	ldr	r0, [pc, #60]	; (1b08 <z_nrf_clock_control_lf_on+0x44>)
    1acc:	f003 f977 	bl	4dbe <z_impl_atomic_set>
	if (atomic_set(&on, 1) == 0) {
    1ad0:	2800      	cmp	r0, #0
    1ad2:	d003      	beq.n	1adc <z_nrf_clock_control_lf_on+0x18>
	switch (start_mode) {
    1ad4:	1e63      	subs	r3, r4, #1
    1ad6:	2b01      	cmp	r3, #1
    1ad8:	d912      	bls.n	1b00 <z_nrf_clock_control_lf_on+0x3c>
}
    1ada:	bd70      	pop	{r4, r5, r6, pc}
				get_onoff_manager(CLOCK_DEVICE,
    1adc:	2101      	movs	r1, #1
    1ade:	480b      	ldr	r0, [pc, #44]	; (1b0c <z_nrf_clock_control_lf_on+0x48>)
    1ae0:	f002 fdaf 	bl	4642 <get_onoff_manager>
    1ae4:	0005      	movs	r5, r0
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    1ae6:	4e0a      	ldr	r6, [pc, #40]	; (1b10 <z_nrf_clock_control_lf_on+0x4c>)
    1ae8:	1d30      	adds	r0, r6, #4
    1aea:	220c      	movs	r2, #12
    1aec:	2100      	movs	r1, #0
    1aee:	f002 fd57 	bl	45a0 <memset>
    1af2:	2301      	movs	r3, #1
    1af4:	60b3      	str	r3, [r6, #8]
		err = onoff_request(mgr, &cli);
    1af6:	0031      	movs	r1, r6
    1af8:	0028      	movs	r0, r5
    1afa:	f7fe ff03 	bl	904 <onoff_request>
    1afe:	e7e9      	b.n	1ad4 <z_nrf_clock_control_lf_on+0x10>
		lfclk_spinwait(start_mode);
    1b00:	0020      	movs	r0, r4
    1b02:	f7ff ff65 	bl	19d0 <lfclk_spinwait>
		break;
    1b06:	e7e8      	b.n	1ada <z_nrf_clock_control_lf_on+0x16>
    1b08:	20000240 	.word	0x20000240
    1b0c:	00004e64 	.word	0x00004e64
    1b10:	200001dc 	.word	0x200001dc

00001b14 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    1b14:	b570      	push	{r4, r5, r6, lr}
    1b16:	0004      	movs	r4, r0
#ifdef CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS

	int handled_by_debug_server = HANDLE_DEBUG_HOOK_OUT(c);
    1b18:	b2c5      	uxtb	r5, r0
    1b1a:	4b0b      	ldr	r3, [pc, #44]	; (1b48 <console_out+0x34>)
    1b1c:	681b      	ldr	r3, [r3, #0]
    1b1e:	0028      	movs	r0, r5
    1b20:	4798      	blx	r3

	if (handled_by_debug_server) {
    1b22:	2801      	cmp	r0, #1
    1b24:	d007      	beq.n	1b36 <console_out+0x22>
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    1b26:	2c0a      	cmp	r4, #10
    1b28:	d007      	beq.n	1b3a <console_out+0x26>
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    1b2a:	4b08      	ldr	r3, [pc, #32]	; (1b4c <console_out+0x38>)
    1b2c:	6818      	ldr	r0, [r3, #0]
				      unsigned char out_char);

static inline void z_impl_uart_poll_out(const struct device *dev,
						unsigned char out_char)
{
	const struct uart_driver_api *api =
    1b2e:	6883      	ldr	r3, [r0, #8]
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    1b30:	685b      	ldr	r3, [r3, #4]
    1b32:	0029      	movs	r1, r5
    1b34:	4798      	blx	r3

	return c;
}
    1b36:	0020      	movs	r0, r4
    1b38:	bd70      	pop	{r4, r5, r6, pc}
		uart_poll_out(uart_console_dev, '\r');
    1b3a:	4b04      	ldr	r3, [pc, #16]	; (1b4c <console_out+0x38>)
    1b3c:	6818      	ldr	r0, [r3, #0]
	const struct uart_driver_api *api =
    1b3e:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
    1b40:	685b      	ldr	r3, [r3, #4]
    1b42:	210d      	movs	r1, #13
    1b44:	4798      	blx	r3
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
}
    1b46:	e7f0      	b.n	1b2a <console_out+0x16>
    1b48:	2000000c 	.word	0x2000000c
    1b4c:	20000244 	.word	0x20000244

00001b50 <uart_console_hook_install>:
 *
 * @return N/A
 */

static void uart_console_hook_install(void)
{
    1b50:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
    1b52:	4c04      	ldr	r4, [pc, #16]	; (1b64 <uart_console_hook_install+0x14>)
    1b54:	0020      	movs	r0, r4
    1b56:	f7ff fe29 	bl	17ac <__stdout_hook_install>
	__printk_hook_install(console_out);
    1b5a:	0020      	movs	r0, r4
    1b5c:	f7fe fdf2 	bl	744 <__printk_hook_install>
}
    1b60:	bd10      	pop	{r4, pc}
    1b62:	46c0      	nop			; (mov r8, r8)
    1b64:	00001b15 	.word	0x00001b15

00001b68 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    1b68:	b510      	push	{r4, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    1b6a:	4807      	ldr	r0, [pc, #28]	; (1b88 <uart_console_init+0x20>)
    1b6c:	4b07      	ldr	r3, [pc, #28]	; (1b8c <uart_console_init+0x24>)
    1b6e:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    1b70:	f002 ff54 	bl	4a1c <z_device_ready>
    1b74:	2800      	cmp	r0, #0
    1b76:	d003      	beq.n	1b80 <uart_console_init+0x18>
	if (!device_is_ready(uart_console_dev)) {
		return -ENODEV;
	}

	uart_console_hook_install();
    1b78:	f7ff ffea 	bl	1b50 <uart_console_hook_install>

	return 0;
    1b7c:	2000      	movs	r0, #0
}
    1b7e:	bd10      	pop	{r4, pc}
		return -ENODEV;
    1b80:	2013      	movs	r0, #19
    1b82:	4240      	negs	r0, r0
    1b84:	e7fb      	b.n	1b7e <uart_console_init+0x16>
    1b86:	46c0      	nop			; (mov r8, r8)
    1b88:	00004e7c 	.word	0x00004e7c
    1b8c:	20000244 	.word	0x20000244

00001b90 <gpio_nrfx_config>:
	return res;
}

static int gpio_nrfx_config(const struct device *port,
			    gpio_pin_t pin, gpio_flags_t flags)
{
    1b90:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b92:	46ce      	mov	lr, r9
    1b94:	4647      	mov	r7, r8
    1b96:	b580      	push	{r7, lr}
    1b98:	000e      	movs	r6, r1
	return port->config;
    1b9a:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    1b9c:	685b      	ldr	r3, [r3, #4]
    1b9e:	4698      	mov	r8, r3
	nrf_gpio_pin_pull_t pull;
	nrf_gpio_pin_drive_t drive;
	nrf_gpio_pin_dir_t dir;
	nrf_gpio_pin_input_t input;

	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    1ba0:	4b3b      	ldr	r3, [pc, #236]	; (1c90 <gpio_nrfx_config+0x100>)
    1ba2:	4013      	ands	r3, r2
    1ba4:	493b      	ldr	r1, [pc, #236]	; (1c94 <gpio_nrfx_config+0x104>)
    1ba6:	428b      	cmp	r3, r1
    1ba8:	d02a      	beq.n	1c00 <gpio_nrfx_config+0x70>
    1baa:	d814      	bhi.n	1bd6 <gpio_nrfx_config+0x46>
    1bac:	2b06      	cmp	r3, #6
    1bae:	d029      	beq.n	1c04 <gpio_nrfx_config+0x74>
    1bb0:	d905      	bls.n	1bbe <gpio_nrfx_config+0x2e>
    1bb2:	2180      	movs	r1, #128	; 0x80
    1bb4:	0349      	lsls	r1, r1, #13
    1bb6:	428b      	cmp	r3, r1
    1bb8:	d10a      	bne.n	1bd0 <gpio_nrfx_config+0x40>
	case GPIO_DS_DFLT_LOW | GPIO_OPEN_DRAIN:
		drive = NRF_GPIO_PIN_S0D1;
		break;

	case GPIO_DS_ALT_LOW | GPIO_DS_DFLT_HIGH:
		drive = NRF_GPIO_PIN_H0S1;
    1bba:	2501      	movs	r5, #1
    1bbc:	e019      	b.n	1bf2 <gpio_nrfx_config+0x62>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    1bbe:	2b00      	cmp	r3, #0
    1bc0:	d022      	beq.n	1c08 <gpio_nrfx_config+0x78>
    1bc2:	2b02      	cmp	r3, #2
    1bc4:	d101      	bne.n	1bca <gpio_nrfx_config+0x3a>
	case GPIO_DS_ALT_LOW | GPIO_OPEN_DRAIN:
		drive = NRF_GPIO_PIN_H0D1;
		break;

	case GPIO_DS_DFLT_HIGH | GPIO_OPEN_SOURCE:
		drive = NRF_GPIO_PIN_D0S1;
    1bc6:	2504      	movs	r5, #4
    1bc8:	e013      	b.n	1bf2 <gpio_nrfx_config+0x62>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    1bca:	2016      	movs	r0, #22
    1bcc:	4240      	negs	r0, r0
    1bce:	e04d      	b.n	1c6c <gpio_nrfx_config+0xdc>
    1bd0:	2016      	movs	r0, #22
    1bd2:	4240      	negs	r0, r0
    1bd4:	e04a      	b.n	1c6c <gpio_nrfx_config+0xdc>
    1bd6:	4930      	ldr	r1, [pc, #192]	; (1c98 <gpio_nrfx_config+0x108>)
    1bd8:	428b      	cmp	r3, r1
    1bda:	d017      	beq.n	1c0c <gpio_nrfx_config+0x7c>
    1bdc:	21a0      	movs	r1, #160	; 0xa0
    1bde:	03c9      	lsls	r1, r1, #15
    1be0:	428b      	cmp	r3, r1
    1be2:	d101      	bne.n	1be8 <gpio_nrfx_config+0x58>
		drive = NRF_GPIO_PIN_H0H1;
    1be4:	2503      	movs	r5, #3
    1be6:	e004      	b.n	1bf2 <gpio_nrfx_config+0x62>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    1be8:	2180      	movs	r1, #128	; 0x80
    1bea:	03c9      	lsls	r1, r1, #15
    1bec:	428b      	cmp	r3, r1
    1bee:	d14c      	bne.n	1c8a <gpio_nrfx_config+0xfa>
		drive = NRF_GPIO_PIN_S0H1;
    1bf0:	2502      	movs	r5, #2

	default:
		return -EINVAL;
	}

	if ((flags & GPIO_PULL_UP) != 0) {
    1bf2:	06d3      	lsls	r3, r2, #27
    1bf4:	d40c      	bmi.n	1c10 <gpio_nrfx_config+0x80>
		pull = NRF_GPIO_PIN_PULLUP;
	} else if ((flags & GPIO_PULL_DOWN) != 0) {
    1bf6:	0693      	lsls	r3, r2, #26
    1bf8:	d53c      	bpl.n	1c74 <gpio_nrfx_config+0xe4>
		pull = NRF_GPIO_PIN_PULLDOWN;
    1bfa:	2301      	movs	r3, #1
    1bfc:	4699      	mov	r9, r3
    1bfe:	e009      	b.n	1c14 <gpio_nrfx_config+0x84>
		drive = NRF_GPIO_PIN_H0D1;
    1c00:	2507      	movs	r5, #7
    1c02:	e7f6      	b.n	1bf2 <gpio_nrfx_config+0x62>
		drive = NRF_GPIO_PIN_S0D1;
    1c04:	2506      	movs	r5, #6
    1c06:	e7f4      	b.n	1bf2 <gpio_nrfx_config+0x62>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    1c08:	2500      	movs	r5, #0
    1c0a:	e7f2      	b.n	1bf2 <gpio_nrfx_config+0x62>
		drive = NRF_GPIO_PIN_D0H1;
    1c0c:	2505      	movs	r5, #5
    1c0e:	e7f0      	b.n	1bf2 <gpio_nrfx_config+0x62>
		pull = NRF_GPIO_PIN_PULLUP;
    1c10:	2303      	movs	r3, #3
    1c12:	4699      	mov	r9, r3
		pull = NRF_GPIO_PIN_NOPULL;
	}

	dir = ((flags & GPIO_OUTPUT) != 0)
	      ? NRF_GPIO_PIN_DIR_OUTPUT
	      : NRF_GPIO_PIN_DIR_INPUT;
    1c14:	0a54      	lsrs	r4, r2, #9
	dir = ((flags & GPIO_OUTPUT) != 0)
    1c16:	2101      	movs	r1, #1
    1c18:	468c      	mov	ip, r1
    1c1a:	0021      	movs	r1, r4
    1c1c:	4664      	mov	r4, ip
    1c1e:	4021      	ands	r1, r4

	input = ((flags & GPIO_INPUT) != 0)
    1c20:	34ff      	adds	r4, #255	; 0xff
    1c22:	4014      	ands	r4, r2
		? NRF_GPIO_PIN_INPUT_CONNECT
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    1c24:	0027      	movs	r7, r4
    1c26:	427c      	negs	r4, r7
    1c28:	417c      	adcs	r4, r7
    1c2a:	b2e4      	uxtb	r4, r4

	if ((flags & GPIO_OUTPUT) != 0) {
    1c2c:	0597      	lsls	r7, r2, #22
    1c2e:	d507      	bpl.n	1c40 <gpio_nrfx_config+0xb0>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    1c30:	0517      	lsls	r7, r2, #20
    1c32:	d522      	bpl.n	1c7a <gpio_nrfx_config+0xea>
			nrf_gpio_port_out_set(reg, BIT(pin));
    1c34:	2201      	movs	r2, #1
    1c36:	40b2      	lsls	r2, r6
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    1c38:	27a1      	movs	r7, #161	; 0xa1
    1c3a:	00ff      	lsls	r7, r7, #3
    1c3c:	4643      	mov	r3, r8
    1c3e:	51da      	str	r2, [r3, r7]
	return port->config;
    1c40:	6842      	ldr	r2, [r0, #4]
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
			nrf_gpio_port_out_clear(reg, BIT(pin));
		}
	}

	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
    1c42:	7a12      	ldrb	r2, [r2, #8]
    1c44:	0152      	lsls	r2, r2, #5
    1c46:	201f      	movs	r0, #31
    1c48:	4030      	ands	r0, r6
    1c4a:	4310      	orrs	r0, r2
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    1c4c:	221f      	movs	r2, #31
    1c4e:	4002      	ands	r2, r0
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos) |
    1c50:	0064      	lsls	r4, r4, #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    1c52:	4321      	orrs	r1, r4
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    1c54:	464b      	mov	r3, r9
    1c56:	009b      	lsls	r3, r3, #2
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos) |
    1c58:	4319      	orrs	r1, r3
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
    1c5a:	022b      	lsls	r3, r5, #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    1c5c:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
    1c5e:	32c1      	adds	r2, #193	; 0xc1
    1c60:	32ff      	adds	r2, #255	; 0xff
    1c62:	0092      	lsls	r2, r2, #2
    1c64:	21a0      	movs	r1, #160	; 0xa0
    1c66:	05c9      	lsls	r1, r1, #23
    1c68:	5053      	str	r3, [r2, r1]
		     dir, input, pull, drive, NRF_GPIO_PIN_NOSENSE);

	return 0;
    1c6a:	2000      	movs	r0, #0
}
    1c6c:	bc0c      	pop	{r2, r3}
    1c6e:	4690      	mov	r8, r2
    1c70:	4699      	mov	r9, r3
    1c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pull = NRF_GPIO_PIN_NOPULL;
    1c74:	2300      	movs	r3, #0
    1c76:	4699      	mov	r9, r3
    1c78:	e7cc      	b.n	1c14 <gpio_nrfx_config+0x84>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    1c7a:	0552      	lsls	r2, r2, #21
    1c7c:	d5e0      	bpl.n	1c40 <gpio_nrfx_config+0xb0>
			nrf_gpio_port_out_clear(reg, BIT(pin));
    1c7e:	2201      	movs	r2, #1
    1c80:	40b2      	lsls	r2, r6
    p_reg->OUTCLR = clr_mask;
    1c82:	4f06      	ldr	r7, [pc, #24]	; (1c9c <gpio_nrfx_config+0x10c>)
    1c84:	4643      	mov	r3, r8
    1c86:	51da      	str	r2, [r3, r7]
}
    1c88:	e7da      	b.n	1c40 <gpio_nrfx_config+0xb0>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    1c8a:	2016      	movs	r0, #22
    1c8c:	4240      	negs	r0, r0
    1c8e:	e7ed      	b.n	1c6c <gpio_nrfx_config+0xdc>
    1c90:	00f00006 	.word	0x00f00006
    1c94:	00100006 	.word	0x00100006
    1c98:	00400002 	.word	0x00400002
    1c9c:	0000050c 	.word	0x0000050c

00001ca0 <gpio_nrfx_port_set_masked_raw>:
}

static int gpio_nrfx_port_set_masked_raw(const struct device *port,
					 uint32_t mask,
					 uint32_t value)
{
    1ca0:	b510      	push	{r4, lr}
	return port->config;
    1ca2:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    1ca4:	6858      	ldr	r0, [r3, #4]
    return p_reg->OUT;
    1ca6:	4b04      	ldr	r3, [pc, #16]	; (1cb8 <gpio_nrfx_port_set_masked_raw+0x18>)
    1ca8:	58c4      	ldr	r4, [r0, r3]
	uint32_t value_tmp;

	value_tmp = nrf_gpio_port_out_read(reg) & ~mask;
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
    1caa:	4062      	eors	r2, r4
    1cac:	4011      	ands	r1, r2
    1cae:	4061      	eors	r1, r4
    p_reg->OUT = value;
    1cb0:	50c1      	str	r1, [r0, r3]

	return 0;
}
    1cb2:	2000      	movs	r0, #0
    1cb4:	bd10      	pop	{r4, pc}
    1cb6:	46c0      	nop			; (mov r8, r8)
    1cb8:	00000504 	.word	0x00000504

00001cbc <gpio_nrfx_port_clear_bits_raw>:
	return port->config;
    1cbc:	6843      	ldr	r3, [r0, #4]
}

static int gpio_nrfx_port_clear_bits_raw(const struct device *port,
					 uint32_t mask)
{
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    1cbe:	685a      	ldr	r2, [r3, #4]
    p_reg->OUTCLR = clr_mask;
    1cc0:	4b01      	ldr	r3, [pc, #4]	; (1cc8 <gpio_nrfx_port_clear_bits_raw+0xc>)
    1cc2:	50d1      	str	r1, [r2, r3]

	nrf_gpio_port_out_clear(reg, mask);

	return 0;
}
    1cc4:	2000      	movs	r0, #0
    1cc6:	4770      	bx	lr
    1cc8:	0000050c 	.word	0x0000050c

00001ccc <gpio_nrfx_port_toggle_bits>:
	return port->config;
    1ccc:	6843      	ldr	r3, [r0, #4]

static int gpio_nrfx_port_toggle_bits(const struct device *port,
				      uint32_t mask)
{
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    1cce:	6858      	ldr	r0, [r3, #4]
    return p_reg->OUT;
    1cd0:	4a02      	ldr	r2, [pc, #8]	; (1cdc <gpio_nrfx_port_toggle_bits+0x10>)
    1cd2:	5883      	ldr	r3, [r0, r2]
	uint32_t value;

	value = nrf_gpio_port_out_read(reg);
	nrf_gpio_port_out_write(reg, value ^ mask);
    1cd4:	404b      	eors	r3, r1
    p_reg->OUT = value;
    1cd6:	5083      	str	r3, [r0, r2]

	return 0;
}
    1cd8:	2000      	movs	r0, #0
    1cda:	4770      	bx	lr
    1cdc:	00000504 	.word	0x00000504

00001ce0 <cfg_level_pins>:
	 */
	return out;
}

static void cfg_level_pins(const struct device *port)
{
    1ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ce2:	46ce      	mov	lr, r9
    1ce4:	4647      	mov	r7, r8
    1ce6:	b580      	push	{r7, lr}
	return port->data;
    1ce8:	6906      	ldr	r6, [r0, #16]
	return port->config;
    1cea:	6843      	ldr	r3, [r0, #4]
    1cec:	4699      	mov	r9, r3
	out &= ~data->trig_edge & ~data->double_edge;
    1cee:	69b3      	ldr	r3, [r6, #24]
    1cf0:	6972      	ldr	r2, [r6, #20]
    1cf2:	4313      	orrs	r3, r2
    1cf4:	68f1      	ldr	r1, [r6, #12]
    1cf6:	4399      	bics	r1, r3
	const struct gpio_nrfx_data *data = get_port_data(port);
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
	uint32_t pin = 0U;
	uint32_t bit = 1U << pin;
    1cf8:	2201      	movs	r2, #1
	uint32_t pin = 0U;
    1cfa:	2000      	movs	r0, #0
	uint32_t level_pins = get_level_pins(port);

	/* Configure sense detection on all pins that use it. */
	while (level_pins) {
    1cfc:	e012      	b.n	1d24 <cfg_level_pins+0x44>
		return NRF_GPIO_PIN_SENSE_HIGH;
    1cfe:	2302      	movs	r3, #2
    1d00:	469c      	mov	ip, r3
    *p_pin = pin_number & 0x1F;
    1d02:	231f      	movs	r3, #31
    1d04:	402b      	ands	r3, r5
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    1d06:	25a0      	movs	r5, #160	; 0xa0
    1d08:	05ed      	lsls	r5, r5, #23
    1d0a:	33c1      	adds	r3, #193	; 0xc1
    1d0c:	33ff      	adds	r3, #255	; 0xff
    1d0e:	009b      	lsls	r3, r3, #2
    1d10:	595c      	ldr	r4, [r3, r5]
    1d12:	4f0f      	ldr	r7, [pc, #60]	; (1d50 <cfg_level_pins+0x70>)
    1d14:	403c      	ands	r4, r7
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    1d16:	4667      	mov	r7, ip
    1d18:	043f      	lsls	r7, r7, #16
    1d1a:	433c      	orrs	r4, r7
    1d1c:	515c      	str	r4, [r3, r5]
		if (level_pins & bit) {
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
			uint32_t sense = sense_for_pin(data, pin);

			nrf_gpio_cfg_sense_set(abs_pin, sense);
			level_pins &= ~bit;
    1d1e:	4391      	bics	r1, r2
		}
		++pin;
    1d20:	3001      	adds	r0, #1
		bit <<= 1;
    1d22:	0052      	lsls	r2, r2, #1
	while (level_pins) {
    1d24:	2900      	cmp	r1, #0
    1d26:	d00e      	beq.n	1d46 <cfg_level_pins+0x66>
		if (level_pins & bit) {
    1d28:	4211      	tst	r1, r2
    1d2a:	d0f9      	beq.n	1d20 <cfg_level_pins+0x40>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    1d2c:	464b      	mov	r3, r9
    1d2e:	7a1b      	ldrb	r3, [r3, #8]
    1d30:	015b      	lsls	r3, r3, #5
    1d32:	251f      	movs	r5, #31
    1d34:	4005      	ands	r5, r0
    1d36:	431d      	orrs	r5, r3
	if ((BIT(pin) & data->int_active_level) != 0U) {
    1d38:	6933      	ldr	r3, [r6, #16]
    1d3a:	40c3      	lsrs	r3, r0
    1d3c:	07db      	lsls	r3, r3, #31
    1d3e:	d4de      	bmi.n	1cfe <cfg_level_pins+0x1e>
	return NRF_GPIO_PIN_SENSE_LOW;
    1d40:	2303      	movs	r3, #3
    1d42:	469c      	mov	ip, r3
    1d44:	e7dd      	b.n	1d02 <cfg_level_pins+0x22>
	}
}
    1d46:	bc0c      	pop	{r2, r3}
    1d48:	4690      	mov	r8, r2
    1d4a:	4699      	mov	r9, r3
    1d4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d4e:	46c0      	nop			; (mov r8, r8)
    1d50:	fffcffff 	.word	0xfffcffff

00001d54 <check_level_trigger_pins>:
 *
 * @return Bitmask where 1 marks pin as trigger source.
 */
static uint32_t check_level_trigger_pins(const struct device *port,
					 uint32_t *sense_levels)
{
    1d54:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d56:	46d6      	mov	lr, sl
    1d58:	464f      	mov	r7, r9
    1d5a:	4646      	mov	r6, r8
    1d5c:	b5c0      	push	{r6, r7, lr}
    1d5e:	4688      	mov	r8, r1
	return port->data;
    1d60:	6903      	ldr	r3, [r0, #16]
	return port->config;
    1d62:	6842      	ldr	r2, [r0, #4]
    1d64:	4692      	mov	sl, r2
	out &= ~data->trig_edge & ~data->double_edge;
    1d66:	695a      	ldr	r2, [r3, #20]
    1d68:	6999      	ldr	r1, [r3, #24]
    1d6a:	430a      	orrs	r2, r1
    1d6c:	68df      	ldr	r7, [r3, #12]
    1d6e:	4397      	bics	r7, r2
    return p_reg->IN;
    1d70:	22a2      	movs	r2, #162	; 0xa2
    1d72:	00d2      	lsls	r2, r2, #3
    1d74:	4651      	mov	r1, sl
    1d76:	6849      	ldr	r1, [r1, #4]
    1d78:	588a      	ldr	r2, [r1, r2]
	uint32_t level_pins = get_level_pins(port);
	uint32_t port_in = nrf_gpio_port_in_read(cfg->port);

	/* Extract which pins have logic level same as interrupt trigger level.
	 */
	uint32_t pin_states = ~(port_in ^ data->int_active_level);
    1d7a:	691b      	ldr	r3, [r3, #16]
    1d7c:	4053      	eors	r3, r2

	/* Discard pins that aren't configured for level. */
	uint32_t out = pin_states & level_pins;
    1d7e:	003a      	movs	r2, r7
    1d80:	439a      	bics	r2, r3
    1d82:	4694      	mov	ip, r2
	uint32_t pin = 0U;
	uint32_t bit = 1U << pin;

	uint32_t port_latch = 0;

	uint32_t check_pins = level_pins;
    1d84:	003d      	movs	r5, r7
	uint32_t bit = 1U << pin;
    1d86:	2201      	movs	r2, #1
	uint32_t pin = 0U;
    1d88:	2600      	movs	r6, #0
#if IS_ENABLED(CONFIG_GPIO_NRF_INT_EDGE_USING_SENSE)
	/* Read LATCH, which will tell us which pin has changed its state. */
	port_latch = cfg->port->LATCH;
#endif

	while (check_pins) {
    1d8a:	e00d      	b.n	1da8 <check_level_trigger_pins+0x54>
    *p_pin = pin_number & 0x1F;
    1d8c:	231f      	movs	r3, #31
    1d8e:	4023      	ands	r3, r4
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    1d90:	20a0      	movs	r0, #160	; 0xa0
    1d92:	05c0      	lsls	r0, r0, #23
    1d94:	33c1      	adds	r3, #193	; 0xc1
    1d96:	33ff      	adds	r3, #255	; 0xff
    1d98:	009b      	lsls	r3, r3, #2
    1d9a:	581c      	ldr	r4, [r3, r0]
    1d9c:	4915      	ldr	r1, [pc, #84]	; (1df4 <check_level_trigger_pins+0xa0>)
    1d9e:	400c      	ands	r4, r1
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    1da0:	501c      	str	r4, [r3, r0]
					*sense_levels |= bit;
				}
			}

			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
			check_pins &= ~bit;
    1da2:	4395      	bics	r5, r2
		}
		++pin;
    1da4:	3601      	adds	r6, #1
		bit <<= 1;
    1da6:	0052      	lsls	r2, r2, #1
	while (check_pins) {
    1da8:	2d00      	cmp	r5, #0
    1daa:	d01c      	beq.n	1de6 <check_level_trigger_pins+0x92>
		if (check_pins & bit) {
    1dac:	4215      	tst	r5, r2
    1dae:	d0f9      	beq.n	1da4 <check_level_trigger_pins+0x50>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    1db0:	4653      	mov	r3, sl
    1db2:	7a1b      	ldrb	r3, [r3, #8]
    1db4:	015b      	lsls	r3, r3, #5
    1db6:	241f      	movs	r4, #31
    1db8:	4034      	ands	r4, r6
    1dba:	431c      	orrs	r4, r3
			if (!(level_pins & bit)) {
    1dbc:	4217      	tst	r7, r2
    1dbe:	d1e5      	bne.n	1d8c <check_level_trigger_pins+0x38>
    *p_pin = pin_number & 0x1F;
    1dc0:	231f      	movs	r3, #31
    1dc2:	4023      	ands	r3, r4
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    1dc4:	33c1      	adds	r3, #193	; 0xc1
    1dc6:	33ff      	adds	r3, #255	; 0xff
    1dc8:	009b      	lsls	r3, r3, #2
    1dca:	20a0      	movs	r0, #160	; 0xa0
    1dcc:	05c0      	lsls	r0, r0, #23
    1dce:	5818      	ldr	r0, [r3, r0]
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
    1dd0:	0c00      	lsrs	r0, r0, #16
    1dd2:	2303      	movs	r3, #3
    1dd4:	4003      	ands	r3, r0
				if (high) {
    1dd6:	2b02      	cmp	r3, #2
    1dd8:	d1d8      	bne.n	1d8c <check_level_trigger_pins+0x38>
					*sense_levels |= bit;
    1dda:	4643      	mov	r3, r8
    1ddc:	681b      	ldr	r3, [r3, #0]
    1dde:	4313      	orrs	r3, r2
    1de0:	4641      	mov	r1, r8
    1de2:	600b      	str	r3, [r1, #0]
    1de4:	e7d2      	b.n	1d8c <check_level_trigger_pins+0x38>
	 */
	cfg->port->LATCH = port_latch;
#endif

	return out;
}
    1de6:	4660      	mov	r0, ip
    1de8:	bc1c      	pop	{r2, r3, r4}
    1dea:	4690      	mov	r8, r2
    1dec:	4699      	mov	r9, r3
    1dee:	46a2      	mov	sl, r4
    1df0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1df2:	46c0      	nop			; (mov r8, r8)
    1df4:	fffcffff 	.word	0xfffcffff

00001df8 <gpiote_event_handler>:

	gpio_fire_callbacks(list, port, pins);
}

static void gpiote_event_handler(void)
{
    1df8:	b570      	push	{r4, r5, r6, lr}
    1dfa:	b084      	sub	sp, #16
	uint32_t fired_triggers[GPIO_COUNT] = {0};
    1dfc:	2300      	movs	r3, #0
    1dfe:	9303      	str	r3, [sp, #12]
	uint32_t sense_levels[GPIO_COUNT] = {0};
    1e00:	9302      	str	r3, [sp, #8]
}

NRF_STATIC_INLINE bool nrf_gpiote_event_check(NRF_GPIOTE_Type const * p_reg,
                                              nrf_gpiote_event_t      event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    1e02:	4b2e      	ldr	r3, [pc, #184]	; (1ebc <gpiote_event_handler+0xc4>)
    1e04:	681d      	ldr	r5, [r3, #0]
	bool port_event = nrf_gpiote_event_check(NRF_GPIOTE,
						 NRF_GPIOTE_EVENT_PORT);

	if (port_event) {
    1e06:	2d00      	cmp	r5, #0
    1e08:	d101      	bne.n	1e0e <gpiote_event_handler+0x16>
{
    1e0a:	2100      	movs	r1, #0
    1e0c:	e009      	b.n	1e22 <gpiote_event_handler+0x2a>
#ifdef CONFIG_GPIO_NRF_P0
		fired_triggers[0] =
			check_level_trigger_pins(DEVICE_DT_GET(GPIO(0)),
    1e0e:	a902      	add	r1, sp, #8
    1e10:	482b      	ldr	r0, [pc, #172]	; (1ec0 <gpiote_event_handler+0xc8>)
    1e12:	f7ff ff9f 	bl	1d54 <check_level_trigger_pins>
		fired_triggers[0] =
    1e16:	9003      	str	r0, [sp, #12]
}

NRF_STATIC_INLINE void nrf_gpiote_event_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_event_t event)
{
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    1e18:	4b28      	ldr	r3, [pc, #160]	; (1ebc <gpiote_event_handler+0xc4>)
    1e1a:	2200      	movs	r2, #0
    1e1c:	601a      	str	r2, [r3, #0]
    nrf_event_readback((void *)nrf_gpiote_event_address_get(p_reg, event));
}
    1e1e:	e7f4      	b.n	1e0a <gpiote_event_handler+0x12>
		 */
		nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
	}

	/* Handle interrupt from GPIOTE channels. */
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    1e20:	3101      	adds	r1, #1
    1e22:	2903      	cmp	r1, #3
    1e24:	d821      	bhi.n	1e6a <gpiote_event_handler+0x72>
		nrf_gpiote_event_t evt =
    1e26:	000b      	movs	r3, r1
    1e28:	3340      	adds	r3, #64	; 0x40
    1e2a:	009b      	lsls	r3, r3, #2
    1e2c:	b29a      	uxth	r2, r3
			offsetof(NRF_GPIOTE_Type, EVENTS_IN[i]);

		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    1e2e:	2301      	movs	r3, #1
    1e30:	408b      	lsls	r3, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    1e32:	4c24      	ldr	r4, [pc, #144]	; (1ec4 <gpiote_event_handler+0xcc>)
    1e34:	20c1      	movs	r0, #193	; 0xc1
    1e36:	0080      	lsls	r0, r0, #2
    1e38:	5820      	ldr	r0, [r4, r0]
    1e3a:	4218      	tst	r0, r3
    1e3c:	d0f0      	beq.n	1e20 <gpiote_event_handler+0x28>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    1e3e:	1913      	adds	r3, r2, r4
    1e40:	681b      	ldr	r3, [r3, #0]
    1e42:	2b00      	cmp	r3, #0
    1e44:	d0ec      	beq.n	1e20 <gpiote_event_handler+0x28>
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    1e46:	000b      	movs	r3, r1
    1e48:	3345      	adds	r3, #69	; 0x45
    1e4a:	33ff      	adds	r3, #255	; 0xff
    1e4c:	009b      	lsls	r3, r3, #2
    1e4e:	591b      	ldr	r3, [r3, r4]
    1e50:	0a1b      	lsrs	r3, r3, #8
    1e52:	201f      	movs	r0, #31
    1e54:	4018      	ands	r0, r3
		    nrf_gpiote_event_check(NRF_GPIOTE, evt)) {
			uint32_t abs_pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, i);
			/* Divide absolute pin number to port and pin parts. */
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    1e56:	2301      	movs	r3, #1
    1e58:	4083      	lsls	r3, r0
    1e5a:	9803      	ldr	r0, [sp, #12]
    1e5c:	9001      	str	r0, [sp, #4]
    1e5e:	4303      	orrs	r3, r0
    1e60:	9303      	str	r3, [sp, #12]
    return ((uint32_t)p_reg + event);
    1e62:	1913      	adds	r3, r2, r4
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    1e64:	2200      	movs	r2, #0
    1e66:	601a      	str	r2, [r3, #0]
}
    1e68:	e7da      	b.n	1e20 <gpiote_event_handler+0x28>
		cfg_edge_sense_pins(DEVICE_DT_GET(GPIO(1)), sense_levels[1]);
#endif
	}

#ifdef CONFIG_GPIO_NRF_P0
	if (fired_triggers[0]) {
    1e6a:	9e03      	ldr	r6, [sp, #12]
    1e6c:	2e00      	cmp	r6, #0
    1e6e:	d103      	bne.n	1e78 <gpiote_event_handler+0x80>
	if (fired_triggers[1]) {
		fire_callbacks(DEVICE_DT_GET(GPIO(1)), fired_triggers[1]);
	}
#endif

	if (port_event) {
    1e70:	2d00      	cmp	r5, #0
    1e72:	d11f      	bne.n	1eb4 <gpiote_event_handler+0xbc>
#endif
#ifdef CONFIG_GPIO_NRF_P1
		cfg_level_pins(DEVICE_DT_GET(GPIO(1)));
#endif
	}
}
    1e74:	b004      	add	sp, #16
    1e76:	bd70      	pop	{r4, r5, r6, pc}
	return list->head;
    1e78:	4b13      	ldr	r3, [pc, #76]	; (1ec8 <gpiote_event_handler+0xd0>)
    1e7a:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    1e7c:	2900      	cmp	r1, #0
    1e7e:	d003      	beq.n	1e88 <gpiote_event_handler+0x90>
    1e80:	1e0c      	subs	r4, r1, #0
Z_GENLIST_PEEK_NEXT(slist, snode)
    1e82:	d00a      	beq.n	1e9a <gpiote_event_handler+0xa2>
	return node->next;
    1e84:	680c      	ldr	r4, [r1, #0]
    1e86:	e008      	b.n	1e9a <gpiote_event_handler+0xa2>
    1e88:	000c      	movs	r4, r1
    1e8a:	e006      	b.n	1e9a <gpiote_event_handler+0xa2>
    1e8c:	2c00      	cmp	r4, #0
    1e8e:	d00f      	beq.n	1eb0 <gpiote_event_handler+0xb8>
    1e90:	1e23      	subs	r3, r4, #0
Z_GENLIST_PEEK_NEXT(slist, snode)
    1e92:	d000      	beq.n	1e96 <gpiote_event_handler+0x9e>
	return node->next;
    1e94:	6823      	ldr	r3, [r4, #0]
    1e96:	0021      	movs	r1, r4
    1e98:	001c      	movs	r4, r3
    1e9a:	2900      	cmp	r1, #0
    1e9c:	d0e8      	beq.n	1e70 <gpiote_event_handler+0x78>
		if (cb->pin_mask & pins) {
    1e9e:	688b      	ldr	r3, [r1, #8]
    1ea0:	001a      	movs	r2, r3
    1ea2:	4032      	ands	r2, r6
    1ea4:	4233      	tst	r3, r6
    1ea6:	d0f1      	beq.n	1e8c <gpiote_event_handler+0x94>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
    1ea8:	684b      	ldr	r3, [r1, #4]
    1eaa:	4805      	ldr	r0, [pc, #20]	; (1ec0 <gpiote_event_handler+0xc8>)
    1eac:	4798      	blx	r3
    1eae:	e7ed      	b.n	1e8c <gpiote_event_handler+0x94>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    1eb0:	0023      	movs	r3, r4
    1eb2:	e7f0      	b.n	1e96 <gpiote_event_handler+0x9e>
		cfg_level_pins(DEVICE_DT_GET(GPIO(0)));
    1eb4:	4802      	ldr	r0, [pc, #8]	; (1ec0 <gpiote_event_handler+0xc8>)
    1eb6:	f7ff ff13 	bl	1ce0 <cfg_level_pins>
}
    1eba:	e7db      	b.n	1e74 <gpiote_event_handler+0x7c>
    1ebc:	4000617c 	.word	0x4000617c
    1ec0:	00004eac 	.word	0x00004eac
    1ec4:	40006000 	.word	0x40006000
    1ec8:	20000248 	.word	0x20000248

00001ecc <gpiote_pin_cleanup>:
{
    1ecc:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
    1ece:	4a15      	ldr	r2, [pc, #84]	; (1f24 <gpiote_pin_cleanup+0x58>)
    1ed0:	23c1      	movs	r3, #193	; 0xc1
    1ed2:	009b      	lsls	r3, r3, #2
    1ed4:	58d3      	ldr	r3, [r2, r3]
    1ed6:	240f      	movs	r4, #15
    1ed8:	401c      	ands	r4, r3
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    1eda:	2300      	movs	r3, #0
    1edc:	e000      	b.n	1ee0 <gpiote_pin_cleanup+0x14>
    1ede:	3301      	adds	r3, #1
    1ee0:	2b03      	cmp	r3, #3
    1ee2:	d81e      	bhi.n	1f22 <gpiote_pin_cleanup+0x56>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    1ee4:	001a      	movs	r2, r3
    1ee6:	3245      	adds	r2, #69	; 0x45
    1ee8:	32ff      	adds	r2, #255	; 0xff
    1eea:	0092      	lsls	r2, r2, #2
    1eec:	490d      	ldr	r1, [pc, #52]	; (1f24 <gpiote_pin_cleanup+0x58>)
    1eee:	5851      	ldr	r1, [r2, r1]
    1ef0:	0a09      	lsrs	r1, r1, #8
    1ef2:	221f      	movs	r2, #31
    1ef4:	400a      	ands	r2, r1
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    1ef6:	4290      	cmp	r0, r2
    1ef8:	d1f1      	bne.n	1ede <gpiote_pin_cleanup+0x12>
		    && (intenset & BIT(i))) {
    1efa:	0022      	movs	r2, r4
    1efc:	40da      	lsrs	r2, r3
    1efe:	07d2      	lsls	r2, r2, #31
    1f00:	d5ed      	bpl.n	1ede <gpiote_pin_cleanup+0x12>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    1f02:	4808      	ldr	r0, [pc, #32]	; (1f24 <gpiote_pin_cleanup+0x58>)
    1f04:	0019      	movs	r1, r3
    1f06:	3145      	adds	r1, #69	; 0x45
    1f08:	31ff      	adds	r1, #255	; 0xff
    1f0a:	0089      	lsls	r1, r1, #2
    1f0c:	580c      	ldr	r4, [r1, r0]
    1f0e:	2201      	movs	r2, #1
    1f10:	4394      	bics	r4, r2
    1f12:	500c      	str	r4, [r1, r0]
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    1f14:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
    1f16:	21c2      	movs	r1, #194	; 0xc2
    1f18:	0089      	lsls	r1, r1, #2
    1f1a:	5042      	str	r2, [r0, r1]
			nrfx_gpiote_channel_free(i);
    1f1c:	b2d8      	uxtb	r0, r3
    1f1e:	f000 ffb5 	bl	2e8c <nrfx_gpiote_channel_free>
}
    1f22:	bd10      	pop	{r4, pc}
    1f24:	40006000 	.word	0x40006000

00001f28 <gpiote_channel_alloc>:
{
    1f28:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f2a:	b083      	sub	sp, #12
    1f2c:	0004      	movs	r4, r0
    1f2e:	000e      	movs	r6, r1
	if (nrfx_gpiote_channel_alloc(&channel) != NRFX_SUCCESS) {
    1f30:	466b      	mov	r3, sp
    1f32:	1dd8      	adds	r0, r3, #7
    1f34:	f000 ffc6 	bl	2ec4 <nrfx_gpiote_channel_alloc>
    1f38:	4b19      	ldr	r3, [pc, #100]	; (1fa0 <gpiote_channel_alloc+0x78>)
    1f3a:	4298      	cmp	r0, r3
    1f3c:	d12d      	bne.n	1f9a <gpiote_channel_alloc+0x72>
	nrf_gpiote_event_t evt = offsetof(NRF_GPIOTE_Type, EVENTS_IN[channel]);
    1f3e:	466b      	mov	r3, sp
    1f40:	1dda      	adds	r2, r3, #7
    1f42:	79db      	ldrb	r3, [r3, #7]
    1f44:	001f      	movs	r7, r3
    1f46:	3740      	adds	r7, #64	; 0x40
    1f48:	00bf      	lsls	r7, r7, #2
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    1f4a:	4d16      	ldr	r5, [pc, #88]	; (1fa4 <gpiote_channel_alloc+0x7c>)
    1f4c:	3345      	adds	r3, #69	; 0x45
    1f4e:	33ff      	adds	r3, #255	; 0xff
    1f50:	009b      	lsls	r3, r3, #2
    1f52:	5959      	ldr	r1, [r3, r5]
    1f54:	4814      	ldr	r0, [pc, #80]	; (1fa8 <gpiote_channel_alloc+0x80>)
    1f56:	4001      	ands	r1, r0
    1f58:	5159      	str	r1, [r3, r5]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    1f5a:	5958      	ldr	r0, [r3, r5]
    1f5c:	0224      	lsls	r4, r4, #8
    1f5e:	21f8      	movs	r1, #248	; 0xf8
    1f60:	0149      	lsls	r1, r1, #5
    1f62:	400c      	ands	r4, r1
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
    1f64:	0431      	lsls	r1, r6, #16
    1f66:	26c0      	movs	r6, #192	; 0xc0
    1f68:	02b6      	lsls	r6, r6, #10
    1f6a:	4031      	ands	r1, r6
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    1f6c:	430c      	orrs	r4, r1
    1f6e:	4304      	orrs	r4, r0
    1f70:	515c      	str	r4, [r3, r5]
    return ((uint32_t)p_reg + event);
    1f72:	46ac      	mov	ip, r5
    1f74:	4467      	add	r7, ip
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    1f76:	2100      	movs	r1, #0
    1f78:	6039      	str	r1, [r7, #0]
	nrf_gpiote_event_enable(NRF_GPIOTE, channel);
    1f7a:	7810      	ldrb	r0, [r2, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    1f7c:	0002      	movs	r2, r0
    1f7e:	3245      	adds	r2, #69	; 0x45
    1f80:	32ff      	adds	r2, #255	; 0xff
    1f82:	0092      	lsls	r2, r2, #2
    1f84:	5951      	ldr	r1, [r2, r5]
    1f86:	2301      	movs	r3, #1
    1f88:	4319      	orrs	r1, r3
    1f8a:	5151      	str	r1, [r2, r5]
	nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    1f8c:	4083      	lsls	r3, r0
    p_reg->INTENSET = mask;
    1f8e:	22c1      	movs	r2, #193	; 0xc1
    1f90:	0092      	lsls	r2, r2, #2
    1f92:	50ab      	str	r3, [r5, r2]
	return 0;
    1f94:	2000      	movs	r0, #0
}
    1f96:	b003      	add	sp, #12
    1f98:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENODEV;
    1f9a:	2013      	movs	r0, #19
    1f9c:	4240      	negs	r0, r0
    1f9e:	e7fa      	b.n	1f96 <gpiote_channel_alloc+0x6e>
    1fa0:	0bad0000 	.word	0x0bad0000
    1fa4:	40006000 	.word	0x40006000
    1fa8:	fffce0ff 	.word	0xfffce0ff

00001fac <gpiote_pin_int_cfg>:
{
    1fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1fae:	000d      	movs	r5, r1
	return port->data;
    1fb0:	6906      	ldr	r6, [r0, #16]
	return port->config;
    1fb2:	6843      	ldr	r3, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    1fb4:	7a1c      	ldrb	r4, [r3, #8]
    1fb6:	0164      	lsls	r4, r4, #5
    1fb8:	271f      	movs	r7, #31
    1fba:	003b      	movs	r3, r7
    1fbc:	400b      	ands	r3, r1
    1fbe:	431c      	orrs	r4, r3
	gpiote_pin_cleanup(abs_pin);
    1fc0:	0020      	movs	r0, r4
    1fc2:	f7ff ff83 	bl	1ecc <gpiote_pin_cleanup>
    *p_pin = pin_number & 0x1F;
    1fc6:	4027      	ands	r7, r4
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    1fc8:	21a0      	movs	r1, #160	; 0xa0
    1fca:	05c9      	lsls	r1, r1, #23
    1fcc:	003b      	movs	r3, r7
    1fce:	33c1      	adds	r3, #193	; 0xc1
    1fd0:	33ff      	adds	r3, #255	; 0xff
    1fd2:	009b      	lsls	r3, r3, #2
    1fd4:	585a      	ldr	r2, [r3, r1]
    1fd6:	4819      	ldr	r0, [pc, #100]	; (203c <gpiote_pin_int_cfg+0x90>)
    1fd8:	4002      	ands	r2, r0
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    1fda:	505a      	str	r2, [r3, r1]
	if (data->pin_int_en & BIT(pin)) {
    1fdc:	68f3      	ldr	r3, [r6, #12]
    1fde:	40eb      	lsrs	r3, r5
    1fe0:	07db      	lsls	r3, r3, #31
    1fe2:	d529      	bpl.n	2038 <gpiote_pin_int_cfg+0x8c>
		if (data->trig_edge & BIT(pin)) {
    1fe4:	6973      	ldr	r3, [r6, #20]
    1fe6:	40eb      	lsrs	r3, r5
    1fe8:	07db      	lsls	r3, r3, #31
    1fea:	d510      	bpl.n	200e <gpiote_pin_int_cfg+0x62>
				if (data->double_edge & BIT(pin)) {
    1fec:	69b3      	ldr	r3, [r6, #24]
    1fee:	40eb      	lsrs	r3, r5
    1ff0:	07db      	lsls	r3, r3, #31
    1ff2:	d405      	bmi.n	2000 <gpiote_pin_int_cfg+0x54>
				} else if ((data->int_active_level & BIT(pin)) != 0U) {
    1ff4:	6933      	ldr	r3, [r6, #16]
    1ff6:	40eb      	lsrs	r3, r5
    1ff8:	07db      	lsls	r3, r3, #31
    1ffa:	d506      	bpl.n	200a <gpiote_pin_int_cfg+0x5e>
					pol = NRF_GPIOTE_POLARITY_LOTOHI;
    1ffc:	2101      	movs	r1, #1
    1ffe:	e000      	b.n	2002 <gpiote_pin_int_cfg+0x56>
					pol = NRF_GPIOTE_POLARITY_TOGGLE;
    2000:	2103      	movs	r1, #3
				res = gpiote_channel_alloc(abs_pin, pol);
    2002:	0020      	movs	r0, r4
    2004:	f7ff ff90 	bl	1f28 <gpiote_channel_alloc>
    2008:	e017      	b.n	203a <gpiote_pin_int_cfg+0x8e>
					pol = NRF_GPIOTE_POLARITY_HITOLO;
    200a:	2102      	movs	r1, #2
    200c:	e7f9      	b.n	2002 <gpiote_pin_int_cfg+0x56>
	if ((BIT(pin) & data->int_active_level) != 0U) {
    200e:	6933      	ldr	r3, [r6, #16]
    2010:	40eb      	lsrs	r3, r5
    2012:	07db      	lsls	r3, r3, #31
    2014:	d40e      	bmi.n	2034 <gpiote_pin_int_cfg+0x88>
	return NRF_GPIO_PIN_SENSE_LOW;
    2016:	2103      	movs	r1, #3
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    2018:	20a0      	movs	r0, #160	; 0xa0
    201a:	05c0      	lsls	r0, r0, #23
    201c:	003b      	movs	r3, r7
    201e:	33c1      	adds	r3, #193	; 0xc1
    2020:	33ff      	adds	r3, #255	; 0xff
    2022:	009b      	lsls	r3, r3, #2
    2024:	581a      	ldr	r2, [r3, r0]
    2026:	4c05      	ldr	r4, [pc, #20]	; (203c <gpiote_pin_int_cfg+0x90>)
    2028:	4022      	ands	r2, r4
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    202a:	0409      	lsls	r1, r1, #16
    202c:	430a      	orrs	r2, r1
    202e:	501a      	str	r2, [r3, r0]
	int res = 0;
    2030:	2000      	movs	r0, #0
}
    2032:	e002      	b.n	203a <gpiote_pin_int_cfg+0x8e>
		return NRF_GPIO_PIN_SENSE_HIGH;
    2034:	2102      	movs	r1, #2
    2036:	e7ef      	b.n	2018 <gpiote_pin_int_cfg+0x6c>
	int res = 0;
    2038:	2000      	movs	r0, #0
}
    203a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    203c:	fffcffff 	.word	0xfffcffff

00002040 <gpio_nrfx_init>:

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    2040:	b510      	push	{r4, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    2042:	4b0c      	ldr	r3, [pc, #48]	; (2074 <gpio_nrfx_init+0x34>)
    2044:	781b      	ldrb	r3, [r3, #0]
    2046:	2b00      	cmp	r3, #0
    2048:	d001      	beq.n	204e <gpio_nrfx_init+0xe>
		irq_enable(DT_IRQN(GPIOTE_NODE));
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    204a:	2000      	movs	r0, #0
    204c:	bd10      	pop	{r4, pc}
		gpio_initialized = true;
    204e:	4b09      	ldr	r3, [pc, #36]	; (2074 <gpio_nrfx_init+0x34>)
    2050:	2201      	movs	r2, #1
    2052:	701a      	strb	r2, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    2054:	2200      	movs	r2, #0
    2056:	2101      	movs	r1, #1
    2058:	2006      	movs	r0, #6
    205a:	f7ff f9c5 	bl	13e8 <z_arm_irq_priority_set>
		irq_enable(DT_IRQN(GPIOTE_NODE));
    205e:	2006      	movs	r0, #6
    2060:	f7ff f9aa 	bl	13b8 <arch_irq_enable>
    2064:	4a04      	ldr	r2, [pc, #16]	; (2078 <gpio_nrfx_init+0x38>)
    2066:	23c1      	movs	r3, #193	; 0xc1
    2068:	009b      	lsls	r3, r3, #2
    206a:	2180      	movs	r1, #128	; 0x80
    206c:	0609      	lsls	r1, r1, #24
    206e:	50d1      	str	r1, [r2, r3]
}
    2070:	e7eb      	b.n	204a <gpio_nrfx_init+0xa>
    2072:	46c0      	nop			; (mov r8, r8)
    2074:	20000300 	.word	0x20000300
    2078:	40006000 	.word	0x40006000

0000207c <event_txdrdy_check>:
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type const * p_reg, nrf_uart_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    207c:	4b06      	ldr	r3, [pc, #24]	; (2098 <event_txdrdy_check+0x1c>)
    207e:	681b      	ldr	r3, [r3, #0]

static bool event_txdrdy_check(void)
{
	return (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_TXDRDY)
#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
		|| uart_sw_event_txdrdy
    2080:	2b00      	cmp	r3, #0
    2082:	d105      	bne.n	2090 <event_txdrdy_check+0x14>
    2084:	4b05      	ldr	r3, [pc, #20]	; (209c <event_txdrdy_check+0x20>)
    2086:	781b      	ldrb	r3, [r3, #0]
    2088:	2b00      	cmp	r3, #0
    208a:	d003      	beq.n	2094 <event_txdrdy_check+0x18>
    208c:	2001      	movs	r0, #1
    208e:	e000      	b.n	2092 <event_txdrdy_check+0x16>
    2090:	2001      	movs	r0, #1
#endif
	       );
}
    2092:	4770      	bx	lr
		|| uart_sw_event_txdrdy
    2094:	2000      	movs	r0, #0
    2096:	e7fc      	b.n	2092 <event_txdrdy_check+0x16>
    2098:	4000211c 	.word	0x4000211c
    209c:	20000302 	.word	0x20000302

000020a0 <event_txdrdy_clear>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    20a0:	2300      	movs	r3, #0
    20a2:	4a02      	ldr	r2, [pc, #8]	; (20ac <event_txdrdy_clear+0xc>)
    20a4:	6013      	str	r3, [r2, #0]

static void event_txdrdy_clear(void)
{
	nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_TXDRDY);
#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
	uart_sw_event_txdrdy = 0U;
    20a6:	4a02      	ldr	r2, [pc, #8]	; (20b0 <event_txdrdy_clear+0x10>)
    20a8:	7013      	strb	r3, [r2, #0]
#endif
}
    20aa:	4770      	bx	lr
    20ac:	4000211c 	.word	0x4000211c
    20b0:	20000302 	.word	0x20000302

000020b4 <baudrate_set>:

static int baudrate_set(const struct device *dev, uint32_t baudrate)
{
	nrf_uart_baudrate_t nrf_baudrate; /* calculated baudrate divisor */

	switch (baudrate) {
    20b4:	2396      	movs	r3, #150	; 0x96
    20b6:	021b      	lsls	r3, r3, #8
    20b8:	4299      	cmp	r1, r3
    20ba:	d100      	bne.n	20be <baudrate_set+0xa>
    20bc:	e07e      	b.n	21bc <baudrate_set+0x108>
    20be:	d847      	bhi.n	2150 <baudrate_set+0x9c>
    20c0:	2396      	movs	r3, #150	; 0x96
    20c2:	019b      	lsls	r3, r3, #6
    20c4:	4299      	cmp	r1, r3
    20c6:	d100      	bne.n	20ca <baudrate_set+0x16>
    20c8:	e07a      	b.n	21c0 <baudrate_set+0x10c>
    20ca:	d90b      	bls.n	20e4 <baudrate_set+0x30>
    20cc:	23e1      	movs	r3, #225	; 0xe1
    20ce:	01db      	lsls	r3, r3, #7
    20d0:	4299      	cmp	r1, r3
    20d2:	d100      	bne.n	20d6 <baudrate_set+0x22>
    20d4:	e07f      	b.n	21d6 <baudrate_set+0x122>
    20d6:	d92b      	bls.n	2130 <baudrate_set+0x7c>
    20d8:	4b49      	ldr	r3, [pc, #292]	; (2200 <baudrate_set+0x14c>)
    20da:	4299      	cmp	r1, r3
    20dc:	d135      	bne.n	214a <baudrate_set+0x96>
		break;
	case 28800:
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
		break;
	case 31250:
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
    20de:	2380      	movs	r3, #128	; 0x80
    20e0:	041b      	lsls	r3, r3, #16
    20e2:	e01a      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    20e4:	2396      	movs	r3, #150	; 0x96
    20e6:	00db      	lsls	r3, r3, #3
    20e8:	4299      	cmp	r1, r3
    20ea:	d100      	bne.n	20ee <baudrate_set+0x3a>
    20ec:	e06a      	b.n	21c4 <baudrate_set+0x110>
    20ee:	d90a      	bls.n	2106 <baudrate_set+0x52>
    20f0:	2396      	movs	r3, #150	; 0x96
    20f2:	011b      	lsls	r3, r3, #4
    20f4:	4299      	cmp	r1, r3
    20f6:	d100      	bne.n	20fa <baudrate_set+0x46>
    20f8:	e06a      	b.n	21d0 <baudrate_set+0x11c>
    20fa:	2396      	movs	r3, #150	; 0x96
    20fc:	015b      	lsls	r3, r3, #5
    20fe:	4299      	cmp	r1, r3
    2100:	d113      	bne.n	212a <baudrate_set+0x76>
		nrf_baudrate = NRF_UART_BAUDRATE_4800;
    2102:	4b40      	ldr	r3, [pc, #256]	; (2204 <baudrate_set+0x150>)
    2104:	e009      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    2106:	2396      	movs	r3, #150	; 0x96
    2108:	005b      	lsls	r3, r3, #1
    210a:	4299      	cmp	r1, r3
    210c:	d05d      	beq.n	21ca <baudrate_set+0x116>
    210e:	332d      	adds	r3, #45	; 0x2d
    2110:	33ff      	adds	r3, #255	; 0xff
    2112:	4299      	cmp	r1, r3
    2114:	d106      	bne.n	2124 <baudrate_set+0x70>
		nrf_baudrate = 0x00027000;
    2116:	239c      	movs	r3, #156	; 0x9c
    2118:	029b      	lsls	r3, r3, #10
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    211a:	493b      	ldr	r1, [pc, #236]	; (2208 <baudrate_set+0x154>)
    211c:	4a3b      	ldr	r2, [pc, #236]	; (220c <baudrate_set+0x158>)
    211e:	508b      	str	r3, [r1, r2]
		return -EINVAL;
	}

	nrf_uart_baudrate_set(uart0_addr, nrf_baudrate);

	return 0;
    2120:	2000      	movs	r0, #0
}
    2122:	4770      	bx	lr
	switch (baudrate) {
    2124:	2016      	movs	r0, #22
    2126:	4240      	negs	r0, r0
    2128:	e7fb      	b.n	2122 <baudrate_set+0x6e>
    212a:	2016      	movs	r0, #22
    212c:	4240      	negs	r0, r0
    212e:	e7f8      	b.n	2122 <baudrate_set+0x6e>
    2130:	23e1      	movs	r3, #225	; 0xe1
    2132:	019b      	lsls	r3, r3, #6
    2134:	4299      	cmp	r1, r3
    2136:	d050      	beq.n	21da <baudrate_set+0x126>
    2138:	2396      	movs	r3, #150	; 0x96
    213a:	01db      	lsls	r3, r3, #7
    213c:	4299      	cmp	r1, r3
    213e:	d101      	bne.n	2144 <baudrate_set+0x90>
		nrf_baudrate = NRF_UART_BAUDRATE_19200;
    2140:	4b33      	ldr	r3, [pc, #204]	; (2210 <baudrate_set+0x15c>)
    2142:	e7ea      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    2144:	2016      	movs	r0, #22
    2146:	4240      	negs	r0, r0
    2148:	e7eb      	b.n	2122 <baudrate_set+0x6e>
    214a:	2016      	movs	r0, #22
    214c:	4240      	negs	r0, r0
    214e:	e7e8      	b.n	2122 <baudrate_set+0x6e>
    2150:	23e1      	movs	r3, #225	; 0xe1
    2152:	029b      	lsls	r3, r3, #10
    2154:	4299      	cmp	r1, r3
    2156:	d043      	beq.n	21e0 <baudrate_set+0x12c>
    2158:	d90a      	bls.n	2170 <baudrate_set+0xbc>
    215a:	23e1      	movs	r3, #225	; 0xe1
    215c:	031b      	lsls	r3, r3, #12
    215e:	4299      	cmp	r1, r3
    2160:	d045      	beq.n	21ee <baudrate_set+0x13a>
    2162:	d91f      	bls.n	21a4 <baudrate_set+0xf0>
    2164:	4b2b      	ldr	r3, [pc, #172]	; (2214 <baudrate_set+0x160>)
    2166:	4299      	cmp	r1, r3
    2168:	d146      	bne.n	21f8 <baudrate_set+0x144>
		nrf_baudrate = NRF_UART_BAUDRATE_1000000;
    216a:	2380      	movs	r3, #128	; 0x80
    216c:	055b      	lsls	r3, r3, #21
    216e:	e7d4      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    2170:	2396      	movs	r3, #150	; 0x96
    2172:	025b      	lsls	r3, r3, #9
    2174:	4299      	cmp	r1, r3
    2176:	d035      	beq.n	21e4 <baudrate_set+0x130>
    2178:	d905      	bls.n	2186 <baudrate_set+0xd2>
    217a:	23e1      	movs	r3, #225	; 0xe1
    217c:	025b      	lsls	r3, r3, #9
    217e:	4299      	cmp	r1, r3
    2180:	d10d      	bne.n	219e <baudrate_set+0xea>
		nrf_baudrate = NRF_UART_BAUDRATE_115200;
    2182:	4b25      	ldr	r3, [pc, #148]	; (2218 <baudrate_set+0x164>)
    2184:	e7c9      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    2186:	4b25      	ldr	r3, [pc, #148]	; (221c <baudrate_set+0x168>)
    2188:	4299      	cmp	r1, r3
    218a:	d02d      	beq.n	21e8 <baudrate_set+0x134>
    218c:	23e1      	movs	r3, #225	; 0xe1
    218e:	021b      	lsls	r3, r3, #8
    2190:	4299      	cmp	r1, r3
    2192:	d101      	bne.n	2198 <baudrate_set+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_57600;
    2194:	4b22      	ldr	r3, [pc, #136]	; (2220 <baudrate_set+0x16c>)
    2196:	e7c0      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    2198:	2016      	movs	r0, #22
    219a:	4240      	negs	r0, r0
    219c:	e7c1      	b.n	2122 <baudrate_set+0x6e>
    219e:	2016      	movs	r0, #22
    21a0:	4240      	negs	r0, r0
    21a2:	e7be      	b.n	2122 <baudrate_set+0x6e>
    21a4:	4b1f      	ldr	r3, [pc, #124]	; (2224 <baudrate_set+0x170>)
    21a6:	4299      	cmp	r1, r3
    21a8:	d023      	beq.n	21f2 <baudrate_set+0x13e>
    21aa:	23e1      	movs	r3, #225	; 0xe1
    21ac:	02db      	lsls	r3, r3, #11
    21ae:	4299      	cmp	r1, r3
    21b0:	d101      	bne.n	21b6 <baudrate_set+0x102>
		nrf_baudrate = NRF_UART_BAUDRATE_460800;
    21b2:	4b1d      	ldr	r3, [pc, #116]	; (2228 <baudrate_set+0x174>)
    21b4:	e7b1      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    21b6:	2016      	movs	r0, #22
    21b8:	4240      	negs	r0, r0
    21ba:	e7b2      	b.n	2122 <baudrate_set+0x6e>
		nrf_baudrate = NRF_UART_BAUDRATE_38400;
    21bc:	4b1b      	ldr	r3, [pc, #108]	; (222c <baudrate_set+0x178>)
    21be:	e7ac      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_9600;
    21c0:	4b1b      	ldr	r3, [pc, #108]	; (2230 <baudrate_set+0x17c>)
    21c2:	e7aa      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_1200;
    21c4:	239e      	movs	r3, #158	; 0x9e
    21c6:	02db      	lsls	r3, r3, #11
    21c8:	e7a7      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    21ca:	23a0      	movs	r3, #160	; 0xa0
    21cc:	025b      	lsls	r3, r3, #9
    21ce:	e7a4      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_2400;
    21d0:	239d      	movs	r3, #157	; 0x9d
    21d2:	031b      	lsls	r3, r3, #12
    21d4:	e7a1      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
    21d6:	4b17      	ldr	r3, [pc, #92]	; (2234 <baudrate_set+0x180>)
    21d8:	e79f      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_14400;
    21da:	23ec      	movs	r3, #236	; 0xec
    21dc:	039b      	lsls	r3, r3, #14
    21de:	e79c      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_230400;
    21e0:	4b15      	ldr	r3, [pc, #84]	; (2238 <baudrate_set+0x184>)
    21e2:	e79a      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_76800;
    21e4:	4b15      	ldr	r3, [pc, #84]	; (223c <baudrate_set+0x188>)
    21e6:	e798      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_56000;
    21e8:	23e5      	movs	r3, #229	; 0xe5
    21ea:	041b      	lsls	r3, r3, #16
    21ec:	e795      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_921600;
    21ee:	4b14      	ldr	r3, [pc, #80]	; (2240 <baudrate_set+0x18c>)
    21f0:	e793      	b.n	211a <baudrate_set+0x66>
		nrf_baudrate = NRF_UART_BAUDRATE_250000;
    21f2:	2380      	movs	r3, #128	; 0x80
    21f4:	04db      	lsls	r3, r3, #19
    21f6:	e790      	b.n	211a <baudrate_set+0x66>
	switch (baudrate) {
    21f8:	2016      	movs	r0, #22
    21fa:	4240      	negs	r0, r0
    21fc:	e791      	b.n	2122 <baudrate_set+0x6e>
    21fe:	46c0      	nop			; (mov r8, r8)
    2200:	00007a12 	.word	0x00007a12
    2204:	0013b000 	.word	0x0013b000
    2208:	40002000 	.word	0x40002000
    220c:	00000524 	.word	0x00000524
    2210:	004ea000 	.word	0x004ea000
    2214:	000f4240 	.word	0x000f4240
    2218:	01d7e000 	.word	0x01d7e000
    221c:	0000dac0 	.word	0x0000dac0
    2220:	00ebf000 	.word	0x00ebf000
    2224:	0003d090 	.word	0x0003d090
    2228:	075f7000 	.word	0x075f7000
    222c:	009d5000 	.word	0x009d5000
    2230:	00275000 	.word	0x00275000
    2234:	0075f000 	.word	0x0075f000
    2238:	03afb000 	.word	0x03afb000
    223c:	013a9000 	.word	0x013a9000
    2240:	0ebed000 	.word	0x0ebed000

00002244 <uart_nrfx_poll_in>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2244:	4b08      	ldr	r3, [pc, #32]	; (2268 <uart_nrfx_poll_in+0x24>)
    2246:	681b      	ldr	r3, [r3, #0]
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */

static int uart_nrfx_poll_in(const struct device *dev, unsigned char *c)
{
	if (!nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
    2248:	2b00      	cmp	r3, #0
    224a:	d009      	beq.n	2260 <uart_nrfx_poll_in+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    224c:	4b06      	ldr	r3, [pc, #24]	; (2268 <uart_nrfx_poll_in+0x24>)
    224e:	2200      	movs	r2, #0
    2250:	601a      	str	r2, [r3, #0]
    return p_reg->RXD;
    2252:	4a06      	ldr	r2, [pc, #24]	; (226c <uart_nrfx_poll_in+0x28>)
    2254:	23a3      	movs	r3, #163	; 0xa3
    2256:	00db      	lsls	r3, r3, #3
    2258:	58d3      	ldr	r3, [r2, r3]

	/* Clear the interrupt */
	nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_RXDRDY);

	/* got a character */
	*c = nrf_uart_rxd_get(uart0_addr);
    225a:	700b      	strb	r3, [r1, #0]

	return 0;
    225c:	2000      	movs	r0, #0
}
    225e:	4770      	bx	lr
		return -1;
    2260:	2001      	movs	r0, #1
    2262:	4240      	negs	r0, r0
    2264:	e7fb      	b.n	225e <uart_nrfx_poll_in+0x1a>
    2266:	46c0      	nop			; (mov r8, r8)
    2268:	40002108 	.word	0x40002108
    226c:	40002000 	.word	0x40002000

00002270 <uart_nrfx_err_check>:
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    2270:	4a02      	ldr	r2, [pc, #8]	; (227c <uart_nrfx_err_check+0xc>)
    2272:	2390      	movs	r3, #144	; 0x90
    2274:	00db      	lsls	r3, r3, #3
    2276:	58d0      	ldr	r0, [r2, r3]
    p_reg->ERRORSRC = errsrc_mask;
    2278:	50d0      	str	r0, [r2, r3]
/** Console I/O function */
static int uart_nrfx_err_check(const struct device *dev)
{
	/* register bitfields maps to the defines in uart.h */
	return nrf_uart_errorsrc_get_and_clear(uart0_addr);
}
    227a:	4770      	bx	lr
    227c:	40002000 	.word	0x40002000

00002280 <uart_nrfx_configure>:

static int uart_nrfx_configure(const struct device *dev,
			       const struct uart_config *cfg)
{
    2280:	b530      	push	{r4, r5, lr}
    2282:	b083      	sub	sp, #12
    2284:	0005      	movs	r5, r0
    2286:	000c      	movs	r4, r1
		break;
	default:
		return -ENOTSUP;
	}
#else
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
    2288:	794b      	ldrb	r3, [r1, #5]
    228a:	2b01      	cmp	r3, #1
    228c:	d132      	bne.n	22f4 <uart_nrfx_configure+0x74>
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    228e:	798b      	ldrb	r3, [r1, #6]
    2290:	2b03      	cmp	r3, #3
    2292:	d132      	bne.n	22fa <uart_nrfx_configure+0x7a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    2294:	79cb      	ldrb	r3, [r1, #7]
    2296:	2b00      	cmp	r3, #0
    2298:	d005      	beq.n	22a6 <uart_nrfx_configure+0x26>
    229a:	2b01      	cmp	r3, #1
    229c:	d00e      	beq.n	22bc <uart_nrfx_configure+0x3c>
    229e:	2086      	movs	r0, #134	; 0x86
    22a0:	4240      	negs	r0, r0
	nrf_uart_configure(uart0_addr, &uart_cfg);

	get_dev_data(dev)->uart_config = *cfg;

	return 0;
}
    22a2:	b003      	add	sp, #12
    22a4:	bd30      	pop	{r4, r5, pc}
		uart_cfg.hwfc = NRF_UART_HWFC_DISABLED;
    22a6:	ab01      	add	r3, sp, #4
    22a8:	2200      	movs	r2, #0
    22aa:	701a      	strb	r2, [r3, #0]
	switch (cfg->parity) {
    22ac:	7923      	ldrb	r3, [r4, #4]
    22ae:	2b00      	cmp	r3, #0
    22b0:	d008      	beq.n	22c4 <uart_nrfx_configure+0x44>
    22b2:	2b02      	cmp	r3, #2
    22b4:	d01a      	beq.n	22ec <uart_nrfx_configure+0x6c>
    22b6:	2086      	movs	r0, #134	; 0x86
    22b8:	4240      	negs	r0, r0
    22ba:	e7f2      	b.n	22a2 <uart_nrfx_configure+0x22>
			uart_cfg.hwfc = NRF_UART_HWFC_ENABLED;
    22bc:	ab01      	add	r3, sp, #4
    22be:	2201      	movs	r2, #1
    22c0:	701a      	strb	r2, [r3, #0]
		break;
    22c2:	e7f3      	b.n	22ac <uart_nrfx_configure+0x2c>
		uart_cfg.parity = NRF_UART_PARITY_EXCLUDED;
    22c4:	ab01      	add	r3, sp, #4
    22c6:	2200      	movs	r2, #0
    22c8:	705a      	strb	r2, [r3, #1]
	if (baudrate_set(dev, cfg->baudrate) != 0) {
    22ca:	6821      	ldr	r1, [r4, #0]
    22cc:	0028      	movs	r0, r5
    22ce:	f7ff fef1 	bl	20b4 <baudrate_set>
    22d2:	2800      	cmp	r0, #0
    22d4:	d114      	bne.n	2300 <uart_nrfx_configure+0x80>
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    22d6:	aa01      	add	r2, sp, #4
    22d8:	7853      	ldrb	r3, [r2, #1]
                    | (uint32_t)p_cfg->hwfc;
    22da:	7812      	ldrb	r2, [r2, #0]
    22dc:	4313      	orrs	r3, r2
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    22de:	490a      	ldr	r1, [pc, #40]	; (2308 <uart_nrfx_configure+0x88>)
    22e0:	4a0a      	ldr	r2, [pc, #40]	; (230c <uart_nrfx_configure+0x8c>)
    22e2:	508b      	str	r3, [r1, r2]
	return dev->data;
    22e4:	692b      	ldr	r3, [r5, #16]
	get_dev_data(dev)->uart_config = *cfg;
    22e6:	cc06      	ldmia	r4!, {r1, r2}
    22e8:	c306      	stmia	r3!, {r1, r2}
	return 0;
    22ea:	e7da      	b.n	22a2 <uart_nrfx_configure+0x22>
		uart_cfg.parity = NRF_UART_PARITY_INCLUDED;
    22ec:	ab01      	add	r3, sp, #4
    22ee:	220e      	movs	r2, #14
    22f0:	705a      	strb	r2, [r3, #1]
		break;
    22f2:	e7ea      	b.n	22ca <uart_nrfx_configure+0x4a>
		return -ENOTSUP;
    22f4:	2086      	movs	r0, #134	; 0x86
    22f6:	4240      	negs	r0, r0
    22f8:	e7d3      	b.n	22a2 <uart_nrfx_configure+0x22>
		return -ENOTSUP;
    22fa:	2086      	movs	r0, #134	; 0x86
    22fc:	4240      	negs	r0, r0
    22fe:	e7d0      	b.n	22a2 <uart_nrfx_configure+0x22>
		return -ENOTSUP;
    2300:	2086      	movs	r0, #134	; 0x86
    2302:	4240      	negs	r0, r0
    2304:	e7cd      	b.n	22a2 <uart_nrfx_configure+0x22>
    2306:	46c0      	nop			; (mov r8, r8)
    2308:	40002000 	.word	0x40002000
    230c:	0000056c 	.word	0x0000056c

00002310 <uart_nrfx_fifo_fill>:

/** Interrupt driven FIFO fill function */
static int uart_nrfx_fifo_fill(const struct device *dev,
			       const uint8_t *tx_data,
			       int len)
{
    2310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2312:	000f      	movs	r7, r1
    2314:	0016      	movs	r6, r2
	uint8_t num_tx = 0U;
    2316:	2400      	movs	r4, #0

	while ((len - num_tx > 0) &&
    2318:	0025      	movs	r5, r4
    231a:	1b33      	subs	r3, r6, r4
    231c:	2b00      	cmp	r3, #0
    231e:	dd0c      	ble.n	233a <uart_nrfx_fifo_fill+0x2a>
	       event_txdrdy_check()) {
    2320:	f7ff feac 	bl	207c <event_txdrdy_check>
	while ((len - num_tx > 0) &&
    2324:	2800      	cmp	r0, #0
    2326:	d008      	beq.n	233a <uart_nrfx_fifo_fill+0x2a>

		/* Clear the interrupt */
		event_txdrdy_clear();
    2328:	f7ff feba 	bl	20a0 <event_txdrdy_clear>

		/* Send a character */
		nrf_uart_txd_set(uart0_addr, (uint8_t)tx_data[num_tx++]);
    232c:	1c63      	adds	r3, r4, #1
    232e:	5d39      	ldrb	r1, [r7, r4]
    p_reg->TXD = txd;
    2330:	4a03      	ldr	r2, [pc, #12]	; (2340 <uart_nrfx_fifo_fill+0x30>)
    2332:	4804      	ldr	r0, [pc, #16]	; (2344 <uart_nrfx_fifo_fill+0x34>)
    2334:	5011      	str	r1, [r2, r0]
    2336:	b2dc      	uxtb	r4, r3
}
    2338:	e7ee      	b.n	2318 <uart_nrfx_fifo_fill+0x8>
	}

	return (int)num_tx;
}
    233a:	0028      	movs	r0, r5
    233c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    233e:	46c0      	nop			; (mov r8, r8)
    2340:	40002000 	.word	0x40002000
    2344:	0000051c 	.word	0x0000051c

00002348 <uart_nrfx_fifo_read>:

/** Interrupt driven FIFO read function */
static int uart_nrfx_fifo_read(const struct device *dev,
			       uint8_t *rx_data,
			       const int size)
{
    2348:	b530      	push	{r4, r5, lr}
	uint8_t num_rx = 0U;
    234a:	2300      	movs	r3, #0

	while ((size - num_rx > 0) &&
    234c:	0018      	movs	r0, r3
    234e:	1ad4      	subs	r4, r2, r3
    2350:	2c00      	cmp	r4, #0
    2352:	dd0e      	ble.n	2372 <uart_nrfx_fifo_read+0x2a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2354:	4c07      	ldr	r4, [pc, #28]	; (2374 <uart_nrfx_fifo_read+0x2c>)
    2356:	6824      	ldr	r4, [r4, #0]
    2358:	2c00      	cmp	r4, #0
    235a:	d00a      	beq.n	2372 <uart_nrfx_fifo_read+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    235c:	4805      	ldr	r0, [pc, #20]	; (2374 <uart_nrfx_fifo_read+0x2c>)
    235e:	2400      	movs	r4, #0
    2360:	6004      	str	r4, [r0, #0]
	       nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
		/* Clear the interrupt */
		nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_RXDRDY);

		/* Receive a character */
		rx_data[num_rx++] = (uint8_t)nrf_uart_rxd_get(uart0_addr);
    2362:	1c58      	adds	r0, r3, #1
    return p_reg->RXD;
    2364:	4d04      	ldr	r5, [pc, #16]	; (2378 <uart_nrfx_fifo_read+0x30>)
    2366:	24a3      	movs	r4, #163	; 0xa3
    2368:	00e4      	lsls	r4, r4, #3
    236a:	592c      	ldr	r4, [r5, r4]
    236c:	54cc      	strb	r4, [r1, r3]
    236e:	b2c3      	uxtb	r3, r0
    2370:	e7ec      	b.n	234c <uart_nrfx_fifo_read+0x4>
	}

	return num_rx;
}
    2372:	bd30      	pop	{r4, r5, pc}
    2374:	40002108 	.word	0x40002108
    2378:	40002000 	.word	0x40002000

0000237c <uart_nrfx_irq_tx_enable>:
/** Interrupt driven transfer enabling function */
static void uart_nrfx_irq_tx_enable(const struct device *dev)
{
	uint32_t key;

	disable_tx_irq = false;
    237c:	4b0e      	ldr	r3, [pc, #56]	; (23b8 <uart_nrfx_irq_tx_enable+0x3c>)
    237e:	2200      	movs	r2, #0
    2380:	701a      	strb	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2382:	4b0e      	ldr	r3, [pc, #56]	; (23bc <uart_nrfx_irq_tx_enable+0x40>)
    2384:	3201      	adds	r2, #1
    2386:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
    2388:	4a0d      	ldr	r2, [pc, #52]	; (23c0 <uart_nrfx_irq_tx_enable+0x44>)
    238a:	23c1      	movs	r3, #193	; 0xc1
    238c:	009b      	lsls	r3, r3, #2
    238e:	2180      	movs	r1, #128	; 0x80
    2390:	50d1      	str	r1, [r2, r3]
	__asm__ volatile("mrs %0, PRIMASK;"
    2392:	f3ef 8310 	mrs	r3, PRIMASK
    2396:	b672      	cpsid	i
	/* Critical section is used to avoid any UART related interrupt which
	 * can occur after the if statement and before call of the function
	 * forcing an interrupt.
	 */
	key = irq_lock();
	if (uart_sw_event_txdrdy) {
    2398:	4a0a      	ldr	r2, [pc, #40]	; (23c4 <uart_nrfx_irq_tx_enable+0x48>)
    239a:	7812      	ldrb	r2, [r2, #0]
    239c:	2a00      	cmp	r2, #0
    239e:	d004      	beq.n	23aa <uart_nrfx_irq_tx_enable+0x2e>
    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    23a0:	4909      	ldr	r1, [pc, #36]	; (23c8 <uart_nrfx_irq_tx_enable+0x4c>)
    23a2:	2280      	movs	r2, #128	; 0x80
    23a4:	0052      	lsls	r2, r2, #1
    23a6:	2004      	movs	r0, #4
    23a8:	5088      	str	r0, [r1, r2]
	if (key != 0U) {
    23aa:	2b00      	cmp	r3, #0
    23ac:	d102      	bne.n	23b4 <uart_nrfx_irq_tx_enable+0x38>
	__asm__ volatile(
    23ae:	b662      	cpsie	i
    23b0:	f3bf 8f6f 	isb	sy
		 * triggered by the software.
		 */
		NVIC_SetPendingIRQ(IRQN);
	}
	irq_unlock(key);
}
    23b4:	4770      	bx	lr
    23b6:	46c0      	nop			; (mov r8, r8)
    23b8:	20000301 	.word	0x20000301
    23bc:	40002008 	.word	0x40002008
    23c0:	40002000 	.word	0x40002000
    23c4:	20000302 	.word	0x20000302
    23c8:	e000e100 	.word	0xe000e100

000023cc <uart_nrfx_irq_tx_disable>:

/** Interrupt driven transfer disabling function */
static void uart_nrfx_irq_tx_disable(const struct device *dev)
{
	/* Disable TX interrupt in uart_nrfx_isr() when transmission is done. */
	disable_tx_irq = true;
    23cc:	4b01      	ldr	r3, [pc, #4]	; (23d4 <uart_nrfx_irq_tx_disable+0x8>)
    23ce:	2201      	movs	r2, #1
    23d0:	701a      	strb	r2, [r3, #0]
}
    23d2:	4770      	bx	lr
    23d4:	20000301 	.word	0x20000301

000023d8 <uart_nrfx_irq_rx_enable>:
    23d8:	4a02      	ldr	r2, [pc, #8]	; (23e4 <uart_nrfx_irq_rx_enable+0xc>)
    23da:	23c1      	movs	r3, #193	; 0xc1
    23dc:	009b      	lsls	r3, r3, #2
    23de:	2104      	movs	r1, #4
    23e0:	50d1      	str	r1, [r2, r3]

/** Interrupt driven receiver enabling function */
static void uart_nrfx_irq_rx_enable(const struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    23e2:	4770      	bx	lr
    23e4:	40002000 	.word	0x40002000

000023e8 <uart_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
    23e8:	4a02      	ldr	r2, [pc, #8]	; (23f4 <uart_nrfx_irq_rx_disable+0xc>)
    23ea:	23c2      	movs	r3, #194	; 0xc2
    23ec:	009b      	lsls	r3, r3, #2
    23ee:	2104      	movs	r1, #4
    23f0:	50d1      	str	r1, [r2, r3]

/** Interrupt driven receiver disabling function */
static void uart_nrfx_irq_rx_disable(const struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    23f2:	4770      	bx	lr
    23f4:	40002000 	.word	0x40002000

000023f8 <uart_nrfx_irq_tx_ready_complete>:

/** Interrupt driven transfer empty function */
static int uart_nrfx_irq_tx_ready_complete(const struct device *dev)
{
    23f8:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
    23fa:	4a0b      	ldr	r2, [pc, #44]	; (2428 <uart_nrfx_irq_tx_ready_complete+0x30>)
    23fc:	23c1      	movs	r3, #193	; 0xc1
    23fe:	009b      	lsls	r3, r3, #2
    2400:	58d3      	ldr	r3, [r2, r3]
	 * called after the TX interrupt is requested to be disabled but before
	 * the disabling is actually performed (in the IRQ handler).
	 */
	return nrf_uart_int_enable_check(uart0_addr,
					 NRF_UART_INT_MASK_TXDRDY) &&
	       !disable_tx_irq &&
    2402:	061b      	lsls	r3, r3, #24
    2404:	d50b      	bpl.n	241e <uart_nrfx_irq_tx_ready_complete+0x26>
    2406:	4b09      	ldr	r3, [pc, #36]	; (242c <uart_nrfx_irq_tx_ready_complete+0x34>)
    2408:	781b      	ldrb	r3, [r3, #0]
					 NRF_UART_INT_MASK_TXDRDY) &&
    240a:	2b00      	cmp	r3, #0
    240c:	d001      	beq.n	2412 <uart_nrfx_irq_tx_ready_complete+0x1a>
	       !disable_tx_irq &&
    240e:	2000      	movs	r0, #0
    2410:	e006      	b.n	2420 <uart_nrfx_irq_tx_ready_complete+0x28>
	       event_txdrdy_check();
    2412:	f7ff fe33 	bl	207c <event_txdrdy_check>
	       !disable_tx_irq &&
    2416:	2800      	cmp	r0, #0
    2418:	d003      	beq.n	2422 <uart_nrfx_irq_tx_ready_complete+0x2a>
    241a:	2001      	movs	r0, #1
    241c:	e000      	b.n	2420 <uart_nrfx_irq_tx_ready_complete+0x28>
    241e:	2000      	movs	r0, #0
}
    2420:	bd10      	pop	{r4, pc}
	       !disable_tx_irq &&
    2422:	2000      	movs	r0, #0
    2424:	e7fc      	b.n	2420 <uart_nrfx_irq_tx_ready_complete+0x28>
    2426:	46c0      	nop			; (mov r8, r8)
    2428:	40002000 	.word	0x40002000
    242c:	20000301 	.word	0x20000301

00002430 <uart_nrfx_irq_rx_ready>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2430:	4b02      	ldr	r3, [pc, #8]	; (243c <uart_nrfx_irq_rx_ready+0xc>)
    2432:	6818      	ldr	r0, [r3, #0]
    2434:	1e43      	subs	r3, r0, #1
    2436:	4198      	sbcs	r0, r3
    2438:	b2c0      	uxtb	r0, r0

/** Interrupt driven receiver ready function */
static int uart_nrfx_irq_rx_ready(const struct device *dev)
{
	return nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY);
}
    243a:	4770      	bx	lr
    243c:	40002108 	.word	0x40002108

00002440 <uart_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
    2440:	4a03      	ldr	r2, [pc, #12]	; (2450 <uart_nrfx_irq_err_enable+0x10>)
    2442:	23c1      	movs	r3, #193	; 0xc1
    2444:	009b      	lsls	r3, r3, #2
    2446:	2180      	movs	r1, #128	; 0x80
    2448:	0089      	lsls	r1, r1, #2
    244a:	50d1      	str	r1, [r2, r3]

/** Interrupt driven error enabling function */
static void uart_nrfx_irq_err_enable(const struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    244c:	4770      	bx	lr
    244e:	46c0      	nop			; (mov r8, r8)
    2450:	40002000 	.word	0x40002000

00002454 <uart_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
    2454:	4a03      	ldr	r2, [pc, #12]	; (2464 <uart_nrfx_irq_err_disable+0x10>)
    2456:	23c2      	movs	r3, #194	; 0xc2
    2458:	009b      	lsls	r3, r3, #2
    245a:	2180      	movs	r1, #128	; 0x80
    245c:	0089      	lsls	r1, r1, #2
    245e:	50d1      	str	r1, [r2, r3]

/** Interrupt driven error disabling function */
static void uart_nrfx_irq_err_disable(const struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    2460:	4770      	bx	lr
    2462:	46c0      	nop			; (mov r8, r8)
    2464:	40002000 	.word	0x40002000

00002468 <uart_nrfx_irq_is_pending>:

/** Interrupt driven pending status function */
static int uart_nrfx_irq_is_pending(const struct device *dev)
{
    2468:	b510      	push	{r4, lr}
    246a:	0004      	movs	r4, r0
    return p_reg->INTENSET & mask;
    246c:	4a0d      	ldr	r2, [pc, #52]	; (24a4 <uart_nrfx_irq_is_pending+0x3c>)
    246e:	23c1      	movs	r3, #193	; 0xc1
    2470:	009b      	lsls	r3, r3, #2
    2472:	58d3      	ldr	r3, [r2, r3]
	return ((nrf_uart_int_enable_check(uart0_addr,
					   NRF_UART_INT_MASK_TXDRDY) &&
		 uart_nrfx_irq_tx_ready_complete(dev))
		||
    2474:	061b      	lsls	r3, r3, #24
    2476:	d407      	bmi.n	2488 <uart_nrfx_irq_is_pending+0x20>
    2478:	4a0a      	ldr	r2, [pc, #40]	; (24a4 <uart_nrfx_irq_is_pending+0x3c>)
    247a:	23c1      	movs	r3, #193	; 0xc1
    247c:	009b      	lsls	r3, r3, #2
    247e:	58d3      	ldr	r3, [r2, r3]
    2480:	075b      	lsls	r3, r3, #29
    2482:	d407      	bmi.n	2494 <uart_nrfx_irq_is_pending+0x2c>
    2484:	2000      	movs	r0, #0
		(nrf_uart_int_enable_check(uart0_addr,
					   NRF_UART_INT_MASK_RXDRDY) &&
		 uart_nrfx_irq_rx_ready(dev)));
}
    2486:	bd10      	pop	{r4, pc}
		 uart_nrfx_irq_tx_ready_complete(dev))
    2488:	f7ff ffb6 	bl	23f8 <uart_nrfx_irq_tx_ready_complete>
					   NRF_UART_INT_MASK_TXDRDY) &&
    248c:	2800      	cmp	r0, #0
    248e:	d0f3      	beq.n	2478 <uart_nrfx_irq_is_pending+0x10>
		||
    2490:	2001      	movs	r0, #1
    2492:	e7f8      	b.n	2486 <uart_nrfx_irq_is_pending+0x1e>
		 uart_nrfx_irq_rx_ready(dev)));
    2494:	0020      	movs	r0, r4
    2496:	f7ff ffcb 	bl	2430 <uart_nrfx_irq_rx_ready>
					   NRF_UART_INT_MASK_RXDRDY) &&
    249a:	2800      	cmp	r0, #0
    249c:	d0f3      	beq.n	2486 <uart_nrfx_irq_is_pending+0x1e>
		||
    249e:	2001      	movs	r0, #1
    24a0:	e7f1      	b.n	2486 <uart_nrfx_irq_is_pending+0x1e>
    24a2:	46c0      	nop			; (mov r8, r8)
    24a4:	40002000 	.word	0x40002000

000024a8 <uart_nrfx_irq_callback_set>:
static void uart_nrfx_irq_callback_set(const struct device *dev,
				       uart_irq_callback_user_data_t cb,
				       void *cb_data)
{
	(void)dev;
	irq_callback = cb;
    24a8:	4b02      	ldr	r3, [pc, #8]	; (24b4 <uart_nrfx_irq_callback_set+0xc>)
    24aa:	6019      	str	r1, [r3, #0]
	irq_cb_data = cb_data;
    24ac:	4b02      	ldr	r3, [pc, #8]	; (24b8 <uart_nrfx_irq_callback_set+0x10>)
    24ae:	601a      	str	r2, [r3, #0]
}
    24b0:	4770      	bx	lr
    24b2:	46c0      	nop			; (mov r8, r8)
    24b4:	20000264 	.word	0x20000264
    24b8:	20000268 	.word	0x20000268

000024bc <uart_nrfx_isr>:
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_nrfx_isr(const struct device *dev)
{
    24bc:	b510      	push	{r4, lr}
	if (disable_tx_irq &&
    24be:	4b11      	ldr	r3, [pc, #68]	; (2504 <uart_nrfx_isr+0x48>)
    24c0:	781b      	ldrb	r3, [r3, #0]
    24c2:	2b00      	cmp	r3, #0
    24c4:	d003      	beq.n	24ce <uart_nrfx_isr+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    24c6:	4b10      	ldr	r3, [pc, #64]	; (2508 <uart_nrfx_isr+0x4c>)
    24c8:	681b      	ldr	r3, [r3, #0]
    24ca:	2b00      	cmp	r3, #0
    24cc:	d10e      	bne.n	24ec <uart_nrfx_isr+0x30>
    24ce:	4b0f      	ldr	r3, [pc, #60]	; (250c <uart_nrfx_isr+0x50>)
    24d0:	681b      	ldr	r3, [r3, #0]
		disable_tx_irq = false;

		return;
	}

	if (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_ERROR)) {
    24d2:	2b00      	cmp	r3, #0
    24d4:	d002      	beq.n	24dc <uart_nrfx_isr+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    24d6:	4b0d      	ldr	r3, [pc, #52]	; (250c <uart_nrfx_isr+0x50>)
    24d8:	2200      	movs	r2, #0
    24da:	601a      	str	r2, [r3, #0]
		nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_ERROR);
	}

	if (irq_callback) {
    24dc:	4b0c      	ldr	r3, [pc, #48]	; (2510 <uart_nrfx_isr+0x54>)
    24de:	681b      	ldr	r3, [r3, #0]
    24e0:	2b00      	cmp	r3, #0
    24e2:	d002      	beq.n	24ea <uart_nrfx_isr+0x2e>
		irq_callback(dev, irq_cb_data);
    24e4:	4a0b      	ldr	r2, [pc, #44]	; (2514 <uart_nrfx_isr+0x58>)
    24e6:	6811      	ldr	r1, [r2, #0]
    24e8:	4798      	blx	r3
	}
}
    24ea:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
    24ec:	4a0a      	ldr	r2, [pc, #40]	; (2518 <uart_nrfx_isr+0x5c>)
    24ee:	23c2      	movs	r3, #194	; 0xc2
    24f0:	009b      	lsls	r3, r3, #2
    24f2:	2180      	movs	r1, #128	; 0x80
    24f4:	50d1      	str	r1, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    24f6:	4b09      	ldr	r3, [pc, #36]	; (251c <uart_nrfx_isr+0x60>)
    24f8:	2201      	movs	r2, #1
    24fa:	601a      	str	r2, [r3, #0]
		disable_tx_irq = false;
    24fc:	4b01      	ldr	r3, [pc, #4]	; (2504 <uart_nrfx_isr+0x48>)
    24fe:	2200      	movs	r2, #0
    2500:	701a      	strb	r2, [r3, #0]
		return;
    2502:	e7f2      	b.n	24ea <uart_nrfx_isr+0x2e>
    2504:	20000301 	.word	0x20000301
    2508:	4000211c 	.word	0x4000211c
    250c:	40002124 	.word	0x40002124
    2510:	20000264 	.word	0x20000264
    2514:	20000268 	.word	0x20000268
    2518:	40002000 	.word	0x40002000
    251c:	4000200c 	.word	0x4000200c

00002520 <uart_nrfx_poll_out>:
{
    2520:	b570      	push	{r4, r5, r6, lr}
    2522:	000d      	movs	r5, r1
	if (!k_is_in_isr()) {
    2524:	f002 faa3 	bl	4a6e <k_is_in_isr>
    2528:	2800      	cmp	r0, #0
    252a:	d110      	bne.n	254e <uart_nrfx_poll_out+0x2e>
		uint8_t safety_cnt = 100;
    252c:	2464      	movs	r4, #100	; 0x64
	return z_impl_atomic_cas(target, old_value, new_value);
    252e:	2201      	movs	r2, #1
    2530:	2100      	movs	r1, #0
    2532:	4816      	ldr	r0, [pc, #88]	; (258c <uart_nrfx_poll_out+0x6c>)
    2534:	f002 fc30 	bl	4d98 <z_impl_atomic_cas>
		while (atomic_cas((atomic_t *) lock,
    2538:	2800      	cmp	r0, #0
    253a:	d10b      	bne.n	2554 <uart_nrfx_poll_out+0x34>
    253c:	2021      	movs	r0, #33	; 0x21
    253e:	2100      	movs	r1, #0
    2540:	f001 fa80 	bl	3a44 <z_impl_k_sleep>
			if (--safety_cnt == 0) {
    2544:	3c01      	subs	r4, #1
    2546:	b2e4      	uxtb	r4, r4
    2548:	2c00      	cmp	r4, #0
    254a:	d1f0      	bne.n	252e <uart_nrfx_poll_out+0xe>
    254c:	e002      	b.n	2554 <uart_nrfx_poll_out+0x34>
		*lock = 1;
    254e:	4b0f      	ldr	r3, [pc, #60]	; (258c <uart_nrfx_poll_out+0x6c>)
    2550:	2201      	movs	r2, #1
    2552:	601a      	str	r2, [r3, #0]
	event_txdrdy_clear();
    2554:	f7ff fda4 	bl	20a0 <event_txdrdy_clear>
    2558:	4b0d      	ldr	r3, [pc, #52]	; (2590 <uart_nrfx_poll_out+0x70>)
    255a:	2201      	movs	r2, #1
    255c:	601a      	str	r2, [r3, #0]
    p_reg->TXD = txd;
    255e:	4a0d      	ldr	r2, [pc, #52]	; (2594 <uart_nrfx_poll_out+0x74>)
    2560:	4b0d      	ldr	r3, [pc, #52]	; (2598 <uart_nrfx_poll_out+0x78>)
    2562:	50d5      	str	r5, [r2, r3]
	NRFX_WAIT_FOR(event_txdrdy_check(), 1000, 1, res);
    2564:	24fa      	movs	r4, #250	; 0xfa
    2566:	00a4      	lsls	r4, r4, #2
    2568:	f7ff fd88 	bl	207c <event_txdrdy_check>
    256c:	2800      	cmp	r0, #0
    256e:	d105      	bne.n	257c <uart_nrfx_poll_out+0x5c>
    2570:	3001      	adds	r0, #1
    2572:	f002 fa3d 	bl	49f0 <nrfx_busy_wait>
    2576:	3c01      	subs	r4, #1
    2578:	2c00      	cmp	r4, #0
    257a:	d1f5      	bne.n	2568 <uart_nrfx_poll_out+0x48>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    257c:	4b07      	ldr	r3, [pc, #28]	; (259c <uart_nrfx_poll_out+0x7c>)
    257e:	2201      	movs	r2, #1
    2580:	601a      	str	r2, [r3, #0]
	*lock = 0;
    2582:	4b02      	ldr	r3, [pc, #8]	; (258c <uart_nrfx_poll_out+0x6c>)
    2584:	2200      	movs	r2, #0
    2586:	601a      	str	r2, [r3, #0]
}
    2588:	bd70      	pop	{r4, r5, r6, pc}
    258a:	46c0      	nop			; (mov r8, r8)
    258c:	2000026c 	.word	0x2000026c
    2590:	40002008 	.word	0x40002008
    2594:	40002000 	.word	0x40002000
    2598:	0000051c 	.word	0x0000051c
    259c:	4000200c 	.word	0x4000200c

000025a0 <uart_nrfx_init>:
 * @param dev UART device struct
 *
 * @return 0 on success
 */
static int uart_nrfx_init(const struct device *dev)
{
    25a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    p_reg->ENABLE = UART_ENABLE_ENABLE_Disabled;
    25a2:	4a21      	ldr	r2, [pc, #132]	; (2628 <uart_nrfx_init+0x88>)
    25a4:	2400      	movs	r4, #0
    25a6:	23a0      	movs	r3, #160	; 0xa0
    25a8:	00db      	lsls	r3, r3, #3
    25aa:	50d4      	str	r4, [r2, r3]
    p_reg->OUTSET = set_mask;
    25ac:	23a0      	movs	r3, #160	; 0xa0
    25ae:	05db      	lsls	r3, r3, #23
    25b0:	21a1      	movs	r1, #161	; 0xa1
    25b2:	00c9      	lsls	r1, r1, #3
    25b4:	2580      	movs	r5, #128	; 0x80
    25b6:	00ad      	lsls	r5, r5, #2
    25b8:	505d      	str	r5, [r3, r1]
    reg->PIN_CNF[pin_number] = cnf;
    25ba:	3dfe      	subs	r5, #254	; 0xfe
    25bc:	3dff      	subs	r5, #255	; 0xff
    25be:	4e1b      	ldr	r6, [pc, #108]	; (262c <uart_nrfx_init+0x8c>)
    25c0:	519d      	str	r5, [r3, r6]
    25c2:	4e1b      	ldr	r6, [pc, #108]	; (2630 <uart_nrfx_init+0x90>)
    25c4:	519c      	str	r4, [r3, r6]
    p_reg->PSELRXD = pselrxd;
    25c6:	4e1b      	ldr	r6, [pc, #108]	; (2634 <uart_nrfx_init+0x94>)
    25c8:	270b      	movs	r7, #11
    25ca:	5197      	str	r7, [r2, r6]
    p_reg->PSELTXD = pseltxd;
    25cc:	4e1a      	ldr	r6, [pc, #104]	; (2638 <uart_nrfx_init+0x98>)
    25ce:	3f02      	subs	r7, #2
    25d0:	5197      	str	r7, [r2, r6]
    p_reg->OUTSET = set_mask;
    25d2:	2680      	movs	r6, #128	; 0x80
    25d4:	0076      	lsls	r6, r6, #1
    25d6:	505e      	str	r6, [r3, r1]
    reg->PIN_CNF[pin_number] = cnf;
    25d8:	26e4      	movs	r6, #228	; 0xe4
    25da:	00f6      	lsls	r6, r6, #3
    25dc:	519d      	str	r5, [r3, r6]
    25de:	25e5      	movs	r5, #229	; 0xe5
    25e0:	00ed      	lsls	r5, r5, #3
    25e2:	515c      	str	r4, [r3, r5]
    p_reg->PSELRTS = pselrts;
    25e4:	2308      	movs	r3, #8
    25e6:	5053      	str	r3, [r2, r1]
    p_reg->PSELCTS = pselcts;
    25e8:	23a2      	movs	r3, #162	; 0xa2
    25ea:	00db      	lsls	r3, r3, #3
    25ec:	210a      	movs	r1, #10
    25ee:	50d1      	str	r1, [r2, r3]
	}

	nrf_uart_hwfc_pins_set(uart0_addr, RTS_PIN, CTS_PIN);

	/* Set initial configuration */
	err = uart_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    25f0:	6901      	ldr	r1, [r0, #16]
    25f2:	f7ff fe45 	bl	2280 <uart_nrfx_configure>
    25f6:	1e04      	subs	r4, r0, #0
	if (err) {
    25f8:	d001      	beq.n	25fe <uart_nrfx_init+0x5e>
#if HW_FLOW_CONTROL_AVAILABLE
	k_timer_init(&uart0_cb.tx_timeout_timer, tx_timeout, NULL);
#endif
#endif
	return 0;
}
    25fa:	0020      	movs	r0, r4
    25fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
    25fe:	4a0a      	ldr	r2, [pc, #40]	; (2628 <uart_nrfx_init+0x88>)
    2600:	23a0      	movs	r3, #160	; 0xa0
    2602:	00db      	lsls	r3, r3, #3
    2604:	2104      	movs	r1, #4
    2606:	50d1      	str	r1, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2608:	4b0c      	ldr	r3, [pc, #48]	; (263c <uart_nrfx_init+0x9c>)
    260a:	2100      	movs	r1, #0
    260c:	6019      	str	r1, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    260e:	2301      	movs	r3, #1
    2610:	6013      	str	r3, [r2, #0]
	uart_sw_event_txdrdy = 1U;
    2612:	4a0b      	ldr	r2, [pc, #44]	; (2640 <uart_nrfx_init+0xa0>)
    2614:	7013      	strb	r3, [r2, #0]
	IRQ_CONNECT(IRQN,
    2616:	2200      	movs	r2, #0
    2618:	3101      	adds	r1, #1
    261a:	2002      	movs	r0, #2
    261c:	f7fe fee4 	bl	13e8 <z_arm_irq_priority_set>
	irq_enable(IRQN);
    2620:	2002      	movs	r0, #2
    2622:	f7fe fec9 	bl	13b8 <arch_irq_enable>
	return 0;
    2626:	e7e8      	b.n	25fa <uart_nrfx_init+0x5a>
    2628:	40002000 	.word	0x40002000
    262c:	00000724 	.word	0x00000724
    2630:	0000072c 	.word	0x0000072c
    2634:	00000514 	.word	0x00000514
    2638:	0000050c 	.word	0x0000050c
    263c:	40002108 	.word	0x40002108
    2640:	20000302 	.word	0x20000302

00002644 <set_comparator>:
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(int32_t chan, uint32_t cyc)
{
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    2644:	0209      	lsls	r1, r1, #8
    2646:	0a09      	lsrs	r1, r1, #8

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
    2648:	3051      	adds	r0, #81	; 0x51
    264a:	30ff      	adds	r0, #255	; 0xff
    264c:	0080      	lsls	r0, r0, #2
    264e:	4b01      	ldr	r3, [pc, #4]	; (2654 <set_comparator+0x10>)
    2650:	50c1      	str	r1, [r0, r3]
}
    2652:	4770      	bx	lr
    2654:	40011000 	.word	0x40011000

00002658 <get_comparator>:
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
    2658:	3051      	adds	r0, #81	; 0x51
    265a:	30ff      	adds	r0, #255	; 0xff
    265c:	0080      	lsls	r0, r0, #2
    265e:	4b01      	ldr	r3, [pc, #4]	; (2664 <get_comparator+0xc>)
    2660:	58c0      	ldr	r0, [r0, r3]

static uint32_t get_comparator(int32_t chan)
{
	return nrf_rtc_cc_get(RTC, chan);
}
    2662:	4770      	bx	lr
    2664:	40011000 	.word	0x40011000

00002668 <event_clear>:

static void event_clear(int32_t chan)
{
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    2668:	3050      	adds	r0, #80	; 0x50
    266a:	0080      	lsls	r0, r0, #2
    266c:	b280      	uxth	r0, r0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type * p_reg, nrf_rtc_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    266e:	4b03      	ldr	r3, [pc, #12]	; (267c <event_clear+0x14>)
    2670:	469c      	mov	ip, r3
    2672:	4460      	add	r0, ip
    2674:	2300      	movs	r3, #0
    2676:	6003      	str	r3, [r0, #0]
}
    2678:	4770      	bx	lr
    267a:	46c0      	nop			; (mov r8, r8)
    267c:	40011000 	.word	0x40011000

00002680 <event_enable>:

static void event_enable(int32_t chan)
{
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2680:	2380      	movs	r3, #128	; 0x80
    2682:	025b      	lsls	r3, r3, #9
    2684:	4083      	lsls	r3, r0
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    2686:	4902      	ldr	r1, [pc, #8]	; (2690 <event_enable+0x10>)
    2688:	22d1      	movs	r2, #209	; 0xd1
    268a:	0092      	lsls	r2, r2, #2
    268c:	508b      	str	r3, [r1, r2]
}
    268e:	4770      	bx	lr
    2690:	40011000 	.word	0x40011000

00002694 <event_disable>:

static void event_disable(int32_t chan)
{
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2694:	2380      	movs	r3, #128	; 0x80
    2696:	025b      	lsls	r3, r3, #9
    2698:	4083      	lsls	r3, r0
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    269a:	4902      	ldr	r1, [pc, #8]	; (26a4 <event_disable+0x10>)
    269c:	22d2      	movs	r2, #210	; 0xd2
    269e:	0092      	lsls	r2, r2, #2
    26a0:	508b      	str	r3, [r1, r2]
}
    26a2:	4770      	bx	lr
    26a4:	40011000 	.word	0x40011000

000026a8 <counter>:
     return p_reg->COUNTER;
    26a8:	4a01      	ldr	r2, [pc, #4]	; (26b0 <counter+0x8>)
    26aa:	4b02      	ldr	r3, [pc, #8]	; (26b4 <counter+0xc>)
    26ac:	58d0      	ldr	r0, [r2, r3]

static uint32_t counter(void)
{
	return nrf_rtc_counter_get(RTC);
}
    26ae:	4770      	bx	lr
    26b0:	40011000 	.word	0x40011000
    26b4:	00000504 	.word	0x00000504

000026b8 <compare_int_lock>:
	__ASSERT_NO_MSG(chan < CHAN_COUNT);
	return nrf_rtc_event_address_get(RTC, nrf_rtc_compare_event_get(chan));
}

static bool compare_int_lock(int32_t chan)
{
    26b8:	b570      	push	{r4, r5, r6, lr}
    26ba:	0005      	movs	r5, r0
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
    26bc:	2401      	movs	r4, #1
    26be:	4084      	lsls	r4, r0
    26c0:	43e1      	mvns	r1, r4
	return z_impl_atomic_and(target, value);
    26c2:	4809      	ldr	r0, [pc, #36]	; (26e8 <compare_int_lock+0x30>)
    26c4:	f002 fb94 	bl	4df0 <z_impl_atomic_and>

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    26c8:	2380      	movs	r3, #128	; 0x80
    26ca:	025b      	lsls	r3, r3, #9
    26cc:	40ab      	lsls	r3, r5
    p_reg->INTENCLR = mask;
    26ce:	4907      	ldr	r1, [pc, #28]	; (26ec <compare_int_lock+0x34>)
    26d0:	22c2      	movs	r2, #194	; 0xc2
    26d2:	0092      	lsls	r2, r2, #2
    26d4:	508b      	str	r3, [r1, r2]
  __ASM volatile ("dmb 0xF":::"memory");
    26d6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
    26da:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
    26de:	4004      	ands	r4, r0
    26e0:	1e60      	subs	r0, r4, #1
    26e2:	4184      	sbcs	r4, r0
    26e4:	b2e0      	uxtb	r0, r4
}
    26e6:	bd70      	pop	{r4, r5, r6, pc}
    26e8:	20000274 	.word	0x20000274
    26ec:	40011000 	.word	0x40011000

000026f0 <channel_processing_check_and_clear>:
		event_enable(chan);
	}
}

static bool channel_processing_check_and_clear(int32_t chan)
{
    26f0:	b570      	push	{r4, r5, r6, lr}
    26f2:	0004      	movs	r4, r0
	bool result = false;

	uint32_t mcu_critical_state = full_int_lock();
    26f4:	f002 f915 	bl	4922 <full_int_lock>
    26f8:	0005      	movs	r5, r0

	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
    26fa:	2380      	movs	r3, #128	; 0x80
    26fc:	025b      	lsls	r3, r3, #9
    26fe:	40a3      	lsls	r3, r4
    return p_reg->INTENSET & mask;
    2700:	4914      	ldr	r1, [pc, #80]	; (2754 <channel_processing_check_and_clear+0x64>)
    2702:	22c1      	movs	r2, #193	; 0xc1
    2704:	0092      	lsls	r2, r2, #2
    2706:	588a      	ldr	r2, [r1, r2]
    2708:	421a      	tst	r2, r3
    270a:	d105      	bne.n	2718 <channel_processing_check_and_clear+0x28>
	bool result = false;
    270c:	2600      	movs	r6, #0
		if (result) {
			event_clear(chan);
		}
	}

	full_int_unlock(mcu_critical_state);
    270e:	0028      	movs	r0, r5
    2710:	f002 f90b 	bl	492a <full_int_unlock>

	return result;
}
    2714:	0030      	movs	r0, r6
    2716:	bd70      	pop	{r4, r5, r6, pc}
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    2718:	2101      	movs	r1, #1
    271a:	40a1      	lsls	r1, r4
    271c:	43c9      	mvns	r1, r1
    271e:	480e      	ldr	r0, [pc, #56]	; (2758 <channel_processing_check_and_clear+0x68>)
    2720:	f002 fb66 	bl	4df0 <z_impl_atomic_and>
    2724:	2800      	cmp	r0, #0
    2726:	d10b      	bne.n	2740 <channel_processing_check_and_clear+0x50>
			 nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    2728:	0023      	movs	r3, r4
    272a:	3350      	adds	r3, #80	; 0x50
    272c:	009b      	lsls	r3, r3, #2
    272e:	b29b      	uxth	r3, r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2730:	4a08      	ldr	r2, [pc, #32]	; (2754 <channel_processing_check_and_clear+0x64>)
    2732:	4694      	mov	ip, r2
    2734:	4463      	add	r3, ip
    2736:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    2738:	2b00      	cmp	r3, #0
    273a:	d002      	beq.n	2742 <channel_processing_check_and_clear+0x52>
    273c:	2001      	movs	r0, #1
    273e:	e000      	b.n	2742 <channel_processing_check_and_clear+0x52>
    2740:	2001      	movs	r0, #1
    2742:	2301      	movs	r3, #1
    2744:	001e      	movs	r6, r3
    2746:	4006      	ands	r6, r0
		if (result) {
    2748:	4203      	tst	r3, r0
    274a:	d0e0      	beq.n	270e <channel_processing_check_and_clear+0x1e>
			event_clear(chan);
    274c:	0020      	movs	r0, r4
    274e:	f7ff ff8b 	bl	2668 <event_clear>
    2752:	e7dc      	b.n	270e <channel_processing_check_and_clear+0x1e>
    2754:	40011000 	.word	0x40011000
    2758:	20000270 	.word	0x20000270

0000275c <compare_int_unlock>:
{
    275c:	b570      	push	{r4, r5, r6, lr}
    275e:	0004      	movs	r4, r0
	if (key) {
    2760:	2900      	cmp	r1, #0
    2762:	d100      	bne.n	2766 <compare_int_unlock+0xa>
}
    2764:	bd70      	pop	{r4, r5, r6, pc}
		atomic_or(&int_mask, BIT(chan));
    2766:	2501      	movs	r5, #1
    2768:	0029      	movs	r1, r5
    276a:	4081      	lsls	r1, r0
	return z_impl_atomic_or(target, value);
    276c:	480b      	ldr	r0, [pc, #44]	; (279c <compare_int_unlock+0x40>)
    276e:	f002 fb32 	bl	4dd6 <z_impl_atomic_or>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2772:	2380      	movs	r3, #128	; 0x80
    2774:	025b      	lsls	r3, r3, #9
    2776:	40a3      	lsls	r3, r4
    p_reg->INTENSET = mask;
    2778:	4909      	ldr	r1, [pc, #36]	; (27a0 <compare_int_unlock+0x44>)
    277a:	22c1      	movs	r2, #193	; 0xc1
    277c:	0092      	lsls	r2, r2, #2
    277e:	508b      	str	r3, [r1, r2]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
    2780:	4808      	ldr	r0, [pc, #32]	; (27a4 <compare_int_unlock+0x48>)
    2782:	f002 fb1a 	bl	4dba <atomic_get>
    2786:	40e0      	lsrs	r0, r4
    2788:	4205      	tst	r5, r0
    278a:	d0eb      	beq.n	2764 <compare_int_unlock+0x8>
    278c:	4a06      	ldr	r2, [pc, #24]	; (27a8 <compare_int_unlock+0x4c>)
    278e:	2380      	movs	r3, #128	; 0x80
    2790:	005b      	lsls	r3, r3, #1
    2792:	2180      	movs	r1, #128	; 0x80
    2794:	0289      	lsls	r1, r1, #10
    2796:	50d1      	str	r1, [r2, r3]
}
    2798:	e7e4      	b.n	2764 <compare_int_unlock+0x8>
    279a:	46c0      	nop			; (mov r8, r8)
    279c:	20000274 	.word	0x20000274
    27a0:	40011000 	.word	0x40011000
    27a4:	20000270 	.word	0x20000270
    27a8:	e000e100 	.word	0xe000e100

000027ac <sys_clock_timeout_handler>:
{
    27ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    27ae:	46ce      	mov	lr, r9
    27b0:	4647      	mov	r7, r8
    27b2:	b580      	push	{r7, lr}
    27b4:	4681      	mov	r9, r0
    27b6:	0014      	movs	r4, r2
    27b8:	001d      	movs	r5, r3
	uint32_t cc_value = absolute_time_to_cc(expire_time);
    27ba:	0010      	movs	r0, r2
    27bc:	0019      	movs	r1, r3
    27be:	f002 f8ad 	bl	491c <absolute_time_to_cc>
    27c2:	4680      	mov	r8, r0
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
    27c4:	4b1a      	ldr	r3, [pc, #104]	; (2830 <sys_clock_timeout_handler+0x84>)
    27c6:	0020      	movs	r0, r4
    27c8:	0029      	movs	r1, r5
    27ca:	681e      	ldr	r6, [r3, #0]
    27cc:	685f      	ldr	r7, [r3, #4]
    27ce:	1b80      	subs	r0, r0, r6
    27d0:	41b9      	sbcs	r1, r7
	last_count += dticks * CYC_PER_TICK;
    27d2:	601c      	str	r4, [r3, #0]
    27d4:	605d      	str	r5, [r3, #4]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
    27d6:	4b17      	ldr	r3, [pc, #92]	; (2834 <sys_clock_timeout_handler+0x88>)
    27d8:	001a      	movs	r2, r3
    27da:	4442      	add	r2, r8
	if (in_anchor_range(cc_value)) {
    27dc:	23c0      	movs	r3, #192	; 0xc0
    27de:	041b      	lsls	r3, r3, #16
    27e0:	429a      	cmp	r2, r3
    27e2:	d30b      	bcc.n	27fc <sys_clock_timeout_handler+0x50>
	return false;
    27e4:	2400      	movs	r4, #0
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    27e6:	f001 fa71 	bl	3ccc <sys_clock_announce>
	if (cc_value == get_comparator(chan)) {
    27ea:	4648      	mov	r0, r9
    27ec:	f7ff ff34 	bl	2658 <get_comparator>
    27f0:	4540      	cmp	r0, r8
    27f2:	d010      	beq.n	2816 <sys_clock_timeout_handler+0x6a>
}
    27f4:	bc0c      	pop	{r2, r3}
    27f6:	4690      	mov	r8, r2
    27f8:	4699      	mov	r9, r3
    27fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
    27fc:	4b0e      	ldr	r3, [pc, #56]	; (2838 <sys_clock_timeout_handler+0x8c>)
    27fe:	681b      	ldr	r3, [r3, #0]
    2800:	0a1d      	lsrs	r5, r3, #8
    2802:	061c      	lsls	r4, r3, #24
    2804:	4642      	mov	r2, r8
    2806:	2300      	movs	r3, #0
    2808:	1912      	adds	r2, r2, r4
    280a:	416b      	adcs	r3, r5
    280c:	4c0b      	ldr	r4, [pc, #44]	; (283c <sys_clock_timeout_handler+0x90>)
    280e:	6022      	str	r2, [r4, #0]
    2810:	6063      	str	r3, [r4, #4]
		return true;
    2812:	2401      	movs	r4, #1
    2814:	e7e7      	b.n	27e6 <sys_clock_timeout_handler+0x3a>
		if (!anchor_updated) {
    2816:	2c00      	cmp	r4, #0
    2818:	d003      	beq.n	2822 <sys_clock_timeout_handler+0x76>
		event_enable(chan);
    281a:	4648      	mov	r0, r9
    281c:	f7ff ff30 	bl	2680 <event_enable>
}
    2820:	e7e8      	b.n	27f4 <sys_clock_timeout_handler+0x48>
			set_comparator(chan, COUNTER_HALF_SPAN);
    2822:	2180      	movs	r1, #128	; 0x80
    2824:	0409      	lsls	r1, r1, #16
    2826:	4648      	mov	r0, r9
    2828:	f7ff ff0c 	bl	2644 <set_comparator>
    282c:	e7f5      	b.n	281a <sys_clock_timeout_handler+0x6e>
    282e:	46c0      	nop			; (mov r8, r8)
    2830:	20000050 	.word	0x20000050
    2834:	ffe00000 	.word	0xffe00000
    2838:	20000278 	.word	0x20000278
    283c:	20000038 	.word	0x20000038

00002840 <z_nrf_rtc_timer_read>:
{
    2840:	b570      	push	{r4, r5, r6, lr}
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
    2842:	4b0f      	ldr	r3, [pc, #60]	; (2880 <z_nrf_rtc_timer_read+0x40>)
    2844:	681b      	ldr	r3, [r3, #0]
    2846:	0a1d      	lsrs	r5, r3, #8
    2848:	061c      	lsls	r4, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
    284a:	f3bf 8f5f 	dmb	sy
	uint32_t cntr = counter();
    284e:	f7ff ff2b 	bl	26a8 <counter>
    2852:	0003      	movs	r3, r0
	val += cntr;
    2854:	2100      	movs	r1, #0
    2856:	1900      	adds	r0, r0, r4
    2858:	4169      	adcs	r1, r5
	if (cntr < OVERFLOW_RISK_RANGE_END) {
    285a:	2280      	movs	r2, #128	; 0x80
    285c:	0352      	lsls	r2, r2, #13
    285e:	4293      	cmp	r3, r2
    2860:	d20c      	bcs.n	287c <z_nrf_rtc_timer_read+0x3c>
		if (val < anchor) {
    2862:	4b08      	ldr	r3, [pc, #32]	; (2884 <z_nrf_rtc_timer_read+0x44>)
    2864:	681a      	ldr	r2, [r3, #0]
    2866:	685b      	ldr	r3, [r3, #4]
    2868:	428b      	cmp	r3, r1
    286a:	d802      	bhi.n	2872 <z_nrf_rtc_timer_read+0x32>
    286c:	d106      	bne.n	287c <z_nrf_rtc_timer_read+0x3c>
    286e:	4282      	cmp	r2, r0
    2870:	d904      	bls.n	287c <z_nrf_rtc_timer_read+0x3c>
			val += COUNTER_SPAN;
    2872:	2280      	movs	r2, #128	; 0x80
    2874:	0452      	lsls	r2, r2, #17
    2876:	2300      	movs	r3, #0
    2878:	1880      	adds	r0, r0, r2
    287a:	4159      	adcs	r1, r3
}
    287c:	bd70      	pop	{r4, r5, r6, pc}
    287e:	46c0      	nop			; (mov r8, r8)
    2880:	20000278 	.word	0x20000278
    2884:	20000038 	.word	0x20000038

00002888 <compare_set_nolocks>:
{
    2888:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    288a:	0006      	movs	r6, r0
    288c:	0014      	movs	r4, r2
    288e:	001d      	movs	r5, r3
	uint32_t cc_value = absolute_time_to_cc(target_time);
    2890:	0010      	movs	r0, r2
    2892:	0019      	movs	r1, r3
    2894:	f002 f842 	bl	491c <absolute_time_to_cc>
    2898:	0007      	movs	r7, r0
	uint64_t curr_time = z_nrf_rtc_timer_read();
    289a:	f7ff ffd1 	bl	2840 <z_nrf_rtc_timer_read>
    289e:	0002      	movs	r2, r0
    28a0:	000b      	movs	r3, r1
	if (curr_time < target_time) {
    28a2:	428d      	cmp	r5, r1
    28a4:	d91b      	bls.n	28de <compare_set_nolocks+0x56>
		if (target_time - curr_time > COUNTER_SPAN) {
    28a6:	0020      	movs	r0, r4
    28a8:	0029      	movs	r1, r5
    28aa:	1a80      	subs	r0, r0, r2
    28ac:	4199      	sbcs	r1, r3
    28ae:	1e0a      	subs	r2, r1, #0
    28b0:	d12d      	bne.n	290e <compare_set_nolocks+0x86>
    28b2:	d028      	beq.n	2906 <compare_set_nolocks+0x7e>
		if (target_time != cc_data[chan].target_time) {
    28b4:	0132      	lsls	r2, r6, #4
    28b6:	4b17      	ldr	r3, [pc, #92]	; (2914 <compare_set_nolocks+0x8c>)
    28b8:	189b      	adds	r3, r3, r2
    28ba:	689a      	ldr	r2, [r3, #8]
    28bc:	68db      	ldr	r3, [r3, #12]
    28be:	42a2      	cmp	r2, r4
    28c0:	d101      	bne.n	28c6 <compare_set_nolocks+0x3e>
    28c2:	42ab      	cmp	r3, r5
    28c4:	d014      	beq.n	28f0 <compare_set_nolocks+0x68>
			uint32_t cc_set = set_absolute_alarm(chan, cc_value);
    28c6:	0039      	movs	r1, r7
    28c8:	0030      	movs	r0, r6
    28ca:	f002 f834 	bl	4936 <set_absolute_alarm>
			target_time += counter_sub(cc_set, cc_value);
    28ce:	0039      	movs	r1, r7
    28d0:	f002 f820 	bl	4914 <counter_sub>
    28d4:	0002      	movs	r2, r0
    28d6:	2300      	movs	r3, #0
    28d8:	18a4      	adds	r4, r4, r2
    28da:	415d      	adcs	r5, r3
    28dc:	e008      	b.n	28f0 <compare_set_nolocks+0x68>
	if (curr_time < target_time) {
    28de:	428d      	cmp	r5, r1
    28e0:	d101      	bne.n	28e6 <compare_set_nolocks+0x5e>
    28e2:	4284      	cmp	r4, r0
    28e4:	d8df      	bhi.n	28a6 <compare_set_nolocks+0x1e>
		atomic_or(&force_isr_mask, BIT(chan));
    28e6:	2101      	movs	r1, #1
    28e8:	40b1      	lsls	r1, r6
    28ea:	480b      	ldr	r0, [pc, #44]	; (2918 <compare_set_nolocks+0x90>)
    28ec:	f002 fa73 	bl	4dd6 <z_impl_atomic_or>
	cc_data[chan].target_time = target_time;
    28f0:	4a08      	ldr	r2, [pc, #32]	; (2914 <compare_set_nolocks+0x8c>)
    28f2:	0136      	lsls	r6, r6, #4
    28f4:	1993      	adds	r3, r2, r6
    28f6:	609c      	str	r4, [r3, #8]
    28f8:	60dd      	str	r5, [r3, #12]
	cc_data[chan].callback = handler;
    28fa:	9906      	ldr	r1, [sp, #24]
    28fc:	50b1      	str	r1, [r6, r2]
	cc_data[chan].user_context = user_data;
    28fe:	9a07      	ldr	r2, [sp, #28]
    2900:	605a      	str	r2, [r3, #4]
	return ret;
    2902:	2000      	movs	r0, #0
}
    2904:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (target_time - curr_time > COUNTER_SPAN) {
    2906:	2380      	movs	r3, #128	; 0x80
    2908:	045b      	lsls	r3, r3, #17
    290a:	4298      	cmp	r0, r3
    290c:	d9d2      	bls.n	28b4 <compare_set_nolocks+0x2c>
			return -EINVAL;
    290e:	2016      	movs	r0, #22
    2910:	4240      	negs	r0, r0
    2912:	e7f7      	b.n	2904 <compare_set_nolocks+0x7c>
    2914:	20000040 	.word	0x20000040
    2918:	20000270 	.word	0x20000270

0000291c <process_channel>:

static void process_channel(int32_t chan)
{
    291c:	b5f0      	push	{r4, r5, r6, r7, lr}
    291e:	46d6      	mov	lr, sl
    2920:	464f      	mov	r7, r9
    2922:	b580      	push	{r7, lr}
    2924:	b085      	sub	sp, #20
    2926:	0004      	movs	r4, r0
	if (channel_processing_check_and_clear(chan)) {
    2928:	f7ff fee2 	bl	26f0 <channel_processing_check_and_clear>
    292c:	2800      	cmp	r0, #0
    292e:	d104      	bne.n	293a <process_channel+0x1e>

		if (handler) {
			handler(chan, expire_time, user_context);
		}
	}
}
    2930:	b005      	add	sp, #20
    2932:	bc0c      	pop	{r2, r3}
    2934:	4691      	mov	r9, r2
    2936:	469a      	mov	sl, r3
    2938:	bdf0      	pop	{r4, r5, r6, r7, pc}
		curr_time = z_nrf_rtc_timer_read();
    293a:	f7ff ff81 	bl	2840 <z_nrf_rtc_timer_read>
    293e:	9003      	str	r0, [sp, #12]
    2940:	000d      	movs	r5, r1
		mcu_critical_state = full_int_lock();
    2942:	f001 ffee 	bl	4922 <full_int_lock>
    2946:	4682      	mov	sl, r0
		expire_time = cc_data[chan].target_time;
    2948:	0122      	lsls	r2, r4, #4
    294a:	4b14      	ldr	r3, [pc, #80]	; (299c <process_channel+0x80>)
    294c:	189b      	adds	r3, r3, r2
    294e:	689e      	ldr	r6, [r3, #8]
    2950:	68df      	ldr	r7, [r3, #12]
		if (curr_time >= expire_time) {
    2952:	42af      	cmp	r7, r5
    2954:	d90c      	bls.n	2970 <process_channel+0x54>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
    2956:	2500      	movs	r5, #0
		full_int_unlock(mcu_critical_state);
    2958:	4650      	mov	r0, sl
    295a:	f001 ffe6 	bl	492a <full_int_unlock>
		if (handler) {
    295e:	2d00      	cmp	r5, #0
    2960:	d0e6      	beq.n	2930 <process_channel+0x14>
			handler(chan, expire_time, user_context);
    2962:	464b      	mov	r3, r9
    2964:	9300      	str	r3, [sp, #0]
    2966:	0032      	movs	r2, r6
    2968:	003b      	movs	r3, r7
    296a:	0020      	movs	r0, r4
    296c:	47a8      	blx	r5
}
    296e:	e7df      	b.n	2930 <process_channel+0x14>
		if (curr_time >= expire_time) {
    2970:	42af      	cmp	r7, r5
    2972:	d102      	bne.n	297a <process_channel+0x5e>
    2974:	9b03      	ldr	r3, [sp, #12]
    2976:	429e      	cmp	r6, r3
    2978:	d8ed      	bhi.n	2956 <process_channel+0x3a>
			handler = cc_data[chan].callback;
    297a:	4b08      	ldr	r3, [pc, #32]	; (299c <process_channel+0x80>)
    297c:	0122      	lsls	r2, r4, #4
    297e:	58d5      	ldr	r5, [r2, r3]
			user_context = cc_data[chan].user_context;
    2980:	1899      	adds	r1, r3, r2
    2982:	6848      	ldr	r0, [r1, #4]
    2984:	4681      	mov	r9, r0
			cc_data[chan].callback = NULL;
    2986:	2000      	movs	r0, #0
    2988:	50d0      	str	r0, [r2, r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
    298a:	2201      	movs	r2, #1
    298c:	4252      	negs	r2, r2
    298e:	17d3      	asrs	r3, r2, #31
    2990:	608a      	str	r2, [r1, #8]
    2992:	60cb      	str	r3, [r1, #12]
			event_disable(chan);
    2994:	0020      	movs	r0, r4
    2996:	f7ff fe7d 	bl	2694 <event_disable>
    299a:	e7dd      	b.n	2958 <process_channel+0x3c>
    299c:	20000040 	.word	0x20000040

000029a0 <rtc_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc_nrf_isr(const void *arg)
{
    29a0:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
    29a2:	4a0d      	ldr	r2, [pc, #52]	; (29d8 <rtc_nrf_isr+0x38>)
    29a4:	23c1      	movs	r3, #193	; 0xc1
    29a6:	009b      	lsls	r3, r3, #2
    29a8:	58d3      	ldr	r3, [r2, r3]
	ARG_UNUSED(arg);

	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
    29aa:	079b      	lsls	r3, r3, #30
    29ac:	d50a      	bpl.n	29c4 <rtc_nrf_isr+0x24>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    29ae:	4b0b      	ldr	r3, [pc, #44]	; (29dc <rtc_nrf_isr+0x3c>)
    29b0:	681b      	ldr	r3, [r3, #0]
    29b2:	2b00      	cmp	r3, #0
    29b4:	d006      	beq.n	29c4 <rtc_nrf_isr+0x24>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    29b6:	4b09      	ldr	r3, [pc, #36]	; (29dc <rtc_nrf_isr+0x3c>)
    29b8:	2200      	movs	r2, #0
    29ba:	601a      	str	r2, [r3, #0]
	    nrf_rtc_event_check(RTC, NRF_RTC_EVENT_OVERFLOW)) {
		nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_OVERFLOW);
		overflow_cnt++;
    29bc:	4a08      	ldr	r2, [pc, #32]	; (29e0 <rtc_nrf_isr+0x40>)
    29be:	6813      	ldr	r3, [r2, #0]
    29c0:	3301      	adds	r3, #1
    29c2:	6013      	str	r3, [r2, #0]
{
    29c4:	2400      	movs	r4, #0
	}

	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    29c6:	2c00      	cmp	r4, #0
    29c8:	dd00      	ble.n	29cc <rtc_nrf_isr+0x2c>
		process_channel(chan);
	}
}
    29ca:	bd10      	pop	{r4, pc}
		process_channel(chan);
    29cc:	0020      	movs	r0, r4
    29ce:	f7ff ffa5 	bl	291c <process_channel>
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    29d2:	3401      	adds	r4, #1
    29d4:	e7f7      	b.n	29c6 <rtc_nrf_isr+0x26>
    29d6:	46c0      	nop			; (mov r8, r8)
    29d8:	40011000 	.word	0x40011000
    29dc:	40011104 	.word	0x40011104
    29e0:	20000278 	.word	0x20000278

000029e4 <sys_clock_driver_init>:

	atomic_or(&alloc_mask, BIT(chan));
}

int sys_clock_driver_init(const struct device *dev)
{
    29e4:	b570      	push	{r4, r5, r6, lr}
    29e6:	b082      	sub	sp, #8
    p_reg->PRESCALER = val;
    29e8:	4a20      	ldr	r2, [pc, #128]	; (2a6c <sys_clock_driver_init+0x88>)
    29ea:	23a1      	movs	r3, #161	; 0xa1
    29ec:	00db      	lsls	r3, r3, #3
    29ee:	2100      	movs	r1, #0
    29f0:	50d1      	str	r1, [r2, r3]
			CLOCK_CONTROL_NRF_LF_START_AVAILABLE :
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    29f2:	2300      	movs	r3, #0
    29f4:	2b00      	cmp	r3, #0
    29f6:	dd28      	ble.n	2a4a <sys_clock_driver_init+0x66>
    p_reg->INTENSET = mask;
    29f8:	4c1c      	ldr	r4, [pc, #112]	; (2a6c <sys_clock_driver_init+0x88>)
    29fa:	25c1      	movs	r5, #193	; 0xc1
    29fc:	00ad      	lsls	r5, r5, #2
    29fe:	2602      	movs	r6, #2
    2a00:	5166      	str	r6, [r4, r5]
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2a02:	4a1b      	ldr	r2, [pc, #108]	; (2a70 <sys_clock_driver_init+0x8c>)
    2a04:	23c0      	movs	r3, #192	; 0xc0
    2a06:	005b      	lsls	r3, r3, #1
    2a08:	2180      	movs	r1, #128	; 0x80
    2a0a:	0289      	lsls	r1, r1, #10
    2a0c:	50d1      	str	r1, [r2, r3]

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    2a0e:	2200      	movs	r2, #0
    2a10:	2101      	movs	r1, #1
    2a12:	2011      	movs	r0, #17
    2a14:	f7fe fce8 	bl	13e8 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    2a18:	2011      	movs	r0, #17
    2a1a:	f7fe fccd 	bl	13b8 <arch_irq_enable>
    2a1e:	5166      	str	r6, [r4, r5]
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    2a20:	2301      	movs	r3, #1
    2a22:	4a14      	ldr	r2, [pc, #80]	; (2a74 <sys_clock_driver_init+0x90>)
    2a24:	6013      	str	r3, [r2, #0]
    2a26:	6023      	str	r3, [r4, #0]

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    2a28:	4a13      	ldr	r2, [pc, #76]	; (2a78 <sys_clock_driver_init+0x94>)
    2a2a:	6013      	str	r3, [r2, #0]

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
				(COUNTER_HALF_SPAN - 1) :
				(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
    2a2c:	2300      	movs	r3, #0
    2a2e:	9301      	str	r3, [sp, #4]
    2a30:	4b12      	ldr	r3, [pc, #72]	; (2a7c <sys_clock_driver_init+0x98>)
    2a32:	9300      	str	r3, [sp, #0]
    2a34:	4a12      	ldr	r2, [pc, #72]	; (2a80 <sys_clock_driver_init+0x9c>)
    2a36:	2300      	movs	r3, #0
    2a38:	2000      	movs	r0, #0
    2a3a:	f001 ffb9 	bl	49b0 <compare_set>

	z_nrf_clock_control_lf_on(mode);
    2a3e:	2002      	movs	r0, #2
    2a40:	f7ff f840 	bl	1ac4 <z_nrf_clock_control_lf_on>

	return 0;
}
    2a44:	2000      	movs	r0, #0
    2a46:	b002      	add	sp, #8
    2a48:	bd70      	pop	{r4, r5, r6, pc}
		cc_data[chan].target_time = TARGET_TIME_INVALID;
    2a4a:	0119      	lsls	r1, r3, #4
    2a4c:	4a0d      	ldr	r2, [pc, #52]	; (2a84 <sys_clock_driver_init+0xa0>)
    2a4e:	1852      	adds	r2, r2, r1
    2a50:	2001      	movs	r0, #1
    2a52:	4240      	negs	r0, r0
    2a54:	17c1      	asrs	r1, r0, #31
    2a56:	6090      	str	r0, [r2, #8]
    2a58:	60d1      	str	r1, [r2, #12]
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2a5a:	2280      	movs	r2, #128	; 0x80
    2a5c:	0252      	lsls	r2, r2, #9
    2a5e:	409a      	lsls	r2, r3
    p_reg->INTENSET = mask;
    2a60:	4802      	ldr	r0, [pc, #8]	; (2a6c <sys_clock_driver_init+0x88>)
    2a62:	21c1      	movs	r1, #193	; 0xc1
    2a64:	0089      	lsls	r1, r1, #2
    2a66:	5042      	str	r2, [r0, r1]
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    2a68:	3301      	adds	r3, #1
    2a6a:	e7c3      	b.n	29f4 <sys_clock_driver_init+0x10>
    2a6c:	40011000 	.word	0x40011000
    2a70:	e000e100 	.word	0xe000e100
    2a74:	40011008 	.word	0x40011008
    2a78:	20000274 	.word	0x20000274
    2a7c:	000027ad 	.word	0x000027ad
    2a80:	007fffff 	.word	0x007fffff
    2a84:	20000040 	.word	0x20000040

00002a88 <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
    2a88:	b510      	push	{r4, lr}
    2a8a:	b082      	sub	sp, #8
    2a8c:	0004      	movs	r4, r0

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    2a8e:	1c43      	adds	r3, r0, #1
    2a90:	d007      	beq.n	2aa2 <sys_clock_set_timeout+0x1a>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    2a92:	3c01      	subs	r4, #1
    2a94:	2c00      	cmp	r4, #0
    2a96:	dd06      	ble.n	2aa6 <sys_clock_set_timeout+0x1e>
    2a98:	4b12      	ldr	r3, [pc, #72]	; (2ae4 <sys_clock_set_timeout+0x5c>)
    2a9a:	429c      	cmp	r4, r3
    2a9c:	dd04      	ble.n	2aa8 <sys_clock_set_timeout+0x20>
    2a9e:	4c12      	ldr	r4, [pc, #72]	; (2ae8 <sys_clock_set_timeout+0x60>)
    2aa0:	e002      	b.n	2aa8 <sys_clock_set_timeout+0x20>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    2aa2:	4c11      	ldr	r4, [pc, #68]	; (2ae8 <sys_clock_set_timeout+0x60>)
    2aa4:	e7f5      	b.n	2a92 <sys_clock_set_timeout+0xa>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    2aa6:	2400      	movs	r4, #0

	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
    2aa8:	f7ff feca 	bl	2840 <z_nrf_rtc_timer_read>
    2aac:	4b0f      	ldr	r3, [pc, #60]	; (2aec <sys_clock_set_timeout+0x64>)
    2aae:	681a      	ldr	r2, [r3, #0]
    2ab0:	685b      	ldr	r3, [r3, #4]
    2ab2:	1a80      	subs	r0, r0, r2
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    2ab4:	2180      	movs	r1, #128	; 0x80
    2ab6:	0409      	lsls	r1, r1, #16
    2ab8:	4288      	cmp	r0, r1
    2aba:	d300      	bcc.n	2abe <sys_clock_set_timeout+0x36>
		ticks = 0;
    2abc:	2400      	movs	r4, #0
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    2abe:	1824      	adds	r4, r4, r0
    2ac0:	3401      	adds	r4, #1
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;

	/* Due to elapsed time the calculation above might produce a
	 * duration that laps the counter.  Don't let it.
	 */
	if (cyc > MAX_CYCLES) {
    2ac2:	2180      	movs	r1, #128	; 0x80
    2ac4:	0409      	lsls	r1, r1, #16
    2ac6:	428c      	cmp	r4, r1
    2ac8:	d300      	bcc.n	2acc <sys_clock_set_timeout+0x44>
		cyc = MAX_CYCLES;
    2aca:	4c07      	ldr	r4, [pc, #28]	; (2ae8 <sys_clock_set_timeout+0x60>)
	}

	uint64_t target_time = cyc + last_count;
    2acc:	0020      	movs	r0, r4
    2ace:	2100      	movs	r1, #0
    2ad0:	1812      	adds	r2, r2, r0
    2ad2:	414b      	adcs	r3, r1

	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
    2ad4:	9101      	str	r1, [sp, #4]
    2ad6:	4906      	ldr	r1, [pc, #24]	; (2af0 <sys_clock_set_timeout+0x68>)
    2ad8:	9100      	str	r1, [sp, #0]
    2ada:	2000      	movs	r0, #0
    2adc:	f001 ff68 	bl	49b0 <compare_set>
}
    2ae0:	b002      	add	sp, #8
    2ae2:	bd10      	pop	{r4, pc}
    2ae4:	007ffffe 	.word	0x007ffffe
    2ae8:	007fffff 	.word	0x007fffff
    2aec:	20000050 	.word	0x20000050
    2af0:	000027ad 	.word	0x000027ad

00002af4 <sys_clock_elapsed>:

uint32_t sys_clock_elapsed(void)
{
    2af4:	b510      	push	{r4, lr}
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
    2af6:	f7ff fea3 	bl	2840 <z_nrf_rtc_timer_read>
    2afa:	4b03      	ldr	r3, [pc, #12]	; (2b08 <sys_clock_elapsed+0x14>)
    2afc:	681a      	ldr	r2, [r3, #0]
    2afe:	685b      	ldr	r3, [r3, #4]
    2b00:	1a80      	subs	r0, r0, r2
    2b02:	4199      	sbcs	r1, r3
}
    2b04:	bd10      	pop	{r4, pc}
    2b06:	46c0      	nop			; (mov r8, r8)
    2b08:	20000050 	.word	0x20000050

00002b0c <nrf51_errata_26>:
        return false;
    #else
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    2b0c:	4b0b      	ldr	r3, [pc, #44]	; (2b3c <nrf51_errata_26+0x30>)
    2b0e:	681b      	ldr	r3, [r3, #0]
    2b10:	22ff      	movs	r2, #255	; 0xff
    2b12:	401a      	ands	r2, r3
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    2b14:	4b0a      	ldr	r3, [pc, #40]	; (2b40 <nrf51_errata_26+0x34>)
    2b16:	6819      	ldr	r1, [r3, #0]
    2b18:	0909      	lsrs	r1, r1, #4
    2b1a:	230f      	movs	r3, #15
    2b1c:	400b      	ands	r3, r1
        #endif
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            if (var1 == 0x01)
    2b1e:	2a01      	cmp	r2, #1
    2b20:	d001      	beq.n	2b26 <nrf51_errata_26+0x1a>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    2b22:	2000      	movs	r0, #0
    #endif
}
    2b24:	4770      	bx	lr
                switch(var2)
    2b26:	2b03      	cmp	r3, #3
    2b28:	d805      	bhi.n	2b36 <nrf51_errata_26+0x2a>
    2b2a:	009b      	lsls	r3, r3, #2
    2b2c:	4a05      	ldr	r2, [pc, #20]	; (2b44 <nrf51_errata_26+0x38>)
    2b2e:	58d3      	ldr	r3, [r2, r3]
    2b30:	469f      	mov	pc, r3
            if (var1 == 0x01)
    2b32:	2001      	movs	r0, #1
    2b34:	e7f6      	b.n	2b24 <nrf51_errata_26+0x18>
                        return false;
    2b36:	2000      	movs	r0, #0
    2b38:	e7f4      	b.n	2b24 <nrf51_errata_26+0x18>
    2b3a:	46c0      	nop			; (mov r8, r8)
    2b3c:	f0000fe0 	.word	0xf0000fe0
    2b40:	f0000fe8 	.word	0xf0000fe8
    2b44:	0000574c 	.word	0x0000574c

00002b48 <nrf51_errata_59>:
        return false;
    #else
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    2b48:	4b0b      	ldr	r3, [pc, #44]	; (2b78 <nrf51_errata_59+0x30>)
    2b4a:	681a      	ldr	r2, [r3, #0]
    2b4c:	23ff      	movs	r3, #255	; 0xff
    2b4e:	4013      	ands	r3, r2
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    2b50:	4a0a      	ldr	r2, [pc, #40]	; (2b7c <nrf51_errata_59+0x34>)
    2b52:	6812      	ldr	r2, [r2, #0]
    2b54:	0912      	lsrs	r2, r2, #4
    2b56:	210f      	movs	r1, #15
    2b58:	400a      	ands	r2, r1
        #endif
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            if (var1 == 0x01)
    2b5a:	2b01      	cmp	r3, #1
    2b5c:	d001      	beq.n	2b62 <nrf51_errata_59+0x1a>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    2b5e:	2000      	movs	r0, #0
    #endif
}
    2b60:	4770      	bx	lr
                switch(var2)
    2b62:	2a02      	cmp	r2, #2
    2b64:	d005      	beq.n	2b72 <nrf51_errata_59+0x2a>
    2b66:	2a04      	cmp	r2, #4
    2b68:	d001      	beq.n	2b6e <nrf51_errata_59+0x26>
    2b6a:	2000      	movs	r0, #0
    2b6c:	e7f8      	b.n	2b60 <nrf51_errata_59+0x18>
                        return true;
    2b6e:	2001      	movs	r0, #1
    2b70:	e7f6      	b.n	2b60 <nrf51_errata_59+0x18>
                        return true;
    2b72:	2001      	movs	r0, #1
    2b74:	e7f4      	b.n	2b60 <nrf51_errata_59+0x18>
    2b76:	46c0      	nop			; (mov r8, r8)
    2b78:	f0000fe0 	.word	0xf0000fe0
    2b7c:	f0000fe8 	.word	0xf0000fe8

00002b80 <nrf51_errata_76>:
        return false;
    #else
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    2b80:	4b0b      	ldr	r3, [pc, #44]	; (2bb0 <nrf51_errata_76+0x30>)
    2b82:	681b      	ldr	r3, [r3, #0]
    2b84:	22ff      	movs	r2, #255	; 0xff
    2b86:	401a      	ands	r2, r3
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    2b88:	4b0a      	ldr	r3, [pc, #40]	; (2bb4 <nrf51_errata_76+0x34>)
    2b8a:	6819      	ldr	r1, [r3, #0]
    2b8c:	0909      	lsrs	r1, r1, #4
    2b8e:	230f      	movs	r3, #15
    2b90:	400b      	ands	r3, r1
        #endif
        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
            if (var1 == 0x01)
    2b92:	2a01      	cmp	r2, #1
    2b94:	d001      	beq.n	2b9a <nrf51_errata_76+0x1a>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    2b96:	2000      	movs	r0, #0
    #endif
}
    2b98:	4770      	bx	lr
                switch(var2)
    2b9a:	2b0c      	cmp	r3, #12
    2b9c:	d805      	bhi.n	2baa <nrf51_errata_76+0x2a>
    2b9e:	009b      	lsls	r3, r3, #2
    2ba0:	4a05      	ldr	r2, [pc, #20]	; (2bb8 <nrf51_errata_76+0x38>)
    2ba2:	58d3      	ldr	r3, [r2, r3]
    2ba4:	469f      	mov	pc, r3
            if (var1 == 0x01)
    2ba6:	2000      	movs	r0, #0
    2ba8:	e7f6      	b.n	2b98 <nrf51_errata_76+0x18>
                        return true;
    2baa:	2001      	movs	r0, #1
    2bac:	e7f4      	b.n	2b98 <nrf51_errata_76+0x18>
    2bae:	46c0      	nop			; (mov r8, r8)
    2bb0:	f0000fe0 	.word	0xf0000fe0
    2bb4:	f0000fe8 	.word	0xf0000fe8
    2bb8:	0000575c 	.word	0x0000575c

00002bbc <SystemCoreClockUpdate>:
    uint32_t SystemCoreClock __attribute__((used)) = __SYSTEM_CLOCK;
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
    2bbc:	4b01      	ldr	r3, [pc, #4]	; (2bc4 <SystemCoreClockUpdate+0x8>)
    2bbe:	4a02      	ldr	r2, [pc, #8]	; (2bc8 <SystemCoreClockUpdate+0xc>)
    2bc0:	601a      	str	r2, [r3, #0]
}
    2bc2:	4770      	bx	lr
    2bc4:	20000018 	.word	0x20000018
    2bc8:	00f42400 	.word	0x00f42400

00002bcc <SystemInit>:

void SystemInit(void)
{
    2bcc:	b510      	push	{r4, lr}
    /* Prepare the peripherals for use as indicated by the PAN 26 "System: Manual setup is required
       to enable the use of peripherals" found at Product Anomaly document for your device found at
       https://infocenter.nordicsemi.com/index.jsp The side effect of executing these instructions in the devices
       that do not need it is that the new peripherals in the second generation devices (LPCOMP for
       example) will not be available. */
    if (nrf51_errata_26())
    2bce:	f7ff ff9d 	bl	2b0c <nrf51_errata_26>
    2bd2:	2800      	cmp	r0, #0
    2bd4:	d006      	beq.n	2be4 <SystemInit+0x18>
    {
        *(uint32_t volatile *)0x40000504 = 0xC007FFDF;
    2bd6:	4b13      	ldr	r3, [pc, #76]	; (2c24 <SystemInit+0x58>)
    2bd8:	4a13      	ldr	r2, [pc, #76]	; (2c28 <SystemInit+0x5c>)
    2bda:	601a      	str	r2, [r3, #0]
        *(uint32_t volatile *)0x40006C18 = 0x00008000;
    2bdc:	4b13      	ldr	r3, [pc, #76]	; (2c2c <SystemInit+0x60>)
    2bde:	2280      	movs	r2, #128	; 0x80
    2be0:	0212      	lsls	r2, r2, #8
    2be2:	601a      	str	r2, [r3, #0]
    }

    /* Disable PROTENSET registers under debug, as indicated by PAN 59 "MPU: Reset value of DISABLEINDEBUG
       register is incorrect" found at Product Anomaly document for your device found at
       https://infocenter.nordicsemi.com/index.jsp There is no side effect of using these instruction if not needed. */
    if (nrf51_errata_59())
    2be4:	f7ff ffb0 	bl	2b48 <nrf51_errata_59>
    2be8:	2800      	cmp	r0, #0
    2bea:	d005      	beq.n	2bf8 <SystemInit+0x2c>
    {
        NRF_MPU->DISABLEINDEBUG = MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled << MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos;
    2bec:	2280      	movs	r2, #128	; 0x80
    2bee:	05d2      	lsls	r2, r2, #23
    2bf0:	23c1      	movs	r3, #193	; 0xc1
    2bf2:	00db      	lsls	r3, r3, #3
    2bf4:	2101      	movs	r1, #1
    2bf6:	50d1      	str	r1, [r2, r3]
    }

    /* Execute the following code to eliminate excessive current in sleep mode with RAM retention in nRF51802 devices,
       as indicated by PAN 76 "System: Excessive current in sleep mode with retention" found at Product Anomaly document
       for your device found at https://infocenter.nordicsemi.com/index.jsp */
    if (nrf51_errata_76()){
    2bf8:	f7ff ffc2 	bl	2b80 <nrf51_errata_76>
    2bfc:	2800      	cmp	r0, #0
    2bfe:	d00d      	beq.n	2c1c <SystemInit+0x50>
        if (*(uint32_t volatile *)0x4006EC00 != 1){
    2c00:	4b0b      	ldr	r3, [pc, #44]	; (2c30 <SystemInit+0x64>)
    2c02:	681b      	ldr	r3, [r3, #0]
    2c04:	2b01      	cmp	r3, #1
    2c06:	d006      	beq.n	2c16 <SystemInit+0x4a>
            *(uint32_t volatile *)0x4006EC00 = 0x9375;
    2c08:	4b09      	ldr	r3, [pc, #36]	; (2c30 <SystemInit+0x64>)
    2c0a:	4a0a      	ldr	r2, [pc, #40]	; (2c34 <SystemInit+0x68>)
    2c0c:	601a      	str	r2, [r3, #0]
            while (*(uint32_t volatile *)0x4006EC00 != 1){
    2c0e:	4b08      	ldr	r3, [pc, #32]	; (2c30 <SystemInit+0x64>)
    2c10:	681b      	ldr	r3, [r3, #0]
    2c12:	2b01      	cmp	r3, #1
    2c14:	d1fb      	bne.n	2c0e <SystemInit+0x42>
            }
        }
        *(uint32_t volatile *)0x4006EC14 = 0xC0;
    2c16:	4b08      	ldr	r3, [pc, #32]	; (2c38 <SystemInit+0x6c>)
    2c18:	22c0      	movs	r2, #192	; 0xc0
    2c1a:	601a      	str	r2, [r3, #0]
    }

    SystemCoreClockUpdate();
    2c1c:	f7ff ffce 	bl	2bbc <SystemCoreClockUpdate>
}
    2c20:	bd10      	pop	{r4, pc}
    2c22:	46c0      	nop			; (mov r8, r8)
    2c24:	40000504 	.word	0x40000504
    2c28:	c007ffdf 	.word	0xc007ffdf
    2c2c:	40006c18 	.word	0x40006c18
    2c30:	4006ec00 	.word	0x4006ec00
    2c34:	00009375 	.word	0x00009375
    2c38:	4006ec14 	.word	0x4006ec14

00002c3c <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    2c3c:	4b05      	ldr	r3, [pc, #20]	; (2c54 <nrfx_clock_init+0x18>)
    2c3e:	791b      	ldrb	r3, [r3, #4]
    2c40:	2b00      	cmp	r3, #0
    2c42:	d105      	bne.n	2c50 <nrfx_clock_init+0x14>
    else
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
    2c44:	4b03      	ldr	r3, [pc, #12]	; (2c54 <nrfx_clock_init+0x18>)
    2c46:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    2c48:	2201      	movs	r2, #1
    2c4a:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    2c4c:	4802      	ldr	r0, [pc, #8]	; (2c58 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    2c4e:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    2c50:	4802      	ldr	r0, [pc, #8]	; (2c5c <nrfx_clock_init+0x20>)
    return err_code;
    2c52:	e7fc      	b.n	2c4e <nrfx_clock_init+0x12>
    2c54:	2000027c 	.word	0x2000027c
    2c58:	0bad0000 	.word	0x0bad0000
    2c5c:	0bad000c 	.word	0x0bad000c

00002c60 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    2c60:	2800      	cmp	r0, #0
    2c62:	d002      	beq.n	2c6a <nrfx_clock_start+0xa>
    2c64:	2801      	cmp	r0, #1
    2c66:	d025      	beq.n	2cb4 <nrfx_clock_start+0x54>
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
    2c68:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    2c6a:	2180      	movs	r1, #128	; 0x80
    2c6c:	05c9      	lsls	r1, r1, #23
    2c6e:	2283      	movs	r2, #131	; 0x83
    2c70:	00d2      	lsls	r2, r2, #3
    2c72:	588b      	ldr	r3, [r1, r2]
    2c74:	2003      	movs	r0, #3
    2c76:	4003      	ands	r3, r0
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    2c78:	588a      	ldr	r2, [r1, r2]
    2c7a:	03d2      	lsls	r2, r2, #15
    2c7c:	d412      	bmi.n	2ca4 <nrfx_clock_start+0x44>
    p_reg->LFCLKSRC = (uint32_t)(source);
    2c7e:	2280      	movs	r2, #128	; 0x80
    2c80:	05d2      	lsls	r2, r2, #23
    2c82:	23a3      	movs	r3, #163	; 0xa3
    2c84:	00db      	lsls	r3, r3, #3
    2c86:	2100      	movs	r1, #0
    2c88:	50d1      	str	r1, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2c8a:	4b10      	ldr	r3, [pc, #64]	; (2ccc <nrfx_clock_start+0x6c>)
    2c8c:	2200      	movs	r2, #0
    2c8e:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
    2c90:	2280      	movs	r2, #128	; 0x80
    2c92:	05d2      	lsls	r2, r2, #23
    2c94:	23c1      	movs	r3, #193	; 0xc1
    2c96:	009b      	lsls	r3, r3, #2
    2c98:	2102      	movs	r1, #2
    2c9a:	50d1      	str	r1, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2c9c:	4b0c      	ldr	r3, [pc, #48]	; (2cd0 <nrfx_clock_start+0x70>)
    2c9e:	2201      	movs	r2, #1
    2ca0:	601a      	str	r2, [r3, #0]
}
    2ca2:	e7e1      	b.n	2c68 <nrfx_clock_start+0x8>
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    2ca4:	2b01      	cmp	r3, #1
    2ca6:	d1ea      	bne.n	2c7e <nrfx_clock_start+0x1e>
    p_reg->LFCLKSRC = (uint32_t)(source);
    2ca8:	000a      	movs	r2, r1
    2caa:	23a3      	movs	r3, #163	; 0xa3
    2cac:	00db      	lsls	r3, r3, #3
    2cae:	2101      	movs	r1, #1
    2cb0:	50d1      	str	r1, [r2, r3]
}
    2cb2:	e7ea      	b.n	2c8a <nrfx_clock_start+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2cb4:	4b07      	ldr	r3, [pc, #28]	; (2cd4 <nrfx_clock_start+0x74>)
    2cb6:	2200      	movs	r2, #0
    2cb8:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
    2cba:	3b01      	subs	r3, #1
    2cbc:	3bff      	subs	r3, #255	; 0xff
    2cbe:	3201      	adds	r2, #1
    2cc0:	21c1      	movs	r1, #193	; 0xc1
    2cc2:	0089      	lsls	r1, r1, #2
    2cc4:	505a      	str	r2, [r3, r1]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2cc6:	601a      	str	r2, [r3, #0]
}
    2cc8:	e7ce      	b.n	2c68 <nrfx_clock_start+0x8>
    2cca:	46c0      	nop			; (mov r8, r8)
    2ccc:	40000104 	.word	0x40000104
    2cd0:	40000008 	.word	0x40000008
    2cd4:	40000100 	.word	0x40000100

00002cd8 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    2cd8:	b570      	push	{r4, r5, r6, lr}
    2cda:	1e04      	subs	r4, r0, #0
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    2cdc:	d002      	beq.n	2ce4 <nrfx_clock_stop+0xc>
    2cde:	2801      	cmp	r0, #1
    2ce0:	d010      	beq.n	2d04 <nrfx_clock_stop+0x2c>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    2ce2:	bd70      	pop	{r4, r5, r6, pc}
    p_reg->INTENCLR = mask;
    2ce4:	2280      	movs	r2, #128	; 0x80
    2ce6:	05d2      	lsls	r2, r2, #23
    2ce8:	23c2      	movs	r3, #194	; 0xc2
    2cea:	009b      	lsls	r3, r3, #2
    2cec:	2102      	movs	r1, #2
    2cee:	50d1      	str	r1, [r2, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2cf0:	4b32      	ldr	r3, [pc, #200]	; (2dbc <nrfx_clock_stop+0xe4>)
    2cf2:	2200      	movs	r2, #0
    2cf4:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2cf6:	4b32      	ldr	r3, [pc, #200]	; (2dc0 <nrfx_clock_stop+0xe8>)
    2cf8:	3201      	adds	r2, #1
    2cfa:	601a      	str	r2, [r3, #0]
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    2cfc:	2c01      	cmp	r4, #1
    2cfe:	d00d      	beq.n	2d1c <nrfx_clock_stop+0x44>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    2d00:	4d30      	ldr	r5, [pc, #192]	; (2dc4 <nrfx_clock_stop+0xec>)
    2d02:	e048      	b.n	2d96 <nrfx_clock_stop+0xbe>
    p_reg->INTENCLR = mask;
    2d04:	2301      	movs	r3, #1
    2d06:	2180      	movs	r1, #128	; 0x80
    2d08:	05c9      	lsls	r1, r1, #23
    2d0a:	22c2      	movs	r2, #194	; 0xc2
    2d0c:	0092      	lsls	r2, r2, #2
    2d0e:	508b      	str	r3, [r1, r2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2d10:	4a2d      	ldr	r2, [pc, #180]	; (2dc8 <nrfx_clock_stop+0xf0>)
    2d12:	2100      	movs	r1, #0
    2d14:	6011      	str	r1, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2d16:	4a2d      	ldr	r2, [pc, #180]	; (2dcc <nrfx_clock_stop+0xf4>)
    2d18:	6013      	str	r3, [r2, #0]
}
    2d1a:	e7ef      	b.n	2cfc <nrfx_clock_stop+0x24>
        nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    2d1c:	0025      	movs	r5, r4
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    2d1e:	4e29      	ldr	r6, [pc, #164]	; (2dc4 <nrfx_clock_stop+0xec>)
    2d20:	e014      	b.n	2d4c <nrfx_clock_stop+0x74>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    2d22:	2280      	movs	r2, #128	; 0x80
    2d24:	05d2      	lsls	r2, r2, #23
    2d26:	2383      	movs	r3, #131	; 0x83
    2d28:	00db      	lsls	r3, r3, #3
    2d2a:	58d5      	ldr	r5, [r2, r3]
    2d2c:	2103      	movs	r1, #3
    2d2e:	400d      	ands	r5, r1
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    2d30:	58d3      	ldr	r3, [r2, r3]
    2d32:	03db      	lsls	r3, r3, #15
    2d34:	d41b      	bmi.n	2d6e <nrfx_clock_stop+0x96>
    return false;
    2d36:	2300      	movs	r3, #0
    2d38:	2b00      	cmp	r3, #0
    2d3a:	d0d2      	beq.n	2ce2 <nrfx_clock_stop+0xa>
    2d3c:	2d01      	cmp	r5, #1
    2d3e:	d1d0      	bne.n	2ce2 <nrfx_clock_stop+0xa>
    2d40:	2001      	movs	r0, #1
    2d42:	f001 fe55 	bl	49f0 <nrfx_busy_wait>
    2d46:	3e01      	subs	r6, #1
    2d48:	2e00      	cmp	r6, #0
    2d4a:	d0ca      	beq.n	2ce2 <nrfx_clock_stop+0xa>
    switch (domain)
    2d4c:	2c00      	cmp	r4, #0
    2d4e:	d0e8      	beq.n	2d22 <nrfx_clock_stop+0x4a>
    2d50:	2c01      	cmp	r4, #1
    2d52:	d001      	beq.n	2d58 <nrfx_clock_stop+0x80>
    2d54:	2300      	movs	r3, #0
    2d56:	e7ef      	b.n	2d38 <nrfx_clock_stop+0x60>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    2d58:	2280      	movs	r2, #128	; 0x80
    2d5a:	05d2      	lsls	r2, r2, #23
    2d5c:	4b1c      	ldr	r3, [pc, #112]	; (2dd0 <nrfx_clock_stop+0xf8>)
    2d5e:	58d5      	ldr	r5, [r2, r3]
    2d60:	2101      	movs	r1, #1
    2d62:	400d      	ands	r5, r1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    2d64:	58d3      	ldr	r3, [r2, r3]
    2d66:	03db      	lsls	r3, r3, #15
    2d68:	d403      	bmi.n	2d72 <nrfx_clock_stop+0x9a>
    return false;
    2d6a:	2300      	movs	r3, #0
    2d6c:	e7e4      	b.n	2d38 <nrfx_clock_stop+0x60>
                return true;
    2d6e:	2301      	movs	r3, #1
    2d70:	e7e2      	b.n	2d38 <nrfx_clock_stop+0x60>
                return true;
    2d72:	2301      	movs	r3, #1
    2d74:	e7e0      	b.n	2d38 <nrfx_clock_stop+0x60>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    2d76:	2280      	movs	r2, #128	; 0x80
    2d78:	05d2      	lsls	r2, r2, #23
    2d7a:	2383      	movs	r3, #131	; 0x83
    2d7c:	00db      	lsls	r3, r3, #3
    2d7e:	58d3      	ldr	r3, [r2, r3]
    2d80:	03db      	lsls	r3, r3, #15
    2d82:	d416      	bmi.n	2db2 <nrfx_clock_stop+0xda>
    return false;
    2d84:	2300      	movs	r3, #0
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    2d86:	2b00      	cmp	r3, #0
    2d88:	d0ab      	beq.n	2ce2 <nrfx_clock_stop+0xa>
    2d8a:	2001      	movs	r0, #1
    2d8c:	f001 fe30 	bl	49f0 <nrfx_busy_wait>
    2d90:	3d01      	subs	r5, #1
    2d92:	2d00      	cmp	r5, #0
    2d94:	d0a5      	beq.n	2ce2 <nrfx_clock_stop+0xa>
    switch (domain)
    2d96:	2c00      	cmp	r4, #0
    2d98:	d0ed      	beq.n	2d76 <nrfx_clock_stop+0x9e>
    2d9a:	2c01      	cmp	r4, #1
    2d9c:	d001      	beq.n	2da2 <nrfx_clock_stop+0xca>
    2d9e:	2300      	movs	r3, #0
    2da0:	e7f1      	b.n	2d86 <nrfx_clock_stop+0xae>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    2da2:	2280      	movs	r2, #128	; 0x80
    2da4:	05d2      	lsls	r2, r2, #23
    2da6:	4b0a      	ldr	r3, [pc, #40]	; (2dd0 <nrfx_clock_stop+0xf8>)
    2da8:	58d3      	ldr	r3, [r2, r3]
    2daa:	03db      	lsls	r3, r3, #15
    2dac:	d403      	bmi.n	2db6 <nrfx_clock_stop+0xde>
    return false;
    2dae:	2300      	movs	r3, #0
    2db0:	e7e9      	b.n	2d86 <nrfx_clock_stop+0xae>
                return true;
    2db2:	2301      	movs	r3, #1
    2db4:	e7e7      	b.n	2d86 <nrfx_clock_stop+0xae>
                return true;
    2db6:	2301      	movs	r3, #1
    2db8:	e7e5      	b.n	2d86 <nrfx_clock_stop+0xae>
    2dba:	46c0      	nop			; (mov r8, r8)
    2dbc:	40000104 	.word	0x40000104
    2dc0:	4000000c 	.word	0x4000000c
    2dc4:	00002710 	.word	0x00002710
    2dc8:	40000100 	.word	0x40000100
    2dcc:	40000004 	.word	0x40000004
    2dd0:	0000040c 	.word	0x0000040c

00002dd4 <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    2dd4:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    2dd6:	4b19      	ldr	r3, [pc, #100]	; (2e3c <nrfx_power_clock_irq_handler+0x68>)
    2dd8:	681b      	ldr	r3, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    2dda:	2b00      	cmp	r3, #0
    2ddc:	d00c      	beq.n	2df8 <nrfx_power_clock_irq_handler+0x24>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2dde:	4b17      	ldr	r3, [pc, #92]	; (2e3c <nrfx_power_clock_irq_handler+0x68>)
    2de0:	2200      	movs	r2, #0
    2de2:	601a      	str	r2, [r3, #0]
    p_reg->INTENCLR = mask;
    2de4:	2280      	movs	r2, #128	; 0x80
    2de6:	05d2      	lsls	r2, r2, #23
    2de8:	23c2      	movs	r3, #194	; 0xc2
    2dea:	009b      	lsls	r3, r3, #2
    2dec:	2101      	movs	r1, #1
    2dee:	50d1      	str	r1, [r2, r3]
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    2df0:	4b13      	ldr	r3, [pc, #76]	; (2e40 <nrfx_power_clock_irq_handler+0x6c>)
    2df2:	681b      	ldr	r3, [r3, #0]
    2df4:	2000      	movs	r0, #0
    2df6:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    2df8:	4b12      	ldr	r3, [pc, #72]	; (2e44 <nrfx_power_clock_irq_handler+0x70>)
    2dfa:	681b      	ldr	r3, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    2dfc:	2b00      	cmp	r3, #0
    2dfe:	d011      	beq.n	2e24 <nrfx_power_clock_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2e00:	4b10      	ldr	r3, [pc, #64]	; (2e44 <nrfx_power_clock_irq_handler+0x70>)
    2e02:	2200      	movs	r2, #0
    2e04:	601a      	str	r2, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    2e06:	2280      	movs	r2, #128	; 0x80
    2e08:	05d2      	lsls	r2, r2, #23
    2e0a:	2383      	movs	r3, #131	; 0x83
    2e0c:	00db      	lsls	r3, r3, #3
    2e0e:	58d1      	ldr	r1, [r2, r3]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    2e10:	58d3      	ldr	r3, [r2, r3]
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    2e12:	078b      	lsls	r3, r1, #30
    2e14:	d107      	bne.n	2e26 <nrfx_power_clock_irq_handler+0x52>
    p_reg->LFCLKSRC = (uint32_t)(source);
    2e16:	2301      	movs	r3, #1
    2e18:	0011      	movs	r1, r2
    2e1a:	22a3      	movs	r2, #163	; 0xa3
    2e1c:	00d2      	lsls	r2, r2, #3
    2e1e:	508b      	str	r3, [r1, r2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2e20:	4a09      	ldr	r2, [pc, #36]	; (2e48 <nrfx_power_clock_irq_handler+0x74>)
    2e22:	6013      	str	r3, [r2, #0]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    2e24:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
    2e26:	2280      	movs	r2, #128	; 0x80
    2e28:	05d2      	lsls	r2, r2, #23
    2e2a:	23c2      	movs	r3, #194	; 0xc2
    2e2c:	009b      	lsls	r3, r3, #2
    2e2e:	2102      	movs	r1, #2
    2e30:	50d1      	str	r1, [r2, r3]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    2e32:	4b03      	ldr	r3, [pc, #12]	; (2e40 <nrfx_power_clock_irq_handler+0x6c>)
    2e34:	681b      	ldr	r3, [r3, #0]
    2e36:	2001      	movs	r0, #1
    2e38:	4798      	blx	r3
}
    2e3a:	e7f3      	b.n	2e24 <nrfx_power_clock_irq_handler+0x50>
    2e3c:	40000100 	.word	0x40000100
    2e40:	2000027c 	.word	0x2000027c
    2e44:	40000104 	.word	0x40000104
    2e48:	40000008 	.word	0x40000008

00002e4c <is_allocated_channel>:
    NRFX_LOG_INFO("Uninitialized.");
}

static bool is_allocated_channel(uint8_t index)
{
    return m_cb.allocated_channels_mask & (1UL << index);
    2e4c:	4b04      	ldr	r3, [pc, #16]	; (2e60 <is_allocated_channel+0x14>)
    2e4e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2e50:	2301      	movs	r3, #1
    2e52:	4083      	lsls	r3, r0
    2e54:	0018      	movs	r0, r3
    2e56:	4010      	ands	r0, r2
    2e58:	1e43      	subs	r3, r0, #1
    2e5a:	4198      	sbcs	r0, r3
    2e5c:	b2c0      	uxtb	r0, r0
}
    2e5e:	4770      	bx	lr
    2e60:	20000284 	.word	0x20000284

00002e64 <channel_allocated_set>:
    return NRFX_GPIOTE_APP_CHANNELS_MASK & (1UL << index);
}

static void channel_allocated_set(uint8_t index)
{
    m_cb.allocated_channels_mask |= (1UL << index);
    2e64:	2301      	movs	r3, #1
    2e66:	4083      	lsls	r3, r0
    2e68:	4a02      	ldr	r2, [pc, #8]	; (2e74 <channel_allocated_set+0x10>)
    2e6a:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
    2e6c:	430b      	orrs	r3, r1
    2e6e:	63d3      	str	r3, [r2, #60]	; 0x3c
}
    2e70:	4770      	bx	lr
    2e72:	46c0      	nop			; (mov r8, r8)
    2e74:	20000284 	.word	0x20000284

00002e78 <channel_allocated_clr>:

static void channel_allocated_clr(uint8_t index)
{
    m_cb.allocated_channels_mask &= ~(1UL << index);
    2e78:	2301      	movs	r3, #1
    2e7a:	4083      	lsls	r3, r0
    2e7c:	4a02      	ldr	r2, [pc, #8]	; (2e88 <channel_allocated_clr+0x10>)
    2e7e:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
    2e80:	4399      	bics	r1, r3
    2e82:	63d1      	str	r1, [r2, #60]	; 0x3c
}
    2e84:	4770      	bx	lr
    2e86:	46c0      	nop			; (mov r8, r8)
    2e88:	20000284 	.word	0x20000284

00002e8c <nrfx_gpiote_channel_free>:

nrfx_err_t nrfx_gpiote_channel_free(uint8_t channel)
{
    2e8c:	b570      	push	{r4, r5, r6, lr}
    2e8e:	0004      	movs	r4, r0
    nrfx_err_t err_code = NRFX_SUCCESS;

    if (!is_app_channel(channel))
    2e90:	f001 fdbc 	bl	4a0c <is_app_channel>
    2e94:	2800      	cmp	r0, #0
    2e96:	d101      	bne.n	2e9c <nrfx_gpiote_channel_free+0x10>
    {
        err_code = NRFX_ERROR_INVALID_PARAM;
    2e98:	4808      	ldr	r0, [pc, #32]	; (2ebc <nrfx_gpiote_channel_free+0x30>)
        NRFX_CRITICAL_SECTION_EXIT();
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    2e9a:	bd70      	pop	{r4, r5, r6, pc}
	__asm__ volatile("mrs %0, PRIMASK;"
    2e9c:	f3ef 8510 	mrs	r5, PRIMASK
    2ea0:	b672      	cpsid	i
        channel_allocated_clr(channel);
    2ea2:	0020      	movs	r0, r4
    2ea4:	f7ff ffe8 	bl	2e78 <channel_allocated_clr>
	if (key != 0U) {
    2ea8:	2d00      	cmp	r5, #0
    2eaa:	d104      	bne.n	2eb6 <nrfx_gpiote_channel_free+0x2a>
	__asm__ volatile(
    2eac:	b662      	cpsie	i
    2eae:	f3bf 8f6f 	isb	sy
    nrfx_err_t err_code = NRFX_SUCCESS;
    2eb2:	4803      	ldr	r0, [pc, #12]	; (2ec0 <nrfx_gpiote_channel_free+0x34>)
    2eb4:	e7f1      	b.n	2e9a <nrfx_gpiote_channel_free+0xe>
    2eb6:	4802      	ldr	r0, [pc, #8]	; (2ec0 <nrfx_gpiote_channel_free+0x34>)
    return err_code;
    2eb8:	e7ef      	b.n	2e9a <nrfx_gpiote_channel_free+0xe>
    2eba:	46c0      	nop			; (mov r8, r8)
    2ebc:	0bad0004 	.word	0x0bad0004
    2ec0:	0bad0000 	.word	0x0bad0000

00002ec4 <nrfx_gpiote_channel_alloc>:

nrfx_err_t nrfx_gpiote_channel_alloc(uint8_t * p_channel)
{
    2ec4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ec6:	46ce      	mov	lr, r9
    2ec8:	4647      	mov	r7, r8
    2eca:	b580      	push	{r7, lr}
    2ecc:	4680      	mov	r8, r0
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    uint32_t mask = NRFX_GPIOTE_APP_CHANNELS_MASK;

    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    2ece:	2400      	movs	r4, #0
    uint32_t mask = NRFX_GPIOTE_APP_CHANNELS_MASK;
    2ed0:	250f      	movs	r5, #15
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    2ed2:	4f15      	ldr	r7, [pc, #84]	; (2f28 <nrfx_gpiote_channel_alloc+0x64>)
    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    2ed4:	e013      	b.n	2efe <nrfx_gpiote_channel_alloc+0x3a>
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
        {
            channel_allocated_set(ch_idx);
    2ed6:	0020      	movs	r0, r4
    2ed8:	f7ff ffc4 	bl	2e64 <channel_allocated_set>
            *p_channel = ch_idx;
    2edc:	4643      	mov	r3, r8
    2ede:	701c      	strb	r4, [r3, #0]
            err_code = NRFX_SUCCESS;
    2ee0:	4f12      	ldr	r7, [pc, #72]	; (2f2c <nrfx_gpiote_channel_alloc+0x68>)
	if (key != 0U) {
    2ee2:	2e00      	cmp	r6, #0
    2ee4:	d102      	bne.n	2eec <nrfx_gpiote_channel_alloc+0x28>
	__asm__ volatile(
    2ee6:	b662      	cpsie	i
    2ee8:	f3bf 8f6f 	isb	sy
        }
        NRFX_CRITICAL_SECTION_EXIT();

        if (err_code == NRFX_SUCCESS)
    2eec:	4b0f      	ldr	r3, [pc, #60]	; (2f2c <nrfx_gpiote_channel_alloc+0x68>)
    2eee:	429f      	cmp	r7, r3
    2ef0:	d015      	beq.n	2f1e <nrfx_gpiote_channel_alloc+0x5a>
        {
            NRFX_LOG_INFO("Allocated channel: %d.", ch_idx);
            break;
        }

        mask &= ~(1UL << ch_idx);
    2ef2:	2301      	movs	r3, #1
    2ef4:	464a      	mov	r2, r9
    2ef6:	4093      	lsls	r3, r2
    2ef8:	439d      	bics	r5, r3
    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    2efa:	3401      	adds	r4, #1
    2efc:	b2e4      	uxtb	r4, r4
    2efe:	2d00      	cmp	r5, #0
    2f00:	d00d      	beq.n	2f1e <nrfx_gpiote_channel_alloc+0x5a>
	__asm__ volatile("mrs %0, PRIMASK;"
    2f02:	f3ef 8610 	mrs	r6, PRIMASK
    2f06:	b672      	cpsid	i
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
    2f08:	46a1      	mov	r9, r4
    2f0a:	002b      	movs	r3, r5
    2f0c:	40e3      	lsrs	r3, r4
    2f0e:	07db      	lsls	r3, r3, #31
    2f10:	d5e7      	bpl.n	2ee2 <nrfx_gpiote_channel_alloc+0x1e>
    2f12:	0020      	movs	r0, r4
    2f14:	f7ff ff9a 	bl	2e4c <is_allocated_channel>
    2f18:	2800      	cmp	r0, #0
    2f1a:	d1e2      	bne.n	2ee2 <nrfx_gpiote_channel_alloc+0x1e>
    2f1c:	e7db      	b.n	2ed6 <nrfx_gpiote_channel_alloc+0x12>
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    2f1e:	0038      	movs	r0, r7
    2f20:	bc0c      	pop	{r2, r3}
    2f22:	4690      	mov	r8, r2
    2f24:	4699      	mov	r9, r3
    2f26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2f28:	0bad0002 	.word	0x0bad0002
    2f2c:	0bad0000 	.word	0x0bad0000

00002f30 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	const struct device *dev = __device_start;
    2f30:	4b03      	ldr	r3, [pc, #12]	; (2f40 <z_device_state_init+0x10>)

	while (dev < __device_end) {
    2f32:	4a04      	ldr	r2, [pc, #16]	; (2f44 <z_device_state_init+0x14>)
    2f34:	4293      	cmp	r3, r2
    2f36:	d201      	bcs.n	2f3c <z_device_state_init+0xc>
		z_object_init(dev);
		++dev;
    2f38:	3318      	adds	r3, #24
    2f3a:	e7fa      	b.n	2f32 <z_device_state_init+0x2>
	}
}
    2f3c:	4770      	bx	lr
    2f3e:	46c0      	nop			; (mov r8, r8)
    2f40:	00004e64 	.word	0x00004e64
    2f44:	00004ec4 	.word	0x00004ec4

00002f48 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    2f48:	b570      	push	{r4, r5, r6, lr}
    2f4a:	0006      	movs	r6, r0
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2f4c:	0082      	lsls	r2, r0, #2
    2f4e:	4b10      	ldr	r3, [pc, #64]	; (2f90 <z_sys_init_run_level+0x48>)
    2f50:	58d4      	ldr	r4, [r2, r3]
    2f52:	e009      	b.n	2f68 <z_sys_init_run_level+0x20>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
				if (rc < 0) {
					rc = -rc;
    2f54:	4240      	negs	r0, r0
    2f56:	e016      	b.n	2f86 <z_sys_init_run_level+0x3e>
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    2f58:	68eb      	ldr	r3, [r5, #12]
    2f5a:	7018      	strb	r0, [r3, #0]
			}
			dev->state->initialized = true;
    2f5c:	68ea      	ldr	r2, [r5, #12]
    2f5e:	7853      	ldrb	r3, [r2, #1]
    2f60:	2101      	movs	r1, #1
    2f62:	430b      	orrs	r3, r1
    2f64:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2f66:	3408      	adds	r4, #8
    2f68:	1c73      	adds	r3, r6, #1
    2f6a:	009b      	lsls	r3, r3, #2
    2f6c:	4a08      	ldr	r2, [pc, #32]	; (2f90 <z_sys_init_run_level+0x48>)
    2f6e:	589b      	ldr	r3, [r3, r2]
    2f70:	42a3      	cmp	r3, r4
    2f72:	d90c      	bls.n	2f8e <z_sys_init_run_level+0x46>
		const struct device *dev = entry->dev;
    2f74:	6865      	ldr	r5, [r4, #4]
		int rc = entry->init(dev);
    2f76:	0028      	movs	r0, r5
    2f78:	6823      	ldr	r3, [r4, #0]
    2f7a:	4798      	blx	r3
		if (dev != NULL) {
    2f7c:	2d00      	cmp	r5, #0
    2f7e:	d0f2      	beq.n	2f66 <z_sys_init_run_level+0x1e>
			if (rc != 0) {
    2f80:	2800      	cmp	r0, #0
    2f82:	d0eb      	beq.n	2f5c <z_sys_init_run_level+0x14>
				if (rc < 0) {
    2f84:	dbe6      	blt.n	2f54 <z_sys_init_run_level+0xc>
				if (rc > UINT8_MAX) {
    2f86:	28ff      	cmp	r0, #255	; 0xff
    2f88:	dde6      	ble.n	2f58 <z_sys_init_run_level+0x10>
					rc = UINT8_MAX;
    2f8a:	20ff      	movs	r0, #255	; 0xff
    2f8c:	e7e4      	b.n	2f58 <z_sys_init_run_level+0x10>
		}
	}
}
    2f8e:	bd70      	pop	{r4, r5, r6, pc}
    2f90:	00005790 	.word	0x00005790

00002f94 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    2f94:	b570      	push	{r4, r5, r6, lr}
    2f96:	1e05      	subs	r5, r0, #0
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    2f98:	d026      	beq.n	2fe8 <z_impl_device_get_binding+0x54>
    2f9a:	7803      	ldrb	r3, [r0, #0]
    2f9c:	2b00      	cmp	r3, #0
    2f9e:	d025      	beq.n	2fec <z_impl_device_get_binding+0x58>
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
    2fa0:	4c13      	ldr	r4, [pc, #76]	; (2ff0 <z_impl_device_get_binding+0x5c>)
    2fa2:	e000      	b.n	2fa6 <z_impl_device_get_binding+0x12>
    2fa4:	3418      	adds	r4, #24
    2fa6:	4b13      	ldr	r3, [pc, #76]	; (2ff4 <z_impl_device_get_binding+0x60>)
    2fa8:	429c      	cmp	r4, r3
    2faa:	d008      	beq.n	2fbe <z_impl_device_get_binding+0x2a>
		if (z_device_ready(dev) && (dev->name == name)) {
    2fac:	0020      	movs	r0, r4
    2fae:	f001 fd35 	bl	4a1c <z_device_ready>
    2fb2:	2800      	cmp	r0, #0
    2fb4:	d0f6      	beq.n	2fa4 <z_impl_device_get_binding+0x10>
    2fb6:	6823      	ldr	r3, [r4, #0]
    2fb8:	42ab      	cmp	r3, r5
    2fba:	d1f3      	bne.n	2fa4 <z_impl_device_get_binding+0x10>
    2fbc:	e012      	b.n	2fe4 <z_impl_device_get_binding+0x50>
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
    2fbe:	4c0c      	ldr	r4, [pc, #48]	; (2ff0 <z_impl_device_get_binding+0x5c>)
    2fc0:	e000      	b.n	2fc4 <z_impl_device_get_binding+0x30>
    2fc2:	3418      	adds	r4, #24
    2fc4:	4b0b      	ldr	r3, [pc, #44]	; (2ff4 <z_impl_device_get_binding+0x60>)
    2fc6:	429c      	cmp	r4, r3
    2fc8:	d00b      	beq.n	2fe2 <z_impl_device_get_binding+0x4e>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    2fca:	0020      	movs	r0, r4
    2fcc:	f001 fd26 	bl	4a1c <z_device_ready>
    2fd0:	2800      	cmp	r0, #0
    2fd2:	d0f6      	beq.n	2fc2 <z_impl_device_get_binding+0x2e>
    2fd4:	6821      	ldr	r1, [r4, #0]
    2fd6:	0028      	movs	r0, r5
    2fd8:	f001 fab7 	bl	454a <strcmp>
    2fdc:	2800      	cmp	r0, #0
    2fde:	d1f0      	bne.n	2fc2 <z_impl_device_get_binding+0x2e>
    2fe0:	e000      	b.n	2fe4 <z_impl_device_get_binding+0x50>
			return dev;
		}
	}

	return NULL;
    2fe2:	2400      	movs	r4, #0
}
    2fe4:	0020      	movs	r0, r4
    2fe6:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
    2fe8:	0004      	movs	r4, r0
    2fea:	e7fb      	b.n	2fe4 <z_impl_device_get_binding+0x50>
    2fec:	2400      	movs	r4, #0
    2fee:	e7f9      	b.n	2fe4 <z_impl_device_get_binding+0x50>
    2ff0:	00004e64 	.word	0x00004e64
    2ff4:	00004ec4 	.word	0x00004ec4

00002ff8 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    2ff8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2ffa:	b089      	sub	sp, #36	; 0x24
    2ffc:	0005      	movs	r5, r0
	struct k_thread *thread = &z_idle_threads[i];
    2ffe:	24a8      	movs	r4, #168	; 0xa8
    3000:	4344      	muls	r4, r0
    3002:	4b13      	ldr	r3, [pc, #76]	; (3050 <init_idle_thread+0x58>)
    3004:	18e4      	adds	r4, r4, r3
	k_thread_stack_t *stack = z_idle_stacks[i];
    3006:	0206      	lsls	r6, r0, #8
    3008:	4b12      	ldr	r3, [pc, #72]	; (3054 <init_idle_thread+0x5c>)
    300a:	18f6      	adds	r6, r6, r3

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
    300c:	af06      	add	r7, sp, #24
    300e:	0003      	movs	r3, r0
    3010:	4a11      	ldr	r2, [pc, #68]	; (3058 <init_idle_thread+0x60>)
    3012:	2108      	movs	r1, #8
    3014:	0038      	movs	r0, r7
    3016:	f000 ff68 	bl	3eea <snprintk>
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    301a:	0068      	lsls	r0, r5, #1
    301c:	1945      	adds	r5, r0, r5
    301e:	00ed      	lsls	r5, r5, #3
    3020:	480e      	ldr	r0, [pc, #56]	; (305c <init_idle_thread+0x64>)
    3022:	1945      	adds	r5, r0, r5
	z_setup_new_thread(thread, stack,
    3024:	2280      	movs	r2, #128	; 0x80
    3026:	9705      	str	r7, [sp, #20]
    3028:	2301      	movs	r3, #1
    302a:	9304      	str	r3, [sp, #16]
    302c:	330e      	adds	r3, #14
    302e:	9303      	str	r3, [sp, #12]
    3030:	2300      	movs	r3, #0
    3032:	9302      	str	r3, [sp, #8]
    3034:	9301      	str	r3, [sp, #4]
    3036:	9500      	str	r5, [sp, #0]
    3038:	4b09      	ldr	r3, [pc, #36]	; (3060 <init_idle_thread+0x68>)
    303a:	0052      	lsls	r2, r2, #1
    303c:	0031      	movs	r1, r6
    303e:	0020      	movs	r0, r4
    3040:	f000 f8e8 	bl	3214 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    3044:	7b63      	ldrb	r3, [r4, #13]
    3046:	2204      	movs	r2, #4
    3048:	4393      	bics	r3, r2
    304a:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    304c:	b009      	add	sp, #36	; 0x24
    304e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3050:	20000058 	.word	0x20000058
    3054:	20000708 	.word	0x20000708
    3058:	000057a8 	.word	0x000057a8
    305c:	200002c4 	.word	0x200002c4
    3060:	00004aa3 	.word	0x00004aa3

00003064 <prepare_multithreading>:
 *
 * @return initial stack pointer for the main thread
 */
__boot_func
static char *prepare_multithreading(void)
{
    3064:	b530      	push	{r4, r5, lr}
    3066:	b087      	sub	sp, #28
	char *stack_ptr;

	/* _kernel.ready_q is all zeroes */
	z_sched_init();
    3068:	f000 fc4c 	bl	3904 <z_sched_init>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_kernel.ready_q.cache = &z_main_thread;
    306c:	4c1c      	ldr	r4, [pc, #112]	; (30e0 <prepare_multithreading+0x7c>)
    306e:	4b1d      	ldr	r3, [pc, #116]	; (30e4 <prepare_multithreading+0x80>)
    3070:	61dc      	str	r4, [r3, #28]
#endif
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    3072:	2280      	movs	r2, #128	; 0x80
    3074:	4b1c      	ldr	r3, [pc, #112]	; (30e8 <prepare_multithreading+0x84>)
    3076:	9305      	str	r3, [sp, #20]
    3078:	2301      	movs	r3, #1
    307a:	9304      	str	r3, [sp, #16]
    307c:	2300      	movs	r3, #0
    307e:	9303      	str	r3, [sp, #12]
    3080:	9302      	str	r3, [sp, #8]
    3082:	9301      	str	r3, [sp, #4]
    3084:	9300      	str	r3, [sp, #0]
    3086:	4b19      	ldr	r3, [pc, #100]	; (30ec <prepare_multithreading+0x88>)
    3088:	00d2      	lsls	r2, r2, #3
    308a:	4919      	ldr	r1, [pc, #100]	; (30f0 <prepare_multithreading+0x8c>)
    308c:	0020      	movs	r0, r4
    308e:	f000 f8c1 	bl	3214 <z_setup_new_thread>
    3092:	0005      	movs	r5, r0
    3094:	7b63      	ldrb	r3, [r4, #13]
    3096:	2204      	movs	r2, #4
    3098:	4393      	bics	r3, r2
    309a:	7363      	strb	r3, [r4, #13]
				       CONFIG_MAIN_STACK_SIZE, bg_thread_main,
				       NULL, NULL, NULL,
				       CONFIG_MAIN_THREAD_PRIORITY,
				       K_ESSENTIAL, "main");
	z_mark_thread_as_started(&z_main_thread);
	z_ready_thread(&z_main_thread);
    309c:	0020      	movs	r0, r4
    309e:	f001 fd3b 	bl	4b18 <z_ready_thread>

	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    30a2:	2400      	movs	r4, #0
    30a4:	2c00      	cmp	r4, #0
    30a6:	dd02      	ble.n	30ae <prepare_multithreading+0x4a>
			(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]) +
			 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]));
	}

	return stack_ptr;
}
    30a8:	0028      	movs	r0, r5
    30aa:	b007      	add	sp, #28
    30ac:	bd30      	pop	{r4, r5, pc}
		init_idle_thread(i);
    30ae:	0020      	movs	r0, r4
    30b0:	f7ff ffa2 	bl	2ff8 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    30b4:	22a8      	movs	r2, #168	; 0xa8
    30b6:	4362      	muls	r2, r4
    30b8:	4b0e      	ldr	r3, [pc, #56]	; (30f4 <prepare_multithreading+0x90>)
    30ba:	18d2      	adds	r2, r2, r3
    30bc:	0063      	lsls	r3, r4, #1
    30be:	191b      	adds	r3, r3, r4
    30c0:	00d9      	lsls	r1, r3, #3
    30c2:	4b08      	ldr	r3, [pc, #32]	; (30e4 <prepare_multithreading+0x80>)
    30c4:	185b      	adds	r3, r3, r1
    30c6:	60da      	str	r2, [r3, #12]
		_kernel.cpus[i].id = i;
    30c8:	751c      	strb	r4, [r3, #20]
			(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]) +
    30ca:	02e2      	lsls	r2, r4, #11
    30cc:	490a      	ldr	r1, [pc, #40]	; (30f8 <prepare_multithreading+0x94>)
    30ce:	1852      	adds	r2, r2, r1
    30d0:	2180      	movs	r1, #128	; 0x80
    30d2:	0109      	lsls	r1, r1, #4
    30d4:	468c      	mov	ip, r1
    30d6:	4462      	add	r2, ip
		_kernel.cpus[i].irq_stack =
    30d8:	605a      	str	r2, [r3, #4]
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    30da:	3401      	adds	r4, #1
    30dc:	e7e2      	b.n	30a4 <prepare_multithreading+0x40>
    30de:	46c0      	nop			; (mov r8, r8)
    30e0:	20000100 	.word	0x20000100
    30e4:	200002c4 	.word	0x200002c4
    30e8:	000057b4 	.word	0x000057b4
    30ec:	000030fd 	.word	0x000030fd
    30f0:	20000308 	.word	0x20000308
    30f4:	20000058 	.word	0x20000058
    30f8:	20000808 	.word	0x20000808

000030fc <bg_thread_main>:
{
    30fc:	b510      	push	{r4, lr}
	z_sys_post_kernel = true;
    30fe:	2401      	movs	r4, #1
    3100:	4b09      	ldr	r3, [pc, #36]	; (3128 <bg_thread_main+0x2c>)
    3102:	701c      	strb	r4, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    3104:	2002      	movs	r0, #2
    3106:	f7ff ff1f 	bl	2f48 <z_sys_init_run_level>
	boot_banner();
    310a:	f000 fe65 	bl	3dd8 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    310e:	2003      	movs	r0, #3
    3110:	f7ff ff1a 	bl	2f48 <z_sys_init_run_level>
	z_init_static_threads();
    3114:	f000 f8d4 	bl	32c0 <z_init_static_threads>
	main();
    3118:	f7fd fa46 	bl	5a8 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    311c:	4a03      	ldr	r2, [pc, #12]	; (312c <bg_thread_main+0x30>)
    311e:	7b13      	ldrb	r3, [r2, #12]
    3120:	43a3      	bics	r3, r4
    3122:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    3124:	bd10      	pop	{r4, pc}
    3126:	46c0      	nop			; (mov r8, r8)
    3128:	20000303 	.word	0x20000303
    312c:	20000100 	.word	0x20000100

00003130 <switch_to_main_thread>:

__boot_func
static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
    3130:	b510      	push	{r4, lr}
    3132:	0001      	movs	r1, r0
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    3134:	4a01      	ldr	r2, [pc, #4]	; (313c <switch_to_main_thread+0xc>)
    3136:	4802      	ldr	r0, [pc, #8]	; (3140 <switch_to_main_thread+0x10>)
    3138:	f7fe fa04 	bl	1544 <arch_switch_to_main_thread>
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
#endif
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    313c:	000030fd 	.word	0x000030fd
    3140:	20000100 	.word	0x20000100

00003144 <z_bss_zero>:
{
    3144:	b510      	push	{r4, lr}
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    3146:	4803      	ldr	r0, [pc, #12]	; (3154 <z_bss_zero+0x10>)
    3148:	4a03      	ldr	r2, [pc, #12]	; (3158 <z_bss_zero+0x14>)
    314a:	1a12      	subs	r2, r2, r0
    314c:	2100      	movs	r1, #0
    314e:	f001 fa27 	bl	45a0 <memset>
}
    3152:	bd10      	pop	{r4, pc}
    3154:	20000038 	.word	0x20000038
    3158:	20000304 	.word	0x20000304

0000315c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    315c:	b500      	push	{lr}
    315e:	b0ab      	sub	sp, #172	; 0xac
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
    3160:	4b12      	ldr	r3, [pc, #72]	; (31ac <z_cstart+0x50>)
	uint32_t msp =
    3162:	2280      	movs	r2, #128	; 0x80
    3164:	0112      	lsls	r2, r2, #4
    3166:	4694      	mov	ip, r2
    3168:	4463      	add	r3, ip
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    316a:	f383 8808 	msr	MSP, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    316e:	4910      	ldr	r1, [pc, #64]	; (31b0 <z_cstart+0x54>)
    3170:	6a0b      	ldr	r3, [r1, #32]
    3172:	4a10      	ldr	r2, [pc, #64]	; (31b4 <z_cstart+0x58>)
    3174:	401a      	ands	r2, r3
    3176:	23c0      	movs	r3, #192	; 0xc0
    3178:	041b      	lsls	r3, r3, #16
    317a:	4313      	orrs	r3, r2
    317c:	620b      	str	r3, [r1, #32]

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    317e:	f001 f9bc 	bl	44fa <z_arm_fault_init>
	z_arm_cpu_idle_init();
    3182:	f7fe f905 	bl	1390 <z_arm_cpu_idle_init>
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    3186:	2301      	movs	r3, #1
    3188:	466a      	mov	r2, sp
    318a:	7353      	strb	r3, [r2, #13]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    318c:	7313      	strb	r3, [r2, #12]
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    318e:	4b0a      	ldr	r3, [pc, #40]	; (31b8 <z_cstart+0x5c>)
    3190:	609a      	str	r2, [r3, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    3192:	f7ff fecd 	bl	2f30 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    3196:	2000      	movs	r0, #0
    3198:	f7ff fed6 	bl	2f48 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    319c:	2001      	movs	r0, #1
    319e:	f7ff fed3 	bl	2f48 <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
    31a2:	f7ff ff5f 	bl	3064 <prepare_multithreading>
    31a6:	f7ff ffc3 	bl	3130 <switch_to_main_thread>
    31aa:	46c0      	nop			; (mov r8, r8)
    31ac:	20000808 	.word	0x20000808
    31b0:	e000ed00 	.word	0xe000ed00
    31b4:	ff00ffff 	.word	0xff00ffff
    31b8:	200002c4 	.word	0x200002c4

000031bc <z_thread_monitor_exit>:
    31bc:	f3ef 8110 	mrs	r1, PRIMASK
    31c0:	b672      	cpsid	i
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
    31c2:	4b0c      	ldr	r3, [pc, #48]	; (31f4 <z_thread_monitor_exit+0x38>)
    31c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    31c6:	4283      	cmp	r3, r0
    31c8:	d104      	bne.n	31d4 <z_thread_monitor_exit+0x18>
		_kernel.threads = _kernel.threads->next_thread;
    31ca:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    31cc:	4b09      	ldr	r3, [pc, #36]	; (31f4 <z_thread_monitor_exit+0x38>)
    31ce:	629a      	str	r2, [r3, #40]	; 0x28
    31d0:	e009      	b.n	31e6 <z_thread_monitor_exit+0x2a>
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while ((prev_thread != NULL) &&
			(thread != prev_thread->next_thread)) {
			prev_thread = prev_thread->next_thread;
    31d2:	0013      	movs	r3, r2
		while ((prev_thread != NULL) &&
    31d4:	2b00      	cmp	r3, #0
    31d6:	d002      	beq.n	31de <z_thread_monitor_exit+0x22>
			(thread != prev_thread->next_thread)) {
    31d8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
		while ((prev_thread != NULL) &&
    31da:	4282      	cmp	r2, r0
    31dc:	d1f9      	bne.n	31d2 <z_thread_monitor_exit+0x16>
		}
		if (prev_thread != NULL) {
    31de:	2b00      	cmp	r3, #0
    31e0:	d001      	beq.n	31e6 <z_thread_monitor_exit+0x2a>
			prev_thread->next_thread = thread->next_thread;
    31e2:	6f02      	ldr	r2, [r0, #112]	; 0x70
    31e4:	671a      	str	r2, [r3, #112]	; 0x70
	if (key != 0U) {
    31e6:	2900      	cmp	r1, #0
    31e8:	d102      	bne.n	31f0 <z_thread_monitor_exit+0x34>
	__asm__ volatile(
    31ea:	b662      	cpsie	i
    31ec:	f3bf 8f6f 	isb	sy
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
    31f0:	4770      	bx	lr
    31f2:	46c0      	nop			; (mov r8, r8)
    31f4:	200002c4 	.word	0x200002c4

000031f8 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
    31f8:	b510      	push	{r4, lr}
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    31fa:	0019      	movs	r1, r3
    31fc:	4311      	orrs	r1, r2
    31fe:	d102      	bne.n	3206 <schedule_new_thread+0xe>
	z_impl_k_thread_start(thread);
    3200:	f001 fc3b 	bl	4a7a <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
    3204:	bd10      	pop	{r4, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    3206:	3018      	adds	r0, #24
    3208:	4901      	ldr	r1, [pc, #4]	; (3210 <schedule_new_thread+0x18>)
    320a:	f000 fccf 	bl	3bac <z_add_timeout>
    320e:	e7f9      	b.n	3204 <schedule_new_thread+0xc>
    3210:	00004b4d 	.word	0x00004b4d

00003214 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    3214:	b5f0      	push	{r4, r5, r6, r7, lr}
    3216:	b085      	sub	sp, #20
    3218:	0004      	movs	r4, r0
    321a:	000f      	movs	r7, r1
    321c:	0015      	movs	r5, r2
    321e:	001e      	movs	r6, r3
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    3220:	0003      	movs	r3, r0
    3222:	3358      	adds	r3, #88	; 0x58
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    3224:	6583      	str	r3, [r0, #88]	; 0x58
	list->tail = (sys_dnode_t *)list;
    3226:	65c3      	str	r3, [r0, #92]	; 0x5c
	k_object_access_grant(new_thread, new_thread);
#endif
	z_waitq_init(&new_thread->join_queue);

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    3228:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    322a:	2204      	movs	r2, #4
    322c:	990d      	ldr	r1, [sp, #52]	; 0x34
    322e:	f001 fc28 	bl	4a82 <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
    3232:	002a      	movs	r2, r5
    3234:	0039      	movs	r1, r7
    3236:	0020      	movs	r0, r4
    3238:	f001 fc14 	bl	4a64 <setup_thread_stack>
    323c:	0005      	movs	r5, r0
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    323e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3240:	9302      	str	r3, [sp, #8]
    3242:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3244:	9301      	str	r3, [sp, #4]
    3246:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3248:	9300      	str	r3, [sp, #0]
    324a:	0033      	movs	r3, r6
    324c:	0002      	movs	r2, r0
    324e:	0039      	movs	r1, r7
    3250:	0020      	movs	r0, r4
    3252:	f7fe f95f 	bl	1514 <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
    3256:	2300      	movs	r3, #0
    3258:	6563      	str	r3, [r4, #84]	; 0x54
#ifdef CONFIG_THREAD_CUSTOM_DATA
	/* Initialize custom data field (value is opaque to kernel) */
	new_thread->custom_data = NULL;
#endif
#ifdef CONFIG_THREAD_MONITOR
	new_thread->entry.pEntry = entry;
    325a:	6626      	str	r6, [r4, #96]	; 0x60
	new_thread->entry.parameter1 = p1;
    325c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    325e:	6663      	str	r3, [r4, #100]	; 0x64
	new_thread->entry.parameter2 = p2;
    3260:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3262:	66a3      	str	r3, [r4, #104]	; 0x68
	new_thread->entry.parameter3 = p3;
    3264:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3266:	66e3      	str	r3, [r4, #108]	; 0x6c
	__asm__ volatile("mrs %0, PRIMASK;"
    3268:	f3ef 8210 	mrs	r2, PRIMASK
    326c:	b672      	cpsid	i

	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	new_thread->next_thread = _kernel.threads;
    326e:	4b13      	ldr	r3, [pc, #76]	; (32bc <z_setup_new_thread+0xa8>)
    3270:	6a99      	ldr	r1, [r3, #40]	; 0x28
    3272:	6721      	str	r1, [r4, #112]	; 0x70
	_kernel.threads = new_thread;
    3274:	629c      	str	r4, [r3, #40]	; 0x28
	if (key != 0U) {
    3276:	2a00      	cmp	r2, #0
    3278:	d102      	bne.n	3280 <z_setup_new_thread+0x6c>
	__asm__ volatile(
    327a:	b662      	cpsie	i
    327c:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
#ifdef CONFIG_THREAD_NAME
	if (name != NULL) {
    3280:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3282:	2b00      	cmp	r3, #0
    3284:	d012      	beq.n	32ac <z_setup_new_thread+0x98>
		strncpy(new_thread->name, name,
    3286:	0020      	movs	r0, r4
    3288:	3074      	adds	r0, #116	; 0x74
    328a:	221f      	movs	r2, #31
    328c:	0019      	movs	r1, r3
    328e:	f001 f935 	bl	44fc <strncpy>
			CONFIG_THREAD_MAX_NAME_LEN - 1);
		/* Ensure NULL termination, truncate if longer */
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    3292:	2393      	movs	r3, #147	; 0x93
    3294:	2200      	movs	r2, #0
    3296:	54e2      	strb	r2, [r4, r3]
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    3298:	4b08      	ldr	r3, [pc, #32]	; (32bc <z_setup_new_thread+0xa8>)
    329a:	689b      	ldr	r3, [r3, #8]
    329c:	2b00      	cmp	r3, #0
    329e:	d009      	beq.n	32b4 <z_setup_new_thread+0xa0>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    32a0:	2298      	movs	r2, #152	; 0x98
    32a2:	589b      	ldr	r3, [r3, r2]
    32a4:	50a3      	str	r3, [r4, r2]
#ifdef CONFIG_THREAD_RUNTIME_STATS
	memset(&new_thread->rt_stats, 0, sizeof(new_thread->rt_stats));
#endif

	return stack_ptr;
}
    32a6:	0028      	movs	r0, r5
    32a8:	b005      	add	sp, #20
    32aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		new_thread->name[0] = '\0';
    32ac:	2374      	movs	r3, #116	; 0x74
    32ae:	2200      	movs	r2, #0
    32b0:	54e2      	strb	r2, [r4, r3]
    32b2:	e7f1      	b.n	3298 <z_setup_new_thread+0x84>
		new_thread->resource_pool = NULL;
    32b4:	3398      	adds	r3, #152	; 0x98
    32b6:	2200      	movs	r2, #0
    32b8:	50e2      	str	r2, [r4, r3]
		return stack_ptr;
    32ba:	e7f4      	b.n	32a6 <z_setup_new_thread+0x92>
    32bc:	200002c4 	.word	0x200002c4

000032c0 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    32c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    32c2:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
    32c4:	4c20      	ldr	r4, [pc, #128]	; (3348 <z_init_static_threads+0x88>)
    32c6:	4b21      	ldr	r3, [pc, #132]	; (334c <z_init_static_threads+0x8c>)
    32c8:	429c      	cmp	r4, r3
    32ca:	d215      	bcs.n	32f8 <z_init_static_threads+0x38>
		z_setup_new_thread(
    32cc:	68e3      	ldr	r3, [r4, #12]
    32ce:	68a2      	ldr	r2, [r4, #8]
    32d0:	6861      	ldr	r1, [r4, #4]
    32d2:	6820      	ldr	r0, [r4, #0]
    32d4:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    32d6:	9505      	str	r5, [sp, #20]
    32d8:	6a25      	ldr	r5, [r4, #32]
    32da:	9504      	str	r5, [sp, #16]
    32dc:	69e5      	ldr	r5, [r4, #28]
    32de:	9503      	str	r5, [sp, #12]
    32e0:	69a5      	ldr	r5, [r4, #24]
    32e2:	9502      	str	r5, [sp, #8]
    32e4:	6965      	ldr	r5, [r4, #20]
    32e6:	9501      	str	r5, [sp, #4]
    32e8:	6925      	ldr	r5, [r4, #16]
    32ea:	9500      	str	r5, [sp, #0]
    32ec:	f7ff ff92 	bl	3214 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
    32f0:	6823      	ldr	r3, [r4, #0]
    32f2:	655c      	str	r4, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    32f4:	3430      	adds	r4, #48	; 0x30
    32f6:	e7e6      	b.n	32c6 <z_init_static_threads+0x6>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    32f8:	f000 f8fe 	bl	34f8 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    32fc:	4c12      	ldr	r4, [pc, #72]	; (3348 <z_init_static_threads+0x88>)
    32fe:	e013      	b.n	3328 <z_init_static_threads+0x68>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
			schedule_new_thread(thread_data->init_thread,
					    K_MSEC(thread_data->init_delay));
    3300:	17d9      	asrs	r1, r3, #31
			return (t * to_hz + off) / from_hz;
    3302:	0c5a      	lsrs	r2, r3, #17
    3304:	03cf      	lsls	r7, r1, #15
    3306:	4317      	orrs	r7, r2
    3308:	03de      	lsls	r6, r3, #15
    330a:	4811      	ldr	r0, [pc, #68]	; (3350 <z_init_static_threads+0x90>)
    330c:	2100      	movs	r1, #0
    330e:	1980      	adds	r0, r0, r6
    3310:	4179      	adcs	r1, r7
    3312:	22fa      	movs	r2, #250	; 0xfa
    3314:	0092      	lsls	r2, r2, #2
    3316:	2300      	movs	r3, #0
    3318:	f7fc fee6 	bl	e8 <__aeabi_uldivmod>
    331c:	0002      	movs	r2, r0
    331e:	000b      	movs	r3, r1
			schedule_new_thread(thread_data->init_thread,
    3320:	0028      	movs	r0, r5
    3322:	f7ff ff69 	bl	31f8 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
    3326:	3430      	adds	r4, #48	; 0x30
    3328:	4b08      	ldr	r3, [pc, #32]	; (334c <z_init_static_threads+0x8c>)
    332a:	429c      	cmp	r4, r3
    332c:	d207      	bcs.n	333e <z_init_static_threads+0x7e>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    332e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3330:	1c5a      	adds	r2, r3, #1
    3332:	d0f8      	beq.n	3326 <z_init_static_threads+0x66>
			schedule_new_thread(thread_data->init_thread,
    3334:	6825      	ldr	r5, [r4, #0]
					    K_MSEC(thread_data->init_delay));
    3336:	2b00      	cmp	r3, #0
    3338:	dae2      	bge.n	3300 <z_init_static_threads+0x40>
    333a:	2300      	movs	r3, #0
    333c:	e7e0      	b.n	3300 <z_init_static_threads+0x40>
		}
	}
	k_sched_unlock();
    333e:	f000 fa71 	bl	3824 <k_sched_unlock>
}
    3342:	b007      	add	sp, #28
    3344:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3346:	46c0      	nop			; (mov r8, r8)
    3348:	20000034 	.word	0x20000034
    334c:	20000034 	.word	0x20000034
    3350:	000003e7 	.word	0x000003e7

00003354 <pm_save_idle>:
 *
 * Sets the kernel data structure idle field to either a positive value or
 * K_FOREVER.
 */
static void pm_save_idle(void)
{
    3354:	b510      	push	{r4, lr}
#ifdef CONFIG_PM
	int32_t ticks = z_get_next_timeout_expiry();
    3356:	f001 fcd5 	bl	4d04 <z_get_next_timeout_expiry>
	_kernel.idle = ticks;
    335a:	4b05      	ldr	r3, [pc, #20]	; (3370 <pm_save_idle+0x1c>)
    335c:	6198      	str	r0, [r3, #24]
	 * before exiting. This is because the kernel does not do its own idle
	 * processing in those cases i.e. skips k_cpu_idle(). The kernel's
	 * idle processing re-enables interrupts which is essential for
	 * the kernel's scheduling logic.
	 */
	if (pm_system_suspend(ticks) == PM_STATE_ACTIVE) {
    335e:	f7fd ffb5 	bl	12cc <pm_system_suspend>
    3362:	2800      	cmp	r0, #0
    3364:	d000      	beq.n	3368 <pm_save_idle+0x14>
		k_cpu_idle();
	}
#endif
}
    3366:	bd10      	pop	{r4, pc}
	arch_cpu_idle();
    3368:	f7fe f818 	bl	139c <arch_cpu_idle>
    336c:	e7fb      	b.n	3366 <pm_save_idle+0x12>
    336e:	46c0      	nop			; (mov r8, r8)
    3370:	200002c4 	.word	0x200002c4

00003374 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    3374:	b570      	push	{r4, r5, r6, lr}
    3376:	0004      	movs	r4, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    3378:	f3ef 8510 	mrs	r5, PRIMASK
    337c:	b672      	cpsid	i
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    337e:	f001 fc6a 	bl	4c56 <z_unpend_first_thread>

	if (thread != NULL) {
    3382:	2800      	cmp	r0, #0
    3384:	d009      	beq.n	339a <z_impl_k_sem_give+0x26>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    3386:	23a0      	movs	r3, #160	; 0xa0
    3388:	2200      	movs	r2, #0
    338a:	50c2      	str	r2, [r0, r3]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    338c:	f001 fbc4 	bl	4b18 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    3390:	0029      	movs	r1, r5
    3392:	4807      	ldr	r0, [pc, #28]	; (33b0 <z_impl_k_sem_give+0x3c>)
    3394:	f000 f892 	bl	34bc <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    3398:	bd70      	pop	{r4, r5, r6, pc}
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    339a:	68a3      	ldr	r3, [r4, #8]
    339c:	68e2      	ldr	r2, [r4, #12]
    339e:	4293      	cmp	r3, r2
    33a0:	d003      	beq.n	33aa <z_impl_k_sem_give+0x36>
    33a2:	2201      	movs	r2, #1
    33a4:	189b      	adds	r3, r3, r2
    33a6:	60a3      	str	r3, [r4, #8]
}
    33a8:	e7f2      	b.n	3390 <z_impl_k_sem_give+0x1c>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    33aa:	2200      	movs	r2, #0
    33ac:	e7fa      	b.n	33a4 <z_impl_k_sem_give+0x30>
    33ae:	46c0      	nop			; (mov r8, r8)
    33b0:	200002f0 	.word	0x200002f0

000033b4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    33b4:	b530      	push	{r4, r5, lr}
    33b6:	b083      	sub	sp, #12
    33b8:	f3ef 8110 	mrs	r1, PRIMASK
    33bc:	b672      	cpsid	i

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    33be:	6884      	ldr	r4, [r0, #8]
    33c0:	2c00      	cmp	r4, #0
    33c2:	d009      	beq.n	33d8 <z_impl_k_sem_take+0x24>
		sem->count--;
    33c4:	3c01      	subs	r4, #1
    33c6:	6084      	str	r4, [r0, #8]
	if (key != 0U) {
    33c8:	2900      	cmp	r1, #0
    33ca:	d102      	bne.n	33d2 <z_impl_k_sem_take+0x1e>
	__asm__ volatile(
    33cc:	b662      	cpsie	i
    33ce:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    33d2:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    33d4:	b003      	add	sp, #12
    33d6:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    33d8:	001c      	movs	r4, r3
    33da:	4314      	orrs	r4, r2
    33dc:	d006      	beq.n	33ec <z_impl_k_sem_take+0x38>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    33de:	9200      	str	r2, [sp, #0]
    33e0:	9301      	str	r3, [sp, #4]
    33e2:	0002      	movs	r2, r0
    33e4:	4805      	ldr	r0, [pc, #20]	; (33fc <z_impl_k_sem_take+0x48>)
    33e6:	f000 f9cf 	bl	3788 <z_pend_curr>
	return ret;
    33ea:	e7f3      	b.n	33d4 <z_impl_k_sem_take+0x20>
	if (key != 0U) {
    33ec:	2900      	cmp	r1, #0
    33ee:	d102      	bne.n	33f6 <z_impl_k_sem_take+0x42>
	__asm__ volatile(
    33f0:	b662      	cpsie	i
    33f2:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    33f6:	2010      	movs	r0, #16
    33f8:	4240      	negs	r0, r0
    33fa:	e7eb      	b.n	33d4 <z_impl_k_sem_take+0x20>
    33fc:	200002f0 	.word	0x200002f0

00003400 <add_thread_timeout>:
		z_priq_wait_add(&wait_q->waitq, thread);
	}
}

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
    3400:	b510      	push	{r4, lr}
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    3402:	0019      	movs	r1, r3
    3404:	1c54      	adds	r4, r2, #1
    3406:	d101      	bne.n	340c <add_thread_timeout+0xc>
    3408:	3101      	adds	r1, #1
    340a:	d003      	beq.n	3414 <add_thread_timeout+0x14>
    340c:	3018      	adds	r0, #24
    340e:	4902      	ldr	r1, [pc, #8]	; (3418 <add_thread_timeout+0x18>)
    3410:	f000 fbcc 	bl	3bac <z_add_timeout>
		z_add_thread_timeout(thread, timeout);
	}
}
    3414:	bd10      	pop	{r4, pc}
    3416:	46c0      	nop			; (mov r8, r8)
    3418:	00004b4d 	.word	0x00004b4d

0000341c <z_reset_time_slice>:
{
    341c:	b510      	push	{r4, lr}
	if (slice_time != 0) {
    341e:	4b08      	ldr	r3, [pc, #32]	; (3440 <z_reset_time_slice+0x24>)
    3420:	681b      	ldr	r3, [r3, #0]
    3422:	2b00      	cmp	r3, #0
    3424:	d100      	bne.n	3428 <z_reset_time_slice+0xc>
}
    3426:	bd10      	pop	{r4, pc}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    3428:	f7ff fb64 	bl	2af4 <sys_clock_elapsed>
    342c:	0003      	movs	r3, r0
    342e:	4a04      	ldr	r2, [pc, #16]	; (3440 <z_reset_time_slice+0x24>)
    3430:	6810      	ldr	r0, [r2, #0]
    3432:	18c3      	adds	r3, r0, r3
    3434:	4a03      	ldr	r2, [pc, #12]	; (3444 <z_reset_time_slice+0x28>)
    3436:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    3438:	2100      	movs	r1, #0
    343a:	f001 fc77 	bl	4d2c <z_set_timeout_expiry>
}
    343e:	e7f2      	b.n	3426 <z_reset_time_slice+0xa>
    3440:	200002f8 	.word	0x200002f8
    3444:	200002c4 	.word	0x200002c4

00003448 <k_sched_time_slice_set>:
{
    3448:	b5f0      	push	{r4, r5, r6, r7, lr}
    344a:	46c6      	mov	lr, r8
    344c:	b500      	push	{lr}
    344e:	0006      	movs	r6, r0
    3450:	4688      	mov	r8, r1
	LOCKED(&sched_spinlock) {
    3452:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    3454:	f3ef 8710 	mrs	r7, PRIMASK
    3458:	b672      	cpsid	i
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    345a:	e00c      	b.n	3476 <k_sched_time_slice_set+0x2e>
			slice_time = MAX(2, slice_time);
    345c:	4b13      	ldr	r3, [pc, #76]	; (34ac <k_sched_time_slice_set+0x64>)
    345e:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    3460:	4b13      	ldr	r3, [pc, #76]	; (34b0 <k_sched_time_slice_set+0x68>)
    3462:	4642      	mov	r2, r8
    3464:	601a      	str	r2, [r3, #0]
		z_reset_time_slice();
    3466:	f7ff ffd9 	bl	341c <z_reset_time_slice>
	if (key != 0U) {
    346a:	2f00      	cmp	r7, #0
    346c:	d102      	bne.n	3474 <k_sched_time_slice_set+0x2c>
	__asm__ volatile(
    346e:	b662      	cpsie	i
    3470:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    3474:	2301      	movs	r3, #1
    3476:	2b00      	cmp	r3, #0
    3478:	d115      	bne.n	34a6 <k_sched_time_slice_set+0x5e>
		_current_cpu->slice_ticks = 0;
    347a:	4b0e      	ldr	r3, [pc, #56]	; (34b4 <k_sched_time_slice_set+0x6c>)
    347c:	2200      	movs	r2, #0
    347e:	611a      	str	r2, [r3, #16]
			return (uint32_t)((t * to_hz + off) / from_hz);
    3480:	0c75      	lsrs	r5, r6, #17
    3482:	03f4      	lsls	r4, r6, #15
    3484:	480c      	ldr	r0, [pc, #48]	; (34b8 <k_sched_time_slice_set+0x70>)
    3486:	2100      	movs	r1, #0
    3488:	1900      	adds	r0, r0, r4
    348a:	4169      	adcs	r1, r5
    348c:	22fa      	movs	r2, #250	; 0xfa
    348e:	0092      	lsls	r2, r2, #2
    3490:	2300      	movs	r3, #0
    3492:	f7fc fe29 	bl	e8 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    3496:	4b05      	ldr	r3, [pc, #20]	; (34ac <k_sched_time_slice_set+0x64>)
    3498:	6018      	str	r0, [r3, #0]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    349a:	2e00      	cmp	r6, #0
    349c:	dde0      	ble.n	3460 <k_sched_time_slice_set+0x18>
			slice_time = MAX(2, slice_time);
    349e:	2802      	cmp	r0, #2
    34a0:	dadc      	bge.n	345c <k_sched_time_slice_set+0x14>
    34a2:	2002      	movs	r0, #2
    34a4:	e7da      	b.n	345c <k_sched_time_slice_set+0x14>
}
    34a6:	bc04      	pop	{r2}
    34a8:	4690      	mov	r8, r2
    34aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    34ac:	200002f8 	.word	0x200002f8
    34b0:	200002f4 	.word	0x200002f4
    34b4:	200002c4 	.word	0x200002c4
    34b8:	000003e7 	.word	0x000003e7

000034bc <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    34bc:	b510      	push	{r4, lr}
    34be:	1e08      	subs	r0, r1, #0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    34c0:	d105      	bne.n	34ce <z_reschedule+0x12>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    34c2:	f3ef 8305 	mrs	r3, IPSR
    34c6:	2b00      	cmp	r3, #0
    34c8:	d10c      	bne.n	34e4 <z_reschedule+0x28>
    34ca:	3301      	adds	r3, #1
    34cc:	e000      	b.n	34d0 <z_reschedule+0x14>
    34ce:	2300      	movs	r3, #0
	if (resched(key.key) && need_swap()) {
    34d0:	07db      	lsls	r3, r3, #31
    34d2:	d509      	bpl.n	34e8 <z_reschedule+0x2c>
	new_thread = _kernel.ready_q.cache;
    34d4:	4b07      	ldr	r3, [pc, #28]	; (34f4 <z_reschedule+0x38>)
    34d6:	69da      	ldr	r2, [r3, #28]
	return new_thread != _current;
    34d8:	689b      	ldr	r3, [r3, #8]
	if (resched(key.key) && need_swap()) {
    34da:	429a      	cmp	r2, r3
    34dc:	d004      	beq.n	34e8 <z_reschedule+0x2c>
	ret = arch_swap(key);
    34de:	f7fd ffb7 	bl	1450 <arch_swap>
		z_swap(lock, key);
    34e2:	e006      	b.n	34f2 <z_reschedule+0x36>
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    34e4:	000b      	movs	r3, r1
    34e6:	e7f3      	b.n	34d0 <z_reschedule+0x14>
	if (key != 0U) {
    34e8:	2800      	cmp	r0, #0
    34ea:	d102      	bne.n	34f2 <z_reschedule+0x36>
	__asm__ volatile(
    34ec:	b662      	cpsie	i
    34ee:	f3bf 8f6f 	isb	sy
	} else {
		k_spin_unlock(lock, key);
	}
}
    34f2:	bd10      	pop	{r4, pc}
    34f4:	200002c4 	.word	0x200002c4

000034f8 <k_sched_lock>:
	}
}

void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
    34f8:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    34fa:	f3ef 8110 	mrs	r1, PRIMASK
    34fe:	b672      	cpsid	i
    3500:	e003      	b.n	350a <k_sched_lock+0x12>
	__asm__ volatile(
    3502:	b662      	cpsie	i
    3504:	f3bf 8f6f 	isb	sy
    3508:	2301      	movs	r3, #1
    350a:	2b00      	cmp	r3, #0
    350c:	d107      	bne.n	351e <k_sched_lock+0x26>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    350e:	4b04      	ldr	r3, [pc, #16]	; (3520 <k_sched_lock+0x28>)
    3510:	689a      	ldr	r2, [r3, #8]
    3512:	7bd3      	ldrb	r3, [r2, #15]
    3514:	3b01      	subs	r3, #1
    3516:	73d3      	strb	r3, [r2, #15]
	if (key != 0U) {
    3518:	2900      	cmp	r1, #0
    351a:	d0f2      	beq.n	3502 <k_sched_lock+0xa>
    351c:	e7f4      	b.n	3508 <k_sched_lock+0x10>
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    351e:	4770      	bx	lr
    3520:	200002c4 	.word	0x200002c4

00003524 <update_cache>:
{
    3524:	b570      	push	{r4, r5, r6, lr}
    3526:	0005      	movs	r5, r0
	thread = _priq_run_best(&_kernel.ready_q.runq);
    3528:	4810      	ldr	r0, [pc, #64]	; (356c <update_cache+0x48>)
    352a:	f001 faee 	bl	4b0a <z_priq_dumb_best>
    352e:	1e04      	subs	r4, r0, #0
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    3530:	d00f      	beq.n	3552 <update_cache+0x2e>
	if (preempt_ok != 0) {
    3532:	2d00      	cmp	r5, #0
    3534:	d110      	bne.n	3558 <update_cache+0x34>
	if (z_is_thread_prevented_from_running(_current)) {
    3536:	4b0e      	ldr	r3, [pc, #56]	; (3570 <update_cache+0x4c>)
    3538:	689b      	ldr	r3, [r3, #8]
	uint8_t state = thread->base.thread_state;
    353a:	7b5a      	ldrb	r2, [r3, #13]
    353c:	06d2      	lsls	r2, r2, #27
    353e:	d10b      	bne.n	3558 <update_cache+0x34>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    3540:	69a2      	ldr	r2, [r4, #24]
    3542:	2a00      	cmp	r2, #0
    3544:	d108      	bne.n	3558 <update_cache+0x34>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    3546:	89da      	ldrh	r2, [r3, #14]
	if (is_preempt(_current) || is_metairq(thread)) {
    3548:	2a7f      	cmp	r2, #127	; 0x7f
    354a:	d905      	bls.n	3558 <update_cache+0x34>
		_kernel.ready_q.cache = _current;
    354c:	4a08      	ldr	r2, [pc, #32]	; (3570 <update_cache+0x4c>)
    354e:	61d3      	str	r3, [r2, #28]
    3550:	e00a      	b.n	3568 <update_cache+0x44>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    3552:	4b07      	ldr	r3, [pc, #28]	; (3570 <update_cache+0x4c>)
    3554:	68dc      	ldr	r4, [r3, #12]
    3556:	e7ec      	b.n	3532 <update_cache+0xe>
		if (thread != _current) {
    3558:	4b05      	ldr	r3, [pc, #20]	; (3570 <update_cache+0x4c>)
    355a:	689b      	ldr	r3, [r3, #8]
    355c:	42a3      	cmp	r3, r4
    355e:	d001      	beq.n	3564 <update_cache+0x40>
			z_reset_time_slice();
    3560:	f7ff ff5c 	bl	341c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    3564:	4b02      	ldr	r3, [pc, #8]	; (3570 <update_cache+0x4c>)
    3566:	61dc      	str	r4, [r3, #28]
}
    3568:	bd70      	pop	{r4, r5, r6, pc}
    356a:	46c0      	nop			; (mov r8, r8)
    356c:	200002e4 	.word	0x200002e4
    3570:	200002c4 	.word	0x200002c4

00003574 <move_thread_to_end_of_prio_q>:
{
    3574:	b570      	push	{r4, r5, r6, lr}
    3576:	0005      	movs	r5, r0
	return (thread->base.thread_state & state) != 0U;
    3578:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    357a:	230d      	movs	r3, #13
    357c:	56c3      	ldrsb	r3, [r0, r3]
    357e:	2b00      	cmp	r3, #0
    3580:	db2a      	blt.n	35d8 <move_thread_to_end_of_prio_q+0x64>
	thread->base.thread_state |= _THREAD_QUEUED;
    3582:	7b6a      	ldrb	r2, [r5, #13]
    3584:	2380      	movs	r3, #128	; 0x80
    3586:	425b      	negs	r3, r3
    3588:	4313      	orrs	r3, r2
    358a:	736b      	strb	r3, [r5, #13]
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    358c:	4b1a      	ldr	r3, [pc, #104]	; (35f8 <move_thread_to_end_of_prio_q+0x84>)
    358e:	6a1c      	ldr	r4, [r3, #32]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    3590:	3320      	adds	r3, #32
    3592:	429c      	cmp	r4, r3
    3594:	d02e      	beq.n	35f4 <move_thread_to_end_of_prio_q+0x80>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    3596:	2c00      	cmp	r4, #0
    3598:	d00e      	beq.n	35b8 <move_thread_to_end_of_prio_q+0x44>
		if (z_sched_prio_cmp(thread, t) > 0) {
    359a:	0021      	movs	r1, r4
    359c:	0028      	movs	r0, r5
    359e:	f001 fa8b 	bl	4ab8 <z_sched_prio_cmp>
    35a2:	2800      	cmp	r0, #0
    35a4:	dc20      	bgt.n	35e8 <move_thread_to_end_of_prio_q+0x74>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    35a6:	2c00      	cmp	r4, #0
    35a8:	d006      	beq.n	35b8 <move_thread_to_end_of_prio_q+0x44>
	return (node == list->tail) ? NULL : node->next;
    35aa:	4a13      	ldr	r2, [pc, #76]	; (35f8 <move_thread_to_end_of_prio_q+0x84>)
    35ac:	6a52      	ldr	r2, [r2, #36]	; 0x24
    35ae:	4294      	cmp	r4, r2
    35b0:	d002      	beq.n	35b8 <move_thread_to_end_of_prio_q+0x44>
    35b2:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    35b4:	2c00      	cmp	r4, #0
    35b6:	d1ee      	bne.n	3596 <move_thread_to_end_of_prio_q+0x22>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;
    35b8:	4b0f      	ldr	r3, [pc, #60]	; (35f8 <move_thread_to_end_of_prio_q+0x84>)
    35ba:	6a5a      	ldr	r2, [r3, #36]	; 0x24

	node->next = list;
    35bc:	0019      	movs	r1, r3
    35be:	3120      	adds	r1, #32
    35c0:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    35c2:	606a      	str	r2, [r5, #4]

	tail->next = node;
    35c4:	6015      	str	r5, [r2, #0]
	list->tail = node;
    35c6:	625d      	str	r5, [r3, #36]	; 0x24
	update_cache(thread == _current);
    35c8:	4b0b      	ldr	r3, [pc, #44]	; (35f8 <move_thread_to_end_of_prio_q+0x84>)
    35ca:	6898      	ldr	r0, [r3, #8]
    35cc:	1b40      	subs	r0, r0, r5
    35ce:	4245      	negs	r5, r0
    35d0:	4168      	adcs	r0, r5
    35d2:	f7ff ffa7 	bl	3524 <update_cache>
}
    35d6:	bd70      	pop	{r4, r5, r6, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    35d8:	237f      	movs	r3, #127	; 0x7f
    35da:	401a      	ands	r2, r3
    35dc:	7342      	strb	r2, [r0, #13]
		_priq_run_remove(pq, thread);
    35de:	0001      	movs	r1, r0
    35e0:	4806      	ldr	r0, [pc, #24]	; (35fc <move_thread_to_end_of_prio_q+0x88>)
    35e2:	f001 fa8a 	bl	4afa <z_priq_dumb_remove>
}
    35e6:	e7cc      	b.n	3582 <move_thread_to_end_of_prio_q+0xe>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
    35e8:	6863      	ldr	r3, [r4, #4]

	node->prev = prev;
    35ea:	606b      	str	r3, [r5, #4]
	node->next = successor;
    35ec:	602c      	str	r4, [r5, #0]
	prev->next = node;
    35ee:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    35f0:	6065      	str	r5, [r4, #4]
}
    35f2:	e7e9      	b.n	35c8 <move_thread_to_end_of_prio_q+0x54>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    35f4:	2400      	movs	r4, #0
    35f6:	e7ce      	b.n	3596 <move_thread_to_end_of_prio_q+0x22>
    35f8:	200002c4 	.word	0x200002c4
    35fc:	200002e4 	.word	0x200002e4

00003600 <z_time_slice>:
{
    3600:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    3602:	f3ef 8410 	mrs	r4, PRIMASK
    3606:	b672      	cpsid	i
	if (pending_current == _current) {
    3608:	4b1d      	ldr	r3, [pc, #116]	; (3680 <z_time_slice+0x80>)
    360a:	689b      	ldr	r3, [r3, #8]
    360c:	4a1d      	ldr	r2, [pc, #116]	; (3684 <z_time_slice+0x84>)
    360e:	6812      	ldr	r2, [r2, #0]
    3610:	4293      	cmp	r3, r2
    3612:	d01d      	beq.n	3650 <z_time_slice+0x50>
	pending_current = NULL;
    3614:	4a1b      	ldr	r2, [pc, #108]	; (3684 <z_time_slice+0x84>)
    3616:	2100      	movs	r1, #0
    3618:	6011      	str	r1, [r2, #0]
	if (slice_time && sliceable(_current)) {
    361a:	4a1b      	ldr	r2, [pc, #108]	; (3688 <z_time_slice+0x88>)
    361c:	6812      	ldr	r2, [r2, #0]
    361e:	2a00      	cmp	r2, #0
    3620:	d024      	beq.n	366c <z_time_slice+0x6c>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    3622:	89da      	ldrh	r2, [r3, #14]
		&& !z_is_idle_thread_object(thread);
    3624:	2a7f      	cmp	r2, #127	; 0x7f
    3626:	d821      	bhi.n	366c <z_time_slice+0x6c>
	uint8_t state = thread->base.thread_state;
    3628:	7b5a      	ldrb	r2, [r3, #13]
		&& !z_is_thread_prevented_from_running(thread)
    362a:	06d2      	lsls	r2, r2, #27
    362c:	d11e      	bne.n	366c <z_time_slice+0x6c>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    362e:	210e      	movs	r1, #14
    3630:	5659      	ldrsb	r1, [r3, r1]
    3632:	4a16      	ldr	r2, [pc, #88]	; (368c <z_time_slice+0x8c>)
    3634:	6812      	ldr	r2, [r2, #0]
    3636:	4291      	cmp	r1, r2
    3638:	db18      	blt.n	366c <z_time_slice+0x6c>
		&& !z_is_idle_thread_object(thread);
    363a:	4a15      	ldr	r2, [pc, #84]	; (3690 <z_time_slice+0x90>)
    363c:	4293      	cmp	r3, r2
    363e:	d015      	beq.n	366c <z_time_slice+0x6c>
		if (ticks >= _current_cpu->slice_ticks) {
    3640:	4a0f      	ldr	r2, [pc, #60]	; (3680 <z_time_slice+0x80>)
    3642:	6912      	ldr	r2, [r2, #16]
    3644:	4282      	cmp	r2, r0
    3646:	dd0b      	ble.n	3660 <z_time_slice+0x60>
			_current_cpu->slice_ticks -= ticks;
    3648:	1a10      	subs	r0, r2, r0
    364a:	4b0d      	ldr	r3, [pc, #52]	; (3680 <z_time_slice+0x80>)
    364c:	6118      	str	r0, [r3, #16]
    364e:	e010      	b.n	3672 <z_time_slice+0x72>
		z_reset_time_slice();
    3650:	f7ff fee4 	bl	341c <z_reset_time_slice>
	if (key != 0U) {
    3654:	2c00      	cmp	r4, #0
    3656:	d111      	bne.n	367c <z_time_slice+0x7c>
	__asm__ volatile(
    3658:	b662      	cpsie	i
    365a:	f3bf 8f6f 	isb	sy
		return;
    365e:	e00d      	b.n	367c <z_time_slice+0x7c>
			move_thread_to_end_of_prio_q(_current);
    3660:	0018      	movs	r0, r3
    3662:	f7ff ff87 	bl	3574 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    3666:	f7ff fed9 	bl	341c <z_reset_time_slice>
    366a:	e002      	b.n	3672 <z_time_slice+0x72>
		_current_cpu->slice_ticks = 0;
    366c:	4b04      	ldr	r3, [pc, #16]	; (3680 <z_time_slice+0x80>)
    366e:	2200      	movs	r2, #0
    3670:	611a      	str	r2, [r3, #16]
	if (key != 0U) {
    3672:	2c00      	cmp	r4, #0
    3674:	d102      	bne.n	367c <z_time_slice+0x7c>
	__asm__ volatile(
    3676:	b662      	cpsie	i
    3678:	f3bf 8f6f 	isb	sy
}
    367c:	bd10      	pop	{r4, pc}
    367e:	46c0      	nop			; (mov r8, r8)
    3680:	200002c4 	.word	0x200002c4
    3684:	200002f0 	.word	0x200002f0
    3688:	200002f8 	.word	0x200002f8
    368c:	200002f4 	.word	0x200002f4
    3690:	20000058 	.word	0x20000058

00003694 <ready_thread>:
{
    3694:	b570      	push	{r4, r5, r6, lr}
    3696:	0004      	movs	r4, r0
	return (thread->base.thread_state & state) != 0U;
    3698:	7b42      	ldrb	r2, [r0, #13]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    369a:	230d      	movs	r3, #13
    369c:	56c3      	ldrsb	r3, [r0, r3]
    369e:	2b00      	cmp	r3, #0
    36a0:	db30      	blt.n	3704 <ready_thread+0x70>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    36a2:	06d3      	lsls	r3, r2, #27
    36a4:	d106      	bne.n	36b4 <ready_thread+0x20>
    36a6:	6983      	ldr	r3, [r0, #24]
    36a8:	2b00      	cmp	r3, #0
    36aa:	d001      	beq.n	36b0 <ready_thread+0x1c>
    36ac:	2300      	movs	r3, #0
    36ae:	e002      	b.n	36b6 <ready_thread+0x22>
    36b0:	3301      	adds	r3, #1
    36b2:	e000      	b.n	36b6 <ready_thread+0x22>
    36b4:	2300      	movs	r3, #0
    36b6:	2b00      	cmp	r3, #0
    36b8:	d024      	beq.n	3704 <ready_thread+0x70>
	thread->base.thread_state |= _THREAD_QUEUED;
    36ba:	2380      	movs	r3, #128	; 0x80
    36bc:	425b      	negs	r3, r3
    36be:	431a      	orrs	r2, r3
    36c0:	7362      	strb	r2, [r4, #13]
	return list->head == list;
    36c2:	4b15      	ldr	r3, [pc, #84]	; (3718 <ready_thread+0x84>)
    36c4:	6a1d      	ldr	r5, [r3, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    36c6:	3320      	adds	r3, #32
    36c8:	429d      	cmp	r5, r3
    36ca:	d022      	beq.n	3712 <ready_thread+0x7e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    36cc:	2d00      	cmp	r5, #0
    36ce:	d00e      	beq.n	36ee <ready_thread+0x5a>
		if (z_sched_prio_cmp(thread, t) > 0) {
    36d0:	0029      	movs	r1, r5
    36d2:	0020      	movs	r0, r4
    36d4:	f001 f9f0 	bl	4ab8 <z_sched_prio_cmp>
    36d8:	2800      	cmp	r0, #0
    36da:	dc14      	bgt.n	3706 <ready_thread+0x72>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    36dc:	2d00      	cmp	r5, #0
    36de:	d006      	beq.n	36ee <ready_thread+0x5a>
	return (node == list->tail) ? NULL : node->next;
    36e0:	4a0d      	ldr	r2, [pc, #52]	; (3718 <ready_thread+0x84>)
    36e2:	6a52      	ldr	r2, [r2, #36]	; 0x24
    36e4:	4295      	cmp	r5, r2
    36e6:	d002      	beq.n	36ee <ready_thread+0x5a>
    36e8:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    36ea:	2d00      	cmp	r5, #0
    36ec:	d1ee      	bne.n	36cc <ready_thread+0x38>
	sys_dnode_t *const tail = list->tail;
    36ee:	4b0a      	ldr	r3, [pc, #40]	; (3718 <ready_thread+0x84>)
    36f0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
    36f2:	0019      	movs	r1, r3
    36f4:	3120      	adds	r1, #32
    36f6:	6021      	str	r1, [r4, #0]
	node->prev = tail;
    36f8:	6062      	str	r2, [r4, #4]
	tail->next = node;
    36fa:	6014      	str	r4, [r2, #0]
	list->tail = node;
    36fc:	625c      	str	r4, [r3, #36]	; 0x24
		update_cache(0);
    36fe:	2000      	movs	r0, #0
    3700:	f7ff ff10 	bl	3524 <update_cache>
}
    3704:	bd70      	pop	{r4, r5, r6, pc}
	sys_dnode_t *const prev = successor->prev;
    3706:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
    3708:	6063      	str	r3, [r4, #4]
	node->next = successor;
    370a:	6025      	str	r5, [r4, #0]
	prev->next = node;
    370c:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    370e:	606c      	str	r4, [r5, #4]
}
    3710:	e7f5      	b.n	36fe <ready_thread+0x6a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    3712:	2500      	movs	r5, #0
    3714:	e7da      	b.n	36cc <ready_thread+0x38>
    3716:	46c0      	nop			; (mov r8, r8)
    3718:	200002c4 	.word	0x200002c4

0000371c <z_sched_start>:
{
    371c:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    371e:	f3ef 8410 	mrs	r4, PRIMASK
    3722:	b672      	cpsid	i
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    3724:	7b43      	ldrb	r3, [r0, #13]
	if (z_has_thread_started(thread)) {
    3726:	0759      	lsls	r1, r3, #29
    3728:	d405      	bmi.n	3736 <z_sched_start+0x1a>
	if (key != 0U) {
    372a:	2c00      	cmp	r4, #0
    372c:	d10c      	bne.n	3748 <z_sched_start+0x2c>
	__asm__ volatile(
    372e:	b662      	cpsie	i
    3730:	f3bf 8f6f 	isb	sy
		return;
    3734:	e008      	b.n	3748 <z_sched_start+0x2c>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    3736:	2204      	movs	r2, #4
    3738:	4393      	bics	r3, r2
    373a:	7343      	strb	r3, [r0, #13]
	ready_thread(thread);
    373c:	f7ff ffaa 	bl	3694 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    3740:	0021      	movs	r1, r4
    3742:	4802      	ldr	r0, [pc, #8]	; (374c <z_sched_start+0x30>)
    3744:	f7ff feba 	bl	34bc <z_reschedule>
}
    3748:	bd10      	pop	{r4, pc}
    374a:	46c0      	nop			; (mov r8, r8)
    374c:	200002f4 	.word	0x200002f4

00003750 <unready_thread>:
{
    3750:	b510      	push	{r4, lr}
    3752:	0004      	movs	r4, r0
	return (thread->base.thread_state & state) != 0U;
    3754:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    3756:	230d      	movs	r3, #13
    3758:	56c3      	ldrsb	r3, [r0, r3]
    375a:	2b00      	cmp	r3, #0
    375c:	db07      	blt.n	376e <unready_thread+0x1e>
	update_cache(thread == _current);
    375e:	4b08      	ldr	r3, [pc, #32]	; (3780 <unready_thread+0x30>)
    3760:	6898      	ldr	r0, [r3, #8]
    3762:	1b00      	subs	r0, r0, r4
    3764:	4244      	negs	r4, r0
    3766:	4160      	adcs	r0, r4
    3768:	f7ff fedc 	bl	3524 <update_cache>
}
    376c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    376e:	237f      	movs	r3, #127	; 0x7f
    3770:	401a      	ands	r2, r3
    3772:	7342      	strb	r2, [r0, #13]
		_priq_run_remove(pq, thread);
    3774:	0001      	movs	r1, r0
    3776:	4803      	ldr	r0, [pc, #12]	; (3784 <unready_thread+0x34>)
    3778:	f001 f9bf 	bl	4afa <z_priq_dumb_remove>
}
    377c:	e7ef      	b.n	375e <unready_thread+0xe>
    377e:	46c0      	nop			; (mov r8, r8)
    3780:	200002c4 	.word	0x200002c4
    3784:	200002e4 	.word	0x200002e4

00003788 <z_pend_curr>:
{
    3788:	b510      	push	{r4, lr}
    378a:	000c      	movs	r4, r1
    378c:	0011      	movs	r1, r2
	pending_current = _current;
    378e:	4b06      	ldr	r3, [pc, #24]	; (37a8 <z_pend_curr+0x20>)
    3790:	6898      	ldr	r0, [r3, #8]
    3792:	4b06      	ldr	r3, [pc, #24]	; (37ac <z_pend_curr+0x24>)
    3794:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
    3796:	9a02      	ldr	r2, [sp, #8]
    3798:	9b03      	ldr	r3, [sp, #12]
    379a:	f001 fa39 	bl	4c10 <pend>
    379e:	0020      	movs	r0, r4
    37a0:	f7fd fe56 	bl	1450 <arch_swap>
}
    37a4:	bd10      	pop	{r4, pc}
    37a6:	46c0      	nop			; (mov r8, r8)
    37a8:	200002c4 	.word	0x200002c4
    37ac:	200002f0 	.word	0x200002f0

000037b0 <z_impl_k_thread_suspend>:
{
    37b0:	b570      	push	{r4, r5, r6, lr}
    37b2:	0004      	movs	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    37b4:	3018      	adds	r0, #24
    37b6:	f001 fa8b 	bl	4cd0 <z_abort_timeout>
	LOCKED(&sched_spinlock) {
    37ba:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    37bc:	f3ef 8510 	mrs	r5, PRIMASK
    37c0:	b672      	cpsid	i
    37c2:	e00b      	b.n	37dc <z_impl_k_thread_suspend+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    37c4:	237f      	movs	r3, #127	; 0x7f
    37c6:	401a      	ands	r2, r3
    37c8:	7362      	strb	r2, [r4, #13]
		_priq_run_remove(pq, thread);
    37ca:	0021      	movs	r1, r4
    37cc:	4813      	ldr	r0, [pc, #76]	; (381c <z_impl_k_thread_suspend+0x6c>)
    37ce:	f001 f994 	bl	4afa <z_priq_dumb_remove>
}
    37d2:	e00a      	b.n	37ea <z_impl_k_thread_suspend+0x3a>
	__asm__ volatile(
    37d4:	b662      	cpsie	i
    37d6:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    37da:	2301      	movs	r3, #1
    37dc:	2b00      	cmp	r3, #0
    37de:	d112      	bne.n	3806 <z_impl_k_thread_suspend+0x56>
    37e0:	7b62      	ldrb	r2, [r4, #13]
		if (z_is_thread_queued(thread)) {
    37e2:	230d      	movs	r3, #13
    37e4:	56e3      	ldrsb	r3, [r4, r3]
    37e6:	2b00      	cmp	r3, #0
    37e8:	dbec      	blt.n	37c4 <z_impl_k_thread_suspend+0x14>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    37ea:	7b63      	ldrb	r3, [r4, #13]
    37ec:	2210      	movs	r2, #16
    37ee:	4313      	orrs	r3, r2
    37f0:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    37f2:	4b0b      	ldr	r3, [pc, #44]	; (3820 <z_impl_k_thread_suspend+0x70>)
    37f4:	6898      	ldr	r0, [r3, #8]
    37f6:	1b00      	subs	r0, r0, r4
    37f8:	4243      	negs	r3, r0
    37fa:	4158      	adcs	r0, r3
    37fc:	f7ff fe92 	bl	3524 <update_cache>
	if (key != 0U) {
    3800:	2d00      	cmp	r5, #0
    3802:	d0e7      	beq.n	37d4 <z_impl_k_thread_suspend+0x24>
    3804:	e7e9      	b.n	37da <z_impl_k_thread_suspend+0x2a>
	if (thread == _current) {
    3806:	4b06      	ldr	r3, [pc, #24]	; (3820 <z_impl_k_thread_suspend+0x70>)
    3808:	689b      	ldr	r3, [r3, #8]
    380a:	42a3      	cmp	r3, r4
    380c:	d000      	beq.n	3810 <z_impl_k_thread_suspend+0x60>
}
    380e:	bd70      	pop	{r4, r5, r6, pc}
	__asm__ volatile("mrs %0, PRIMASK;"
    3810:	f3ef 8010 	mrs	r0, PRIMASK
    3814:	b672      	cpsid	i
	(void) z_reschedule_irqlock(arch_irq_lock());
    3816:	f001 f959 	bl	4acc <z_reschedule_irqlock>
    381a:	e7f8      	b.n	380e <z_impl_k_thread_suspend+0x5e>
    381c:	200002e4 	.word	0x200002e4
    3820:	200002c4 	.word	0x200002c4

00003824 <k_sched_unlock>:

void k_sched_unlock(void)
{
    3824:	b510      	push	{r4, lr}
	LOCKED(&sched_spinlock) {
    3826:	2300      	movs	r3, #0
    3828:	f3ef 8410 	mrs	r4, PRIMASK
    382c:	b672      	cpsid	i
    382e:	e003      	b.n	3838 <k_sched_unlock+0x14>
	__asm__ volatile(
    3830:	b662      	cpsie	i
    3832:	f3bf 8f6f 	isb	sy
    3836:	2301      	movs	r3, #1
    3838:	2b00      	cmp	r3, #0
    383a:	d10a      	bne.n	3852 <k_sched_unlock+0x2e>
		__ASSERT(_current->base.sched_locked != 0U, "");
		__ASSERT(!arch_is_in_isr(), "");

		++_current->base.sched_locked;
    383c:	4b08      	ldr	r3, [pc, #32]	; (3860 <k_sched_unlock+0x3c>)
    383e:	689a      	ldr	r2, [r3, #8]
    3840:	7bd3      	ldrb	r3, [r2, #15]
    3842:	3301      	adds	r3, #1
    3844:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    3846:	2000      	movs	r0, #0
    3848:	f7ff fe6c 	bl	3524 <update_cache>
	if (key != 0U) {
    384c:	2c00      	cmp	r4, #0
    384e:	d0ef      	beq.n	3830 <k_sched_unlock+0xc>
    3850:	e7f1      	b.n	3836 <k_sched_unlock+0x12>
	__asm__ volatile("mrs %0, PRIMASK;"
    3852:	f3ef 8010 	mrs	r0, PRIMASK
    3856:	b672      	cpsid	i
    3858:	f001 f938 	bl	4acc <z_reschedule_irqlock>
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
}
    385c:	bd10      	pop	{r4, pc}
    385e:	46c0      	nop			; (mov r8, r8)
    3860:	200002c4 	.word	0x200002c4

00003864 <end_thread>:
#ifdef CONFIG_CMSIS_RTOS_V1
extern void z_thread_cmsis_status_mask_clear(struct k_thread *thread);
#endif

static void end_thread(struct k_thread *thread)
{
    3864:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3866:	0005      	movs	r5, r0
	/* We hold the lock, and the thread is known not to be running
	 * anywhere.
	 */
	if ((thread->base.thread_state & _THREAD_DEAD) == 0U) {
    3868:	7b43      	ldrb	r3, [r0, #13]
    386a:	071a      	lsls	r2, r3, #28
    386c:	d446      	bmi.n	38fc <end_thread+0x98>
		thread->base.thread_state |= _THREAD_DEAD;
    386e:	2208      	movs	r2, #8
    3870:	4313      	orrs	r3, r2
    3872:	b2db      	uxtb	r3, r3
		thread->base.thread_state &= ~_THREAD_ABORTING;
    3874:	2220      	movs	r2, #32
    3876:	4393      	bics	r3, r2
    3878:	7343      	strb	r3, [r0, #13]
		if (z_is_thread_queued(thread)) {
    387a:	b25a      	sxtb	r2, r3
    387c:	2a00      	cmp	r2, #0
    387e:	db15      	blt.n	38ac <end_thread+0x48>
			dequeue_thread(&_kernel.ready_q.runq, thread);
		}
		if (thread->base.pended_on != NULL) {
    3880:	68ab      	ldr	r3, [r5, #8]
    3882:	2b00      	cmp	r3, #0
    3884:	d00b      	beq.n	389e <end_thread+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    3886:	0028      	movs	r0, r5
    3888:	f001 f914 	bl	4ab4 <pended_on_thread>
    388c:	0029      	movs	r1, r5
    388e:	f001 f934 	bl	4afa <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    3892:	7b6b      	ldrb	r3, [r5, #13]
    3894:	2202      	movs	r2, #2
    3896:	4393      	bics	r3, r2
    3898:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
    389a:	2300      	movs	r3, #0
    389c:	60ab      	str	r3, [r5, #8]
    389e:	0028      	movs	r0, r5
    38a0:	3018      	adds	r0, #24
    38a2:	f001 fa15 	bl	4cd0 <z_abort_timeout>
			unpend_thread_no_timeout(thread);
		}
		(void)z_abort_thread_timeout(thread);
		unpend_all(&thread->join_queue);
    38a6:	002f      	movs	r7, r5
    38a8:	3758      	adds	r7, #88	; 0x58
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    38aa:	e01c      	b.n	38e6 <end_thread+0x82>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    38ac:	227f      	movs	r2, #127	; 0x7f
    38ae:	4013      	ands	r3, r2
    38b0:	7343      	strb	r3, [r0, #13]
		_priq_run_remove(pq, thread);
    38b2:	0001      	movs	r1, r0
    38b4:	4812      	ldr	r0, [pc, #72]	; (3900 <end_thread+0x9c>)
    38b6:	f001 f920 	bl	4afa <z_priq_dumb_remove>
}
    38ba:	e7e1      	b.n	3880 <end_thread+0x1c>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    38bc:	0020      	movs	r0, r4
    38be:	f001 f8f9 	bl	4ab4 <pended_on_thread>
    38c2:	0021      	movs	r1, r4
    38c4:	f001 f919 	bl	4afa <z_priq_dumb_remove>
    38c8:	7b63      	ldrb	r3, [r4, #13]
    38ca:	2202      	movs	r2, #2
    38cc:	4393      	bics	r3, r2
    38ce:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    38d0:	2600      	movs	r6, #0
    38d2:	60a6      	str	r6, [r4, #8]
    38d4:	0020      	movs	r0, r4
    38d6:	3018      	adds	r0, #24
    38d8:	f001 f9fa 	bl	4cd0 <z_abort_timeout>
    38dc:	23a0      	movs	r3, #160	; 0xa0
    38de:	50e6      	str	r6, [r4, r3]
		ready_thread(thread);
    38e0:	0020      	movs	r0, r4
    38e2:	f7ff fed7 	bl	3694 <ready_thread>
	return list->head == list;
    38e6:	683c      	ldr	r4, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    38e8:	42bc      	cmp	r4, r7
    38ea:	d001      	beq.n	38f0 <end_thread+0x8c>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    38ec:	2c00      	cmp	r4, #0
    38ee:	d1e5      	bne.n	38bc <end_thread+0x58>
		update_cache(1);
    38f0:	2001      	movs	r0, #1
    38f2:	f7ff fe17 	bl	3524 <update_cache>

		SYS_PORT_TRACING_FUNC(k_thread, sched_abort, thread);

		z_thread_monitor_exit(thread);
    38f6:	0028      	movs	r0, r5
    38f8:	f7ff fc60 	bl	31bc <z_thread_monitor_exit>
		z_thread_perms_all_clear(thread);
		z_object_uninit(thread->stack_obj);
		z_object_uninit(thread);
#endif
	}
}
    38fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    38fe:	46c0      	nop			; (mov r8, r8)
    3900:	200002e4 	.word	0x200002e4

00003904 <z_sched_init>:
{
    3904:	b510      	push	{r4, lr}
	list->head = (sys_dnode_t *)list;
    3906:	4b05      	ldr	r3, [pc, #20]	; (391c <z_sched_init+0x18>)
    3908:	001a      	movs	r2, r3
    390a:	3220      	adds	r2, #32
    390c:	621a      	str	r2, [r3, #32]
	list->tail = (sys_dnode_t *)list;
    390e:	625a      	str	r2, [r3, #36]	; 0x24
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    3910:	2100      	movs	r1, #0
    3912:	2000      	movs	r0, #0
    3914:	f7ff fd98 	bl	3448 <k_sched_time_slice_set>
}
    3918:	bd10      	pop	{r4, pc}
    391a:	46c0      	nop			; (mov r8, r8)
    391c:	200002c4 	.word	0x200002c4

00003920 <z_impl_k_yield>:
{
    3920:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3922:	f3ef 8610 	mrs	r6, PRIMASK
    3926:	b672      	cpsid	i
		dequeue_thread(&_kernel.ready_q.runq,
    3928:	4c1d      	ldr	r4, [pc, #116]	; (39a0 <z_impl_k_yield+0x80>)
    392a:	68a1      	ldr	r1, [r4, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    392c:	7b4a      	ldrb	r2, [r1, #13]
    392e:	237f      	movs	r3, #127	; 0x7f
    3930:	4013      	ands	r3, r2
    3932:	734b      	strb	r3, [r1, #13]
		_priq_run_remove(pq, thread);
    3934:	0027      	movs	r7, r4
    3936:	3720      	adds	r7, #32
    3938:	0038      	movs	r0, r7
    393a:	f001 f8de 	bl	4afa <z_priq_dumb_remove>
	queue_thread(&_kernel.ready_q.runq, _current);
    393e:	68a5      	ldr	r5, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    3940:	7b6a      	ldrb	r2, [r5, #13]
    3942:	2380      	movs	r3, #128	; 0x80
    3944:	425b      	negs	r3, r3
    3946:	4313      	orrs	r3, r2
    3948:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    394a:	6a24      	ldr	r4, [r4, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    394c:	42bc      	cmp	r4, r7
    394e:	d025      	beq.n	399c <z_impl_k_yield+0x7c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    3950:	2c00      	cmp	r4, #0
    3952:	d00e      	beq.n	3972 <z_impl_k_yield+0x52>
		if (z_sched_prio_cmp(thread, t) > 0) {
    3954:	0021      	movs	r1, r4
    3956:	0028      	movs	r0, r5
    3958:	f001 f8ae 	bl	4ab8 <z_sched_prio_cmp>
    395c:	2800      	cmp	r0, #0
    395e:	dc17      	bgt.n	3990 <z_impl_k_yield+0x70>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    3960:	2c00      	cmp	r4, #0
    3962:	d006      	beq.n	3972 <z_impl_k_yield+0x52>
	return (node == list->tail) ? NULL : node->next;
    3964:	4a0e      	ldr	r2, [pc, #56]	; (39a0 <z_impl_k_yield+0x80>)
    3966:	6a52      	ldr	r2, [r2, #36]	; 0x24
    3968:	4294      	cmp	r4, r2
    396a:	d002      	beq.n	3972 <z_impl_k_yield+0x52>
    396c:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    396e:	2c00      	cmp	r4, #0
    3970:	d1ee      	bne.n	3950 <z_impl_k_yield+0x30>
	sys_dnode_t *const tail = list->tail;
    3972:	4b0b      	ldr	r3, [pc, #44]	; (39a0 <z_impl_k_yield+0x80>)
    3974:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
    3976:	0019      	movs	r1, r3
    3978:	3120      	adds	r1, #32
    397a:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    397c:	606a      	str	r2, [r5, #4]
	tail->next = node;
    397e:	6015      	str	r5, [r2, #0]
	list->tail = node;
    3980:	625d      	str	r5, [r3, #36]	; 0x24
	update_cache(1);
    3982:	2001      	movs	r0, #1
    3984:	f7ff fdce 	bl	3524 <update_cache>
    3988:	0030      	movs	r0, r6
    398a:	f7fd fd61 	bl	1450 <arch_swap>
}
    398e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	sys_dnode_t *const prev = successor->prev;
    3990:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    3992:	606b      	str	r3, [r5, #4]
	node->next = successor;
    3994:	602c      	str	r4, [r5, #0]
	prev->next = node;
    3996:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    3998:	6065      	str	r5, [r4, #4]
}
    399a:	e7f2      	b.n	3982 <z_impl_k_yield+0x62>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    399c:	2400      	movs	r4, #0
    399e:	e7d7      	b.n	3950 <z_impl_k_yield+0x30>
    39a0:	200002c4 	.word	0x200002c4

000039a4 <z_tick_sleep>:
{
    39a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    39a6:	46c6      	mov	lr, r8
    39a8:	b500      	push	{lr}
    39aa:	0004      	movs	r4, r0
    39ac:	000d      	movs	r5, r1
	if (ticks == 0) {
    39ae:	0003      	movs	r3, r0
    39b0:	430b      	orrs	r3, r1
    39b2:	d031      	beq.n	3a18 <z_tick_sleep+0x74>
	if (Z_TICK_ABS(ticks) <= 0) {
    39b4:	2202      	movs	r2, #2
    39b6:	4252      	negs	r2, r2
    39b8:	17d3      	asrs	r3, r2, #31
    39ba:	1b12      	subs	r2, r2, r4
    39bc:	41ab      	sbcs	r3, r5
    39be:	2b00      	cmp	r3, #0
    39c0:	dd2e      	ble.n	3a20 <z_tick_sleep+0x7c>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    39c2:	2602      	movs	r6, #2
    39c4:	4276      	negs	r6, r6
    39c6:	1b36      	subs	r6, r6, r4
    39c8:	f3ef 8810 	mrs	r8, PRIMASK
    39cc:	b672      	cpsid	i
	pending_current = _current;
    39ce:	4f1a      	ldr	r7, [pc, #104]	; (3a38 <z_tick_sleep+0x94>)
    39d0:	4b1a      	ldr	r3, [pc, #104]	; (3a3c <z_tick_sleep+0x98>)
    39d2:	68ba      	ldr	r2, [r7, #8]
    39d4:	601a      	str	r2, [r3, #0]
	unready_thread(_current);
    39d6:	0010      	movs	r0, r2
    39d8:	f7ff feba 	bl	3750 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    39dc:	68b8      	ldr	r0, [r7, #8]
    39de:	3018      	adds	r0, #24
    39e0:	0022      	movs	r2, r4
    39e2:	002b      	movs	r3, r5
    39e4:	4916      	ldr	r1, [pc, #88]	; (3a40 <z_tick_sleep+0x9c>)
    39e6:	f000 f8e1 	bl	3bac <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    39ea:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    39ec:	7b53      	ldrb	r3, [r2, #13]
    39ee:	2110      	movs	r1, #16
    39f0:	430b      	orrs	r3, r1
    39f2:	7353      	strb	r3, [r2, #13]
    39f4:	4640      	mov	r0, r8
    39f6:	f7fd fd2b 	bl	1450 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    39fa:	0034      	movs	r4, r6
    39fc:	2500      	movs	r5, #0
    39fe:	f001 f9bc 	bl	4d7a <sys_clock_tick_get_32>
    3a02:	0002      	movs	r2, r0
    3a04:	2300      	movs	r3, #0
    3a06:	1aa4      	subs	r4, r4, r2
    3a08:	419d      	sbcs	r5, r3
	if (ticks > 0) {
    3a0a:	2d00      	cmp	r5, #0
    3a0c:	dc12      	bgt.n	3a34 <z_tick_sleep+0x90>
    3a0e:	d00f      	beq.n	3a30 <z_tick_sleep+0x8c>
	return 0;
    3a10:	2000      	movs	r0, #0
}
    3a12:	bc04      	pop	{r2}
    3a14:	4690      	mov	r8, r2
    3a16:	bdf0      	pop	{r4, r5, r6, r7, pc}
	z_impl_k_yield();
    3a18:	f7ff ff82 	bl	3920 <z_impl_k_yield>
		return 0;
    3a1c:	2000      	movs	r0, #0
    3a1e:	e7f8      	b.n	3a12 <z_tick_sleep+0x6e>
	if (Z_TICK_ABS(ticks) <= 0) {
    3a20:	2b00      	cmp	r3, #0
    3a22:	d101      	bne.n	3a28 <z_tick_sleep+0x84>
    3a24:	2a00      	cmp	r2, #0
    3a26:	d1cc      	bne.n	39c2 <z_tick_sleep+0x1e>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    3a28:	f001 f9a7 	bl	4d7a <sys_clock_tick_get_32>
    3a2c:	1906      	adds	r6, r0, r4
    3a2e:	e7cb      	b.n	39c8 <z_tick_sleep+0x24>
	if (ticks > 0) {
    3a30:	2c00      	cmp	r4, #0
    3a32:	d0ed      	beq.n	3a10 <z_tick_sleep+0x6c>
		return ticks;
    3a34:	0020      	movs	r0, r4
    3a36:	e7ec      	b.n	3a12 <z_tick_sleep+0x6e>
    3a38:	200002c4 	.word	0x200002c4
    3a3c:	200002f0 	.word	0x200002f0
    3a40:	00004b4d 	.word	0x00004b4d

00003a44 <z_impl_k_sleep>:
{
    3a44:	b510      	push	{r4, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    3a46:	000b      	movs	r3, r1
    3a48:	1c42      	adds	r2, r0, #1
    3a4a:	d00b      	beq.n	3a64 <z_impl_k_sleep+0x20>
	ticks = z_tick_sleep(ticks);
    3a4c:	f7ff ffaa 	bl	39a4 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    3a50:	17c1      	asrs	r1, r0, #31
			return (t * to_hz + off) / from_hz;
    3a52:	22fa      	movs	r2, #250	; 0xfa
    3a54:	0092      	lsls	r2, r2, #2
    3a56:	2300      	movs	r3, #0
    3a58:	f7fc fb66 	bl	128 <__aeabi_lmul>
    3a5c:	0449      	lsls	r1, r1, #17
    3a5e:	0bc0      	lsrs	r0, r0, #15
    3a60:	4308      	orrs	r0, r1
}
    3a62:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    3a64:	3301      	adds	r3, #1
    3a66:	d1f1      	bne.n	3a4c <z_impl_k_sleep+0x8>
		k_thread_suspend(_current);
    3a68:	4b03      	ldr	r3, [pc, #12]	; (3a78 <z_impl_k_sleep+0x34>)
    3a6a:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    3a6c:	f7ff fea0 	bl	37b0 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    3a70:	2001      	movs	r0, #1
    3a72:	4240      	negs	r0, r0
    3a74:	e7f5      	b.n	3a62 <z_impl_k_sleep+0x1e>
    3a76:	46c0      	nop			; (mov r8, r8)
    3a78:	200002c4 	.word	0x200002c4

00003a7c <z_impl_z_current_get>:
	k_tid_t ret = _current_cpu->current;
    3a7c:	4b01      	ldr	r3, [pc, #4]	; (3a84 <z_impl_z_current_get+0x8>)
    3a7e:	6898      	ldr	r0, [r3, #8]
}
    3a80:	4770      	bx	lr
    3a82:	46c0      	nop			; (mov r8, r8)
    3a84:	200002c4 	.word	0x200002c4

00003a88 <z_thread_abort>:

void z_thread_abort(struct k_thread *thread)
{
    3a88:	b570      	push	{r4, r5, r6, lr}
    3a8a:	0004      	movs	r4, r0
    3a8c:	f3ef 8510 	mrs	r5, PRIMASK
    3a90:	b672      	cpsid	i
	k.key = arch_irq_lock();
    3a92:	002e      	movs	r6, r5
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    3a94:	7b43      	ldrb	r3, [r0, #13]
    3a96:	071b      	lsls	r3, r3, #28
    3a98:	d505      	bpl.n	3aa6 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xe>
	if (key != 0U) {
    3a9a:	2d00      	cmp	r5, #0
    3a9c:	d102      	bne.n	3aa4 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xc>
	__asm__ volatile(
    3a9e:	b662      	cpsie	i
    3aa0:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    3aa4:	bd70      	pop	{r4, r5, r6, pc}
	end_thread(thread);
    3aa6:	f7ff fedd 	bl	3864 <end_thread>
	if (thread == _current && !arch_is_in_isr()) {
    3aaa:	4b09      	ldr	r3, [pc, #36]	; (3ad0 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x38>)
    3aac:	689b      	ldr	r3, [r3, #8]
    3aae:	42a3      	cmp	r3, r4
    3ab0:	d005      	beq.n	3abe <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x26>
	if (key != 0U) {
    3ab2:	2e00      	cmp	r6, #0
    3ab4:	d1f6      	bne.n	3aa4 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xc>
	__asm__ volatile(
    3ab6:	b662      	cpsie	i
    3ab8:	f3bf 8f6f 	isb	sy
    3abc:	e7f2      	b.n	3aa4 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xc>
    3abe:	f3ef 8305 	mrs	r3, IPSR
    3ac2:	2b00      	cmp	r3, #0
    3ac4:	d1f5      	bne.n	3ab2 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x1a>
    3ac6:	0028      	movs	r0, r5
    3ac8:	f7fd fcc2 	bl	1450 <arch_swap>
	return ret;
    3acc:	e7f1      	b.n	3ab2 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x1a>
    3ace:	46c0      	nop			; (mov r8, r8)
    3ad0:	200002c4 	.word	0x200002c4

00003ad4 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    3ad4:	b510      	push	{r4, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
    3ad6:	4806      	ldr	r0, [pc, #24]	; (3af0 <z_data_copy+0x1c>)
    3ad8:	4a06      	ldr	r2, [pc, #24]	; (3af4 <z_data_copy+0x20>)
    3ada:	1a12      	subs	r2, r2, r0
	(void)memcpy(&__data_region_start, &__data_region_load_start,
    3adc:	4906      	ldr	r1, [pc, #24]	; (3af8 <z_data_copy+0x24>)
    3ade:	f000 fd3f 	bl	4560 <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
    3ae2:	4a06      	ldr	r2, [pc, #24]	; (3afc <z_data_copy+0x28>)
    3ae4:	4906      	ldr	r1, [pc, #24]	; (3b00 <z_data_copy+0x2c>)
    3ae6:	4807      	ldr	r0, [pc, #28]	; (3b04 <z_data_copy+0x30>)
    3ae8:	f000 fd3a 	bl	4560 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    3aec:	bd10      	pop	{r4, pc}
    3aee:	46c0      	nop			; (mov r8, r8)
    3af0:	20000000 	.word	0x20000000
    3af4:	20000034 	.word	0x20000034
    3af8:	000057f0 	.word	0x000057f0
    3afc:	00000000 	.word	0x00000000
    3b00:	000057f0 	.word	0x000057f0
    3b04:	20000000 	.word	0x20000000

00003b08 <first>:
	return list->head == list;
    3b08:	4b03      	ldr	r3, [pc, #12]	; (3b18 <first+0x10>)
    3b0a:	6818      	ldr	r0, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    3b0c:	4298      	cmp	r0, r3
    3b0e:	d000      	beq.n	3b12 <first+0xa>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
    3b10:	4770      	bx	lr
    3b12:	2000      	movs	r0, #0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    3b14:	e7fc      	b.n	3b10 <first+0x8>
    3b16:	46c0      	nop			; (mov r8, r8)
    3b18:	2000001c 	.word	0x2000001c

00003b1c <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    3b1c:	2800      	cmp	r0, #0
    3b1e:	d004      	beq.n	3b2a <next+0xe>
	return (node == list->tail) ? NULL : node->next;
    3b20:	4a03      	ldr	r2, [pc, #12]	; (3b30 <next+0x14>)
    3b22:	6852      	ldr	r2, [r2, #4]
    3b24:	4290      	cmp	r0, r2
    3b26:	d001      	beq.n	3b2c <next+0x10>
    3b28:	6800      	ldr	r0, [r0, #0]
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
    3b2a:	4770      	bx	lr
    3b2c:	2000      	movs	r0, #0
	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
    3b2e:	e7fc      	b.n	3b2a <next+0xe>
    3b30:	2000001c 	.word	0x2000001c

00003b34 <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
    3b34:	b510      	push	{r4, lr}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    3b36:	4b04      	ldr	r3, [pc, #16]	; (3b48 <elapsed+0x14>)
    3b38:	681b      	ldr	r3, [r3, #0]
    3b3a:	2b00      	cmp	r3, #0
    3b3c:	d001      	beq.n	3b42 <elapsed+0xe>
    3b3e:	2000      	movs	r0, #0
}
    3b40:	bd10      	pop	{r4, pc}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    3b42:	f7fe ffd7 	bl	2af4 <sys_clock_elapsed>
    3b46:	e7fb      	b.n	3b40 <elapsed+0xc>
    3b48:	200002fc 	.word	0x200002fc

00003b4c <next_timeout>:

static int32_t next_timeout(void)
{
    3b4c:	b570      	push	{r4, r5, r6, lr}
	struct _timeout *to = first();
    3b4e:	f7ff ffdb 	bl	3b08 <first>
    3b52:	0004      	movs	r4, r0
	int32_t ticks_elapsed = elapsed();
    3b54:	f7ff ffee 	bl	3b34 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    3b58:	2c00      	cmp	r4, #0
    3b5a:	d019      	beq.n	3b90 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    3b5c:	6922      	ldr	r2, [r4, #16]
    3b5e:	6963      	ldr	r3, [r4, #20]
    3b60:	0004      	movs	r4, r0
    3b62:	17c5      	asrs	r5, r0, #31
    3b64:	1b12      	subs	r2, r2, r4
    3b66:	41ab      	sbcs	r3, r5
	int32_t ret = to == NULL ? MAX_WAIT
    3b68:	2b00      	cmp	r3, #0
    3b6a:	dd04      	ble.n	3b76 <next_timeout+0x2a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    3b6c:	0010      	movs	r0, r2
    3b6e:	2b00      	cmp	r3, #0
    3b70:	dd07      	ble.n	3b82 <next_timeout+0x36>
    3b72:	480c      	ldr	r0, [pc, #48]	; (3ba4 <next_timeout+0x58>)
    3b74:	e00d      	b.n	3b92 <next_timeout+0x46>
	int32_t ret = to == NULL ? MAX_WAIT
    3b76:	2b00      	cmp	r3, #0
    3b78:	d101      	bne.n	3b7e <next_timeout+0x32>
    3b7a:	2a00      	cmp	r2, #0
    3b7c:	d1f6      	bne.n	3b6c <next_timeout+0x20>
    3b7e:	2000      	movs	r0, #0
    3b80:	e007      	b.n	3b92 <next_timeout+0x46>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    3b82:	2b00      	cmp	r3, #0
    3b84:	d105      	bne.n	3b92 <next_timeout+0x46>
    3b86:	2380      	movs	r3, #128	; 0x80
    3b88:	061b      	lsls	r3, r3, #24
    3b8a:	429a      	cmp	r2, r3
    3b8c:	d301      	bcc.n	3b92 <next_timeout+0x46>
    3b8e:	e7f0      	b.n	3b72 <next_timeout+0x26>
	int32_t ret = to == NULL ? MAX_WAIT
    3b90:	4804      	ldr	r0, [pc, #16]	; (3ba4 <next_timeout+0x58>)

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    3b92:	4b05      	ldr	r3, [pc, #20]	; (3ba8 <next_timeout+0x5c>)
    3b94:	691b      	ldr	r3, [r3, #16]
    3b96:	2b00      	cmp	r3, #0
    3b98:	d002      	beq.n	3ba0 <next_timeout+0x54>
    3b9a:	4283      	cmp	r3, r0
    3b9c:	da00      	bge.n	3ba0 <next_timeout+0x54>
		ret = _current_cpu->slice_ticks;
    3b9e:	0018      	movs	r0, r3
	}
#endif
	return ret;
}
    3ba0:	bd70      	pop	{r4, r5, r6, pc}
    3ba2:	46c0      	nop			; (mov r8, r8)
    3ba4:	7fffffff 	.word	0x7fffffff
    3ba8:	200002c4 	.word	0x200002c4

00003bac <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    3bac:	b5d0      	push	{r4, r6, r7, lr}
    3bae:	46ce      	mov	lr, r9
    3bb0:	b500      	push	{lr}
    3bb2:	b085      	sub	sp, #20
    3bb4:	0004      	movs	r4, r0
    3bb6:	9200      	str	r2, [sp, #0]
    3bb8:	9301      	str	r3, [sp, #4]
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    3bba:	9e00      	ldr	r6, [sp, #0]
    3bbc:	9f01      	ldr	r7, [sp, #4]
    3bbe:	003b      	movs	r3, r7
    3bc0:	0032      	movs	r2, r6
    3bc2:	3201      	adds	r2, #1
    3bc4:	d006      	beq.n	3bd4 <z_add_timeout+0x28>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    3bc6:	60a1      	str	r1, [r4, #8]

	LOCKED(&timeout_lock) {
    3bc8:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    3bca:	f3ef 8210 	mrs	r2, PRIMASK
    3bce:	b672      	cpsid	i
	return k;
    3bd0:	4691      	mov	r9, r2
    3bd2:	e045      	b.n	3c60 <z_add_timeout+0xb4>
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    3bd4:	3301      	adds	r3, #1
    3bd6:	d1f6      	bne.n	3bc6 <z_add_timeout+0x1a>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    3bd8:	b005      	add	sp, #20
    3bda:	bc04      	pop	{r2}
    3bdc:	4691      	mov	r9, r2
    3bde:	bdd0      	pop	{r4, r6, r7, pc}
			to->dticks = MAX(1, ticks);
    3be0:	2b00      	cmp	r3, #0
    3be2:	d101      	bne.n	3be8 <z_add_timeout+0x3c>
    3be4:	2a00      	cmp	r2, #0
    3be6:	d152      	bne.n	3c8e <z_add_timeout+0xe2>
    3be8:	2201      	movs	r2, #1
    3bea:	2300      	movs	r3, #0
    3bec:	e04f      	b.n	3c8e <z_add_timeout+0xe2>
			to->dticks = timeout.ticks + 1 + elapsed();
    3bee:	f7ff ffa1 	bl	3b34 <elapsed>
    3bf2:	9002      	str	r0, [sp, #8]
    3bf4:	17c3      	asrs	r3, r0, #31
    3bf6:	9303      	str	r3, [sp, #12]
    3bf8:	9e00      	ldr	r6, [sp, #0]
    3bfa:	9f01      	ldr	r7, [sp, #4]
    3bfc:	9a02      	ldr	r2, [sp, #8]
    3bfe:	9b03      	ldr	r3, [sp, #12]
    3c00:	18b6      	adds	r6, r6, r2
    3c02:	415f      	adcs	r7, r3
    3c04:	2201      	movs	r2, #1
    3c06:	2300      	movs	r3, #0
    3c08:	1992      	adds	r2, r2, r6
    3c0a:	417b      	adcs	r3, r7
    3c0c:	6122      	str	r2, [r4, #16]
    3c0e:	6163      	str	r3, [r4, #20]
    3c10:	e03f      	b.n	3c92 <z_add_timeout+0xe6>
			to->dticks -= t->dticks;
    3c12:	1b92      	subs	r2, r2, r6
    3c14:	41bb      	sbcs	r3, r7
    3c16:	6122      	str	r2, [r4, #16]
    3c18:	6163      	str	r3, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
    3c1a:	f7ff ff7f 	bl	3b1c <next>
    3c1e:	2800      	cmp	r0, #0
    3c20:	d011      	beq.n	3c46 <z_add_timeout+0x9a>
			if (t->dticks > to->dticks) {
    3c22:	6906      	ldr	r6, [r0, #16]
    3c24:	6947      	ldr	r7, [r0, #20]
    3c26:	6922      	ldr	r2, [r4, #16]
    3c28:	6963      	ldr	r3, [r4, #20]
    3c2a:	429f      	cmp	r7, r3
    3c2c:	dc02      	bgt.n	3c34 <z_add_timeout+0x88>
    3c2e:	d1f0      	bne.n	3c12 <z_add_timeout+0x66>
    3c30:	4296      	cmp	r6, r2
    3c32:	d9ee      	bls.n	3c12 <z_add_timeout+0x66>
				t->dticks -= to->dticks;
    3c34:	1ab6      	subs	r6, r6, r2
    3c36:	419f      	sbcs	r7, r3
    3c38:	6106      	str	r6, [r0, #16]
    3c3a:	6147      	str	r7, [r0, #20]
	sys_dnode_t *const prev = successor->prev;
    3c3c:	6843      	ldr	r3, [r0, #4]
	node->prev = prev;
    3c3e:	6063      	str	r3, [r4, #4]
	node->next = successor;
    3c40:	6020      	str	r0, [r4, #0]
	prev->next = node;
    3c42:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    3c44:	6044      	str	r4, [r0, #4]
		if (t == NULL) {
    3c46:	2800      	cmp	r0, #0
    3c48:	d026      	beq.n	3c98 <z_add_timeout+0xec>
		if (to == first()) {
    3c4a:	f7ff ff5d 	bl	3b08 <first>
    3c4e:	4284      	cmp	r4, r0
    3c50:	d029      	beq.n	3ca6 <z_add_timeout+0xfa>
	if (key != 0U) {
    3c52:	464b      	mov	r3, r9
    3c54:	2b00      	cmp	r3, #0
    3c56:	d102      	bne.n	3c5e <z_add_timeout+0xb2>
	__asm__ volatile(
    3c58:	b662      	cpsie	i
    3c5a:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    3c5e:	2301      	movs	r3, #1
    3c60:	2b00      	cmp	r3, #0
    3c62:	d1b9      	bne.n	3bd8 <z_add_timeout+0x2c>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    3c64:	2202      	movs	r2, #2
    3c66:	4252      	negs	r2, r2
    3c68:	17d3      	asrs	r3, r2, #31
    3c6a:	9800      	ldr	r0, [sp, #0]
    3c6c:	9901      	ldr	r1, [sp, #4]
    3c6e:	1a12      	subs	r2, r2, r0
    3c70:	418b      	sbcs	r3, r1
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    3c72:	2b00      	cmp	r3, #0
    3c74:	dbbb      	blt.n	3bee <z_add_timeout+0x42>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    3c76:	4b12      	ldr	r3, [pc, #72]	; (3cc0 <z_add_timeout+0x114>)
    3c78:	681e      	ldr	r6, [r3, #0]
    3c7a:	685f      	ldr	r7, [r3, #4]
    3c7c:	1836      	adds	r6, r6, r0
    3c7e:	414f      	adcs	r7, r1
    3c80:	2202      	movs	r2, #2
    3c82:	4252      	negs	r2, r2
    3c84:	17d3      	asrs	r3, r2, #31
    3c86:	1b92      	subs	r2, r2, r6
    3c88:	41bb      	sbcs	r3, r7
			to->dticks = MAX(1, ticks);
    3c8a:	2b00      	cmp	r3, #0
    3c8c:	dda8      	ble.n	3be0 <z_add_timeout+0x34>
    3c8e:	6122      	str	r2, [r4, #16]
    3c90:	6163      	str	r3, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
    3c92:	f7ff ff39 	bl	3b08 <first>
    3c96:	e7c2      	b.n	3c1e <z_add_timeout+0x72>
	sys_dnode_t *const tail = list->tail;
    3c98:	4b0a      	ldr	r3, [pc, #40]	; (3cc4 <z_add_timeout+0x118>)
    3c9a:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    3c9c:	6023      	str	r3, [r4, #0]
	node->prev = tail;
    3c9e:	6062      	str	r2, [r4, #4]
	tail->next = node;
    3ca0:	6014      	str	r4, [r2, #0]
	list->tail = node;
    3ca2:	605c      	str	r4, [r3, #4]
}
    3ca4:	e7d1      	b.n	3c4a <z_add_timeout+0x9e>
			int32_t next_time = next_timeout();
    3ca6:	f7ff ff51 	bl	3b4c <next_timeout>
			if (next_time == 0 ||
    3caa:	2800      	cmp	r0, #0
    3cac:	d003      	beq.n	3cb6 <z_add_timeout+0x10a>
			    _current_cpu->slice_ticks != next_time) {
    3cae:	4b06      	ldr	r3, [pc, #24]	; (3cc8 <z_add_timeout+0x11c>)
    3cb0:	691b      	ldr	r3, [r3, #16]
			if (next_time == 0 ||
    3cb2:	4283      	cmp	r3, r0
    3cb4:	d0cd      	beq.n	3c52 <z_add_timeout+0xa6>
				sys_clock_set_timeout(next_time, false);
    3cb6:	2100      	movs	r1, #0
    3cb8:	f7fe fee6 	bl	2a88 <sys_clock_set_timeout>
    3cbc:	e7c9      	b.n	3c52 <z_add_timeout+0xa6>
    3cbe:	46c0      	nop			; (mov r8, r8)
    3cc0:	200001a8 	.word	0x200001a8
    3cc4:	2000001c 	.word	0x2000001c
    3cc8:	200002c4 	.word	0x200002c4

00003ccc <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
    3ccc:	b5f0      	push	{r4, r5, r6, r7, lr}
    3cce:	46c6      	mov	lr, r8
    3cd0:	b500      	push	{lr}
    3cd2:	0004      	movs	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    3cd4:	f7ff fc94 	bl	3600 <z_time_slice>
	__asm__ volatile("mrs %0, PRIMASK;"
    3cd8:	f3ef 8510 	mrs	r5, PRIMASK
    3cdc:	b672      	cpsid	i
    3cde:	46a8      	mov	r8, r5
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    3ce0:	4b2c      	ldr	r3, [pc, #176]	; (3d94 <sys_clock_announce+0xc8>)
    3ce2:	601c      	str	r4, [r3, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    3ce4:	e009      	b.n	3cfa <sys_clock_announce+0x2e>
	__asm__ volatile(
    3ce6:	b662      	cpsie	i
    3ce8:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
		t->dticks = 0;
		remove_timeout(t);

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    3cec:	68a3      	ldr	r3, [r4, #8]
    3cee:	0020      	movs	r0, r4
    3cf0:	4798      	blx	r3
	__asm__ volatile("mrs %0, PRIMASK;"
    3cf2:	f3ef 8510 	mrs	r5, PRIMASK
    3cf6:	b672      	cpsid	i
    3cf8:	46a8      	mov	r8, r5
	while (first() != NULL && first()->dticks <= announce_remaining) {
    3cfa:	f7ff ff05 	bl	3b08 <first>
    3cfe:	1e04      	subs	r4, r0, #0
    3d00:	d020      	beq.n	3d44 <sys_clock_announce+0x78>
    3d02:	6902      	ldr	r2, [r0, #16]
    3d04:	6940      	ldr	r0, [r0, #20]
    3d06:	4b23      	ldr	r3, [pc, #140]	; (3d94 <sys_clock_announce+0xc8>)
    3d08:	681b      	ldr	r3, [r3, #0]
    3d0a:	17d9      	asrs	r1, r3, #31
    3d0c:	4288      	cmp	r0, r1
    3d0e:	dc19      	bgt.n	3d44 <sys_clock_announce+0x78>
    3d10:	d016      	beq.n	3d40 <sys_clock_announce+0x74>
		curr_tick += dt;
    3d12:	4d21      	ldr	r5, [pc, #132]	; (3d98 <sys_clock_announce+0xcc>)
    3d14:	0016      	movs	r6, r2
    3d16:	17d7      	asrs	r7, r2, #31
    3d18:	6828      	ldr	r0, [r5, #0]
    3d1a:	6869      	ldr	r1, [r5, #4]
    3d1c:	1980      	adds	r0, r0, r6
    3d1e:	4179      	adcs	r1, r7
    3d20:	6028      	str	r0, [r5, #0]
    3d22:	6069      	str	r1, [r5, #4]
		announce_remaining -= dt;
    3d24:	1a9b      	subs	r3, r3, r2
    3d26:	4a1b      	ldr	r2, [pc, #108]	; (3d94 <sys_clock_announce+0xc8>)
    3d28:	6013      	str	r3, [r2, #0]
		t->dticks = 0;
    3d2a:	2200      	movs	r2, #0
    3d2c:	2300      	movs	r3, #0
    3d2e:	6122      	str	r2, [r4, #16]
    3d30:	6163      	str	r3, [r4, #20]
		remove_timeout(t);
    3d32:	0020      	movs	r0, r4
    3d34:	f000 ffb6 	bl	4ca4 <remove_timeout>
	if (key != 0U) {
    3d38:	4643      	mov	r3, r8
    3d3a:	2b00      	cmp	r3, #0
    3d3c:	d0d3      	beq.n	3ce6 <sys_clock_announce+0x1a>
    3d3e:	e7d5      	b.n	3cec <sys_clock_announce+0x20>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    3d40:	429a      	cmp	r2, r3
    3d42:	d9e6      	bls.n	3d12 <sys_clock_announce+0x46>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
    3d44:	2c00      	cmp	r4, #0
    3d46:	d00b      	beq.n	3d60 <sys_clock_announce+0x94>
		first()->dticks -= announce_remaining;
    3d48:	4b12      	ldr	r3, [pc, #72]	; (3d94 <sys_clock_announce+0xc8>)
    3d4a:	6819      	ldr	r1, [r3, #0]
    3d4c:	000a      	movs	r2, r1
    3d4e:	17cb      	asrs	r3, r1, #31
    3d50:	6920      	ldr	r0, [r4, #16]
    3d52:	6961      	ldr	r1, [r4, #20]
    3d54:	1a80      	subs	r0, r0, r2
    3d56:	4199      	sbcs	r1, r3
    3d58:	0002      	movs	r2, r0
    3d5a:	000b      	movs	r3, r1
    3d5c:	6122      	str	r2, [r4, #16]
    3d5e:	6163      	str	r3, [r4, #20]
	}

	curr_tick += announce_remaining;
    3d60:	480d      	ldr	r0, [pc, #52]	; (3d98 <sys_clock_announce+0xcc>)
    3d62:	490c      	ldr	r1, [pc, #48]	; (3d94 <sys_clock_announce+0xc8>)
    3d64:	680a      	ldr	r2, [r1, #0]
    3d66:	17d3      	asrs	r3, r2, #31
    3d68:	6804      	ldr	r4, [r0, #0]
    3d6a:	6845      	ldr	r5, [r0, #4]
    3d6c:	1912      	adds	r2, r2, r4
    3d6e:	416b      	adcs	r3, r5
    3d70:	6002      	str	r2, [r0, #0]
    3d72:	6043      	str	r3, [r0, #4]
	announce_remaining = 0;
    3d74:	2300      	movs	r3, #0
    3d76:	600b      	str	r3, [r1, #0]

	sys_clock_set_timeout(next_timeout(), false);
    3d78:	f7ff fee8 	bl	3b4c <next_timeout>
    3d7c:	2100      	movs	r1, #0
    3d7e:	f7fe fe83 	bl	2a88 <sys_clock_set_timeout>
    3d82:	4643      	mov	r3, r8
    3d84:	2b00      	cmp	r3, #0
    3d86:	d102      	bne.n	3d8e <sys_clock_announce+0xc2>
	__asm__ volatile(
    3d88:	b662      	cpsie	i
    3d8a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    3d8e:	bc04      	pop	{r2}
    3d90:	4690      	mov	r8, r2
    3d92:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3d94:	200002fc 	.word	0x200002fc
    3d98:	200001a8 	.word	0x200001a8

00003d9c <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    3d9c:	b570      	push	{r4, r5, r6, lr}
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
    3d9e:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    3da0:	f3ef 8610 	mrs	r6, PRIMASK
    3da4:	b672      	cpsid	i
	uint64_t t = 0U;
    3da6:	2000      	movs	r0, #0
    3da8:	2100      	movs	r1, #0
    3daa:	e003      	b.n	3db4 <sys_clock_tick_get+0x18>
	__asm__ volatile(
    3dac:	b662      	cpsie	i
    3dae:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    3db2:	2301      	movs	r3, #1
    3db4:	2b00      	cmp	r3, #0
    3db6:	d10b      	bne.n	3dd0 <sys_clock_tick_get+0x34>
		t = curr_tick + sys_clock_elapsed();
    3db8:	f7fe fe9c 	bl	2af4 <sys_clock_elapsed>
    3dbc:	0004      	movs	r4, r0
    3dbe:	2500      	movs	r5, #0
    3dc0:	4b04      	ldr	r3, [pc, #16]	; (3dd4 <sys_clock_tick_get+0x38>)
    3dc2:	6818      	ldr	r0, [r3, #0]
    3dc4:	6859      	ldr	r1, [r3, #4]
    3dc6:	1900      	adds	r0, r0, r4
    3dc8:	4169      	adcs	r1, r5
	if (key != 0U) {
    3dca:	2e00      	cmp	r6, #0
    3dcc:	d0ee      	beq.n	3dac <sys_clock_tick_get+0x10>
    3dce:	e7f0      	b.n	3db2 <sys_clock_tick_get+0x16>
	}
	return t;
}
    3dd0:	bd70      	pop	{r4, r5, r6, pc}
    3dd2:	46c0      	nop			; (mov r8, r8)
    3dd4:	200001a8 	.word	0x200001a8

00003dd8 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    3dd8:	b510      	push	{r4, lr}
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    3dda:	4a03      	ldr	r2, [pc, #12]	; (3de8 <boot_banner+0x10>)
    3ddc:	4903      	ldr	r1, [pc, #12]	; (3dec <boot_banner+0x14>)
    3dde:	4804      	ldr	r0, [pc, #16]	; (3df0 <boot_banner+0x18>)
    3de0:	f000 f877 	bl	3ed2 <printk>
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
    3de4:	bd10      	pop	{r4, pc}
    3de6:	46c0      	nop			; (mov r8, r8)
    3de8:	00005258 	.word	0x00005258
    3dec:	000057bc 	.word	0x000057bc
    3df0:	000057c8 	.word	0x000057c8

00003df4 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
    3df4:	b510      	push	{r4, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    3df6:	4c06      	ldr	r4, [pc, #24]	; (3e10 <statics_init+0x1c>)
    3df8:	4b06      	ldr	r3, [pc, #24]	; (3e14 <statics_init+0x20>)
    3dfa:	429c      	cmp	r4, r3
    3dfc:	d206      	bcs.n	3e0c <statics_init+0x18>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    3dfe:	68a2      	ldr	r2, [r4, #8]
    3e00:	6861      	ldr	r1, [r4, #4]
    3e02:	0020      	movs	r0, r4
    3e04:	f001 f801 	bl	4e0a <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    3e08:	3414      	adds	r4, #20
    3e0a:	e7f5      	b.n	3df8 <statics_init+0x4>
		}
	}
	return 0;
}
    3e0c:	2000      	movs	r0, #0
    3e0e:	bd10      	pop	{r4, pc}
    3e10:	20000034 	.word	0x20000034
    3e14:	20000034 	.word	0x20000034

00003e18 <Event_dispatcher>:
void Event_dispatcher(KitchenTimer_t * MainObject,GenericEvent_t  * DispatchEvent){
    3e18:	b570      	push	{r4, r5, r6, lr}
    3e1a:	b082      	sub	sp, #8
    3e1c:	0004      	movs	r4, r0
  PreTransitionState = MainObject->CurrentState;
    3e1e:	7905      	ldrb	r5, [r0, #4]
  HandledStatus = StateMachine_Handler(MainObject,DispatchEvent);
    3e20:	f7fc fb98 	bl	554 <StateMachine_Handler>
  if(HandledStatus == EVENT_TRANISITON){
    3e24:	2806      	cmp	r0, #6
    3e26:	d001      	beq.n	3e2c <Event_dispatcher+0x14>
} 
    3e28:	b002      	add	sp, #8
    3e2a:	bd70      	pop	{r4, r5, r6, pc}
    PostTransitionState = MainObject->CurrentState;
    3e2c:	7926      	ldrb	r6, [r4, #4]
    TransitionEvent.Signal = Exit;
    3e2e:	2301      	movs	r3, #1
    3e30:	466a      	mov	r2, sp
    3e32:	7113      	strb	r3, [r2, #4]
    MainObject->CurrentState = PreTransitionState;
    3e34:	7125      	strb	r5, [r4, #4]
    StateMachine_Handler(MainObject,&TransitionEvent);
    3e36:	a901      	add	r1, sp, #4
    3e38:	0020      	movs	r0, r4
    3e3a:	f7fc fb8b 	bl	554 <StateMachine_Handler>
    TransitionEvent.Signal = Entry;
    3e3e:	2300      	movs	r3, #0
    3e40:	466a      	mov	r2, sp
    3e42:	7113      	strb	r3, [r2, #4]
    MainObject->CurrentState = PostTransitionState;
    3e44:	7126      	strb	r6, [r4, #4]
    StateMachine_Handler(MainObject,&TransitionEvent);
    3e46:	a901      	add	r1, sp, #4
    3e48:	0020      	movs	r0, r4
    3e4a:	f7fc fb83 	bl	554 <StateMachine_Handler>
} 
    3e4e:	e7eb      	b.n	3e28 <Event_dispatcher+0x10>

00003e50 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    3e50:	2800      	cmp	r0, #0
    3e52:	d00d      	beq.n	3e70 <sys_notify_validate+0x20>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    3e54:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    3e56:	2303      	movs	r3, #3
    3e58:	4013      	ands	r3, r2
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    3e5a:	2b01      	cmp	r3, #1
    3e5c:	d004      	beq.n	3e68 <sys_notify_validate+0x18>
    3e5e:	2b03      	cmp	r3, #3
    3e60:	d109      	bne.n	3e76 <sys_notify_validate+0x26>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
    3e62:	6803      	ldr	r3, [r0, #0]
    3e64:	2b00      	cmp	r3, #0
    3e66:	d009      	beq.n	3e7c <sys_notify_validate+0x2c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
    3e68:	2300      	movs	r3, #0
    3e6a:	6083      	str	r3, [r0, #8]
    3e6c:	2000      	movs	r0, #0
	}

	return rv;
}
    3e6e:	4770      	bx	lr
		return -EINVAL;
    3e70:	2016      	movs	r0, #22
    3e72:	4240      	negs	r0, r0
    3e74:	e7fb      	b.n	3e6e <sys_notify_validate+0x1e>
	switch (sys_notify_get_method(notify)) {
    3e76:	2016      	movs	r0, #22
    3e78:	4240      	negs	r0, r0
    3e7a:	e7f8      	b.n	3e6e <sys_notify_validate+0x1e>
			rv = -EINVAL;
    3e7c:	2016      	movs	r0, #22
    3e7e:	4240      	negs	r0, r0
    3e80:	e7f5      	b.n	3e6e <sys_notify_validate+0x1e>

00003e82 <sys_notify_finalize>:

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
    3e82:	0003      	movs	r3, r0
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    3e84:	6840      	ldr	r0, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    3e86:	2203      	movs	r2, #3
    3e88:	4002      	ands	r2, r0
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
    3e8a:	6099      	str	r1, [r3, #8]
	switch (method) {
    3e8c:	2a03      	cmp	r2, #3
    3e8e:	d103      	bne.n	3e98 <sys_notify_finalize+0x16>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    3e90:	6818      	ldr	r0, [r3, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    3e92:	2200      	movs	r2, #0
    3e94:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    3e96:	4770      	bx	lr
	sys_notify_generic_callback rv = NULL;
    3e98:	2000      	movs	r0, #0
    3e9a:	e7fa      	b.n	3e92 <sys_notify_finalize+0x10>

00003e9c <arch_printk_char_out>:
}
    3e9c:	2000      	movs	r0, #0
    3e9e:	4770      	bx	lr

00003ea0 <str_out>:
{
    3ea0:	b510      	push	{r4, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    3ea2:	680c      	ldr	r4, [r1, #0]
    3ea4:	2c00      	cmp	r4, #0
    3ea6:	d00a      	beq.n	3ebe <str_out+0x1e>
    3ea8:	688a      	ldr	r2, [r1, #8]
    3eaa:	684b      	ldr	r3, [r1, #4]
    3eac:	429a      	cmp	r2, r3
    3eae:	da06      	bge.n	3ebe <str_out+0x1e>
	if (ctx->count == ctx->max - 1) {
    3eb0:	3b01      	subs	r3, #1
    3eb2:	429a      	cmp	r2, r3
    3eb4:	d007      	beq.n	3ec6 <str_out+0x26>
		ctx->str[ctx->count++] = c;
    3eb6:	1c53      	adds	r3, r2, #1
    3eb8:	608b      	str	r3, [r1, #8]
    3eba:	54a0      	strb	r0, [r4, r2]
    3ebc:	e002      	b.n	3ec4 <str_out+0x24>
		ctx->count++;
    3ebe:	688b      	ldr	r3, [r1, #8]
    3ec0:	3301      	adds	r3, #1
    3ec2:	608b      	str	r3, [r1, #8]
}
    3ec4:	bd10      	pop	{r4, pc}
		ctx->str[ctx->count++] = '\0';
    3ec6:	1c53      	adds	r3, r2, #1
    3ec8:	608b      	str	r3, [r1, #8]
    3eca:	18a2      	adds	r2, r4, r2
    3ecc:	2300      	movs	r3, #0
    3ece:	7013      	strb	r3, [r2, #0]
    3ed0:	e7f8      	b.n	3ec4 <str_out+0x24>

00003ed2 <printk>:
{
    3ed2:	b40f      	push	{r0, r1, r2, r3}
    3ed4:	b500      	push	{lr}
    3ed6:	b083      	sub	sp, #12
    3ed8:	a904      	add	r1, sp, #16
    3eda:	c901      	ldmia	r1!, {r0}
	va_start(ap, fmt);
    3edc:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
    3ede:	f7fc fc37 	bl	750 <vprintk>
}
    3ee2:	b003      	add	sp, #12
    3ee4:	bc08      	pop	{r3}
    3ee6:	b004      	add	sp, #16
    3ee8:	4718      	bx	r3

00003eea <snprintk>:
{
    3eea:	b40c      	push	{r2, r3}
    3eec:	b500      	push	{lr}
    3eee:	b083      	sub	sp, #12
    3ef0:	ab04      	add	r3, sp, #16
    3ef2:	cb04      	ldmia	r3!, {r2}
	va_start(ap, fmt);
    3ef4:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
    3ef6:	f7fc fc39 	bl	76c <vsnprintk>
}
    3efa:	b003      	add	sp, #12
    3efc:	bc08      	pop	{r3}
    3efe:	b002      	add	sp, #8
    3f00:	4718      	bx	r3

00003f02 <set_state>:
	mgr->flags = (state & ONOFF_STATE_MASK)
    3f02:	2307      	movs	r3, #7
    3f04:	400b      	ands	r3, r1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    3f06:	8b01      	ldrh	r1, [r0, #24]
    3f08:	2207      	movs	r2, #7
    3f0a:	4391      	bics	r1, r2
    3f0c:	430b      	orrs	r3, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
    3f0e:	8303      	strh	r3, [r0, #24]
}
    3f10:	4770      	bx	lr

00003f12 <notify_monitors>:
{
    3f12:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f14:	46c6      	mov	lr, r8
    3f16:	b500      	push	{lr}
    3f18:	0006      	movs	r6, r0
    3f1a:	000f      	movs	r7, r1
    3f1c:	4690      	mov	r8, r2
	return list->head;
    3f1e:	6881      	ldr	r1, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    3f20:	2900      	cmp	r1, #0
    3f22:	d003      	beq.n	3f2c <notify_monitors+0x1a>
    3f24:	1e0c      	subs	r4, r1, #0
Z_GENLIST_PEEK_NEXT(slist, snode)
    3f26:	d006      	beq.n	3f36 <notify_monitors+0x24>
	return node->next;
    3f28:	680c      	ldr	r4, [r1, #0]
    3f2a:	e004      	b.n	3f36 <notify_monitors+0x24>
    3f2c:	000c      	movs	r4, r1
    3f2e:	e002      	b.n	3f36 <notify_monitors+0x24>
    3f30:	0023      	movs	r3, r4
    3f32:	0021      	movs	r1, r4
    3f34:	001c      	movs	r4, r3
    3f36:	2900      	cmp	r1, #0
    3f38:	d00a      	beq.n	3f50 <notify_monitors+0x3e>
		mon->callback(mgr, mon, state, res);
    3f3a:	684d      	ldr	r5, [r1, #4]
    3f3c:	4643      	mov	r3, r8
    3f3e:	003a      	movs	r2, r7
    3f40:	0030      	movs	r0, r6
    3f42:	47a8      	blx	r5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    3f44:	2c00      	cmp	r4, #0
    3f46:	d0f3      	beq.n	3f30 <notify_monitors+0x1e>
    3f48:	1e23      	subs	r3, r4, #0
Z_GENLIST_PEEK_NEXT(slist, snode)
    3f4a:	d0f2      	beq.n	3f32 <notify_monitors+0x20>
	return node->next;
    3f4c:	6823      	ldr	r3, [r4, #0]
    3f4e:	e7f0      	b.n	3f32 <notify_monitors+0x20>
}
    3f50:	bc04      	pop	{r2}
    3f52:	4690      	mov	r8, r2
    3f54:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003f56 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    3f56:	8b03      	ldrh	r3, [r0, #24]
    3f58:	2207      	movs	r2, #7
    3f5a:	0011      	movs	r1, r2
    3f5c:	4019      	ands	r1, r3
	if ((state == ONOFF_STATE_OFF)
    3f5e:	421a      	tst	r2, r3
    3f60:	d104      	bne.n	3f6c <process_recheck+0x16>
	    && !sys_slist_is_empty(&mgr->clients)) {
    3f62:	6803      	ldr	r3, [r0, #0]
    3f64:	2b00      	cmp	r3, #0
    3f66:	d001      	beq.n	3f6c <process_recheck+0x16>
		evt = EVT_START;
    3f68:	2003      	movs	r0, #3
    3f6a:	e004      	b.n	3f76 <process_recheck+0x20>
	} else if ((state == ONOFF_STATE_ON)
    3f6c:	2902      	cmp	r1, #2
    3f6e:	d003      	beq.n	3f78 <process_recheck+0x22>
	} else if ((state == ONOFF_STATE_ERROR)
    3f70:	2901      	cmp	r1, #1
    3f72:	d006      	beq.n	3f82 <process_recheck+0x2c>
	int evt = EVT_NOP;
    3f74:	2000      	movs	r0, #0
}
    3f76:	4770      	bx	lr
		   && (mgr->refs == 0U)) {
    3f78:	8b43      	ldrh	r3, [r0, #26]
    3f7a:	2b00      	cmp	r3, #0
    3f7c:	d1f8      	bne.n	3f70 <process_recheck+0x1a>
		evt = EVT_STOP;
    3f7e:	2004      	movs	r0, #4
    3f80:	e7f9      	b.n	3f76 <process_recheck+0x20>
	return list->head;
    3f82:	6803      	ldr	r3, [r0, #0]
		   && !sys_slist_is_empty(&mgr->clients)) {
    3f84:	2b00      	cmp	r3, #0
    3f86:	d001      	beq.n	3f8c <process_recheck+0x36>
		evt = EVT_RESET;
    3f88:	2005      	movs	r0, #5
	return evt;
    3f8a:	e7f4      	b.n	3f76 <process_recheck+0x20>
	int evt = EVT_NOP;
    3f8c:	2000      	movs	r0, #0
    3f8e:	e7f2      	b.n	3f76 <process_recheck+0x20>

00003f90 <process_complete>:
{
    3f90:	b570      	push	{r4, r5, r6, lr}
    3f92:	0004      	movs	r4, r0
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    3f94:	8b00      	ldrh	r0, [r0, #24]
    3f96:	2307      	movs	r3, #7
    3f98:	4003      	ands	r3, r0
	if (res < 0) {
    3f9a:	2a00      	cmp	r2, #0
    3f9c:	db05      	blt.n	3faa <process_complete+0x1a>
		   || (state == ONOFF_STATE_RESETTING)) {
    3f9e:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    3fa0:	2a01      	cmp	r2, #1
    3fa2:	d90d      	bls.n	3fc0 <process_complete+0x30>
	} else if (state == ONOFF_STATE_TO_OFF) {
    3fa4:	2b04      	cmp	r3, #4
    3fa6:	d032      	beq.n	400e <process_complete+0x7e>
}
    3fa8:	bd70      	pop	{r4, r5, r6, pc}
		*clients = mgr->clients;
    3faa:	0023      	movs	r3, r4
    3fac:	cb05      	ldmia	r3!, {r0, r2}
    3fae:	c105      	stmia	r1!, {r0, r2}
	list->head = NULL;
    3fb0:	2300      	movs	r3, #0
    3fb2:	6023      	str	r3, [r4, #0]
	list->tail = NULL;
    3fb4:	6063      	str	r3, [r4, #4]
		set_state(mgr, ONOFF_STATE_ERROR);
    3fb6:	2101      	movs	r1, #1
    3fb8:	0020      	movs	r0, r4
    3fba:	f7ff ffa2 	bl	3f02 <set_state>
    3fbe:	e7f3      	b.n	3fa8 <process_complete+0x18>
		*clients = mgr->clients;
    3fc0:	000a      	movs	r2, r1
    3fc2:	0020      	movs	r0, r4
    3fc4:	c860      	ldmia	r0!, {r5, r6}
    3fc6:	c260      	stmia	r2!, {r5, r6}
	list->head = NULL;
    3fc8:	2200      	movs	r2, #0
    3fca:	6022      	str	r2, [r4, #0]
	list->tail = NULL;
    3fcc:	6062      	str	r2, [r4, #4]
		if (state == ONOFF_STATE_TO_ON) {
    3fce:	2b06      	cmp	r3, #6
    3fd0:	d118      	bne.n	4004 <process_complete+0x74>
	return list->head;
    3fd2:	680b      	ldr	r3, [r1, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    3fd4:	2b00      	cmp	r3, #0
    3fd6:	d007      	beq.n	3fe8 <process_complete+0x58>
				mgr->refs += 1U;
    3fd8:	8b62      	ldrh	r2, [r4, #26]
    3fda:	3201      	adds	r2, #1
    3fdc:	8362      	strh	r2, [r4, #26]
Z_GENLIST_PEEK_NEXT(slist, snode)
    3fde:	2b00      	cmp	r3, #0
    3fe0:	d0f8      	beq.n	3fd4 <process_complete+0x44>
	return node->next;
    3fe2:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    3fe4:	2b00      	cmp	r3, #0
    3fe6:	d1f5      	bne.n	3fd4 <process_complete+0x44>
			set_state(mgr, ONOFF_STATE_ON);
    3fe8:	2102      	movs	r1, #2
    3fea:	0020      	movs	r0, r4
    3fec:	f7ff ff89 	bl	3f02 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    3ff0:	0020      	movs	r0, r4
    3ff2:	f7ff ffb0 	bl	3f56 <process_recheck>
    3ff6:	2800      	cmp	r0, #0
    3ff8:	d0d6      	beq.n	3fa8 <process_complete+0x18>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    3ffa:	8b23      	ldrh	r3, [r4, #24]
    3ffc:	2220      	movs	r2, #32
    3ffe:	4313      	orrs	r3, r2
    4000:	8323      	strh	r3, [r4, #24]
    4002:	e7d1      	b.n	3fa8 <process_complete+0x18>
			set_state(mgr, ONOFF_STATE_OFF);
    4004:	2100      	movs	r1, #0
    4006:	0020      	movs	r0, r4
    4008:	f7ff ff7b 	bl	3f02 <set_state>
    400c:	e7f0      	b.n	3ff0 <process_complete+0x60>
		set_state(mgr, ONOFF_STATE_OFF);
    400e:	2100      	movs	r1, #0
    4010:	0020      	movs	r0, r4
    4012:	f7ff ff76 	bl	3f02 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    4016:	0020      	movs	r0, r4
    4018:	f7ff ff9d 	bl	3f56 <process_recheck>
    401c:	2800      	cmp	r0, #0
    401e:	d0c3      	beq.n	3fa8 <process_complete+0x18>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    4020:	8b23      	ldrh	r3, [r4, #24]
    4022:	2220      	movs	r2, #32
    4024:	4313      	orrs	r3, r2
    4026:	8323      	strh	r3, [r4, #24]
}
    4028:	e7be      	b.n	3fa8 <process_complete+0x18>

0000402a <validate_args>:
{
    402a:	b510      	push	{r4, lr}
    402c:	000c      	movs	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    402e:	2800      	cmp	r0, #0
    4030:	d00b      	beq.n	404a <validate_args+0x20>
    4032:	2900      	cmp	r1, #0
    4034:	d00c      	beq.n	4050 <validate_args+0x26>
	int rv = sys_notify_validate(&cli->notify);
    4036:	1d08      	adds	r0, r1, #4
    4038:	f7ff ff0a 	bl	3e50 <sys_notify_validate>
	if ((rv == 0)
    403c:	2800      	cmp	r0, #0
    403e:	d103      	bne.n	4048 <validate_args+0x1e>
	    && ((cli->notify.flags
    4040:	68a3      	ldr	r3, [r4, #8]
		 & ~BIT_MASK(ONOFF_CLIENT_EXTENSION_POS)) != 0)) {
    4042:	2203      	movs	r2, #3
    4044:	4393      	bics	r3, r2
	    && ((cli->notify.flags
    4046:	d106      	bne.n	4056 <validate_args+0x2c>
}
    4048:	bd10      	pop	{r4, pc}
		return -EINVAL;
    404a:	2016      	movs	r0, #22
    404c:	4240      	negs	r0, r0
    404e:	e7fb      	b.n	4048 <validate_args+0x1e>
    4050:	2016      	movs	r0, #22
    4052:	4240      	negs	r0, r0
    4054:	e7f8      	b.n	4048 <validate_args+0x1e>
		rv = -EINVAL;
    4056:	2016      	movs	r0, #22
    4058:	4240      	negs	r0, r0
    405a:	e7f5      	b.n	4048 <validate_args+0x1e>

0000405c <notify_one>:
{
    405c:	b5f0      	push	{r4, r5, r6, r7, lr}
    405e:	b083      	sub	sp, #12
    4060:	9001      	str	r0, [sp, #4]
    4062:	000f      	movs	r7, r1
    4064:	0016      	movs	r6, r2
    4066:	001d      	movs	r5, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    4068:	1d08      	adds	r0, r1, #4
    406a:	0019      	movs	r1, r3
    406c:	f7ff ff09 	bl	3e82 <sys_notify_finalize>
    4070:	1e04      	subs	r4, r0, #0
	if (cb) {
    4072:	d004      	beq.n	407e <notify_one+0x22>
		cb(mgr, cli, state, res);
    4074:	002b      	movs	r3, r5
    4076:	0032      	movs	r2, r6
    4078:	0039      	movs	r1, r7
    407a:	9801      	ldr	r0, [sp, #4]
    407c:	47a0      	blx	r4
}
    407e:	b003      	add	sp, #12
    4080:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004082 <notify_all>:
{
    4082:	b5f0      	push	{r4, r5, r6, r7, lr}
    4084:	46c6      	mov	lr, r8
    4086:	b500      	push	{lr}
    4088:	4680      	mov	r8, r0
    408a:	000c      	movs	r4, r1
    408c:	0017      	movs	r7, r2
    408e:	001e      	movs	r6, r3
	while (!sys_slist_is_empty(list)) {
    4090:	e005      	b.n	409e <notify_all+0x1c>
	list->tail = node;
    4092:	6065      	str	r5, [r4, #4]
		notify_one(mgr, cli, state, res);
    4094:	0033      	movs	r3, r6
    4096:	003a      	movs	r2, r7
    4098:	4640      	mov	r0, r8
    409a:	f7ff ffdf 	bl	405c <notify_one>
	return list->head;
    409e:	6821      	ldr	r1, [r4, #0]
	while (!sys_slist_is_empty(list)) {
    40a0:	2900      	cmp	r1, #0
    40a2:	d005      	beq.n	40b0 <notify_all+0x2e>
	return node->next;
    40a4:	680d      	ldr	r5, [r1, #0]
	list->head = node;
    40a6:	6025      	str	r5, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    40a8:	6863      	ldr	r3, [r4, #4]
    40aa:	428b      	cmp	r3, r1
    40ac:	d1f2      	bne.n	4094 <notify_all+0x12>
    40ae:	e7f0      	b.n	4092 <notify_all+0x10>
}
    40b0:	bc04      	pop	{r2}
    40b2:	4690      	mov	r8, r2
    40b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

000040b6 <transition_complete>:
{
    40b6:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    40b8:	f3ef 8210 	mrs	r2, PRIMASK
    40bc:	b672      	cpsid	i
	mgr->last_res = res;
    40be:	6141      	str	r1, [r0, #20]
	process_event(mgr, EVT_COMPLETE, key);
    40c0:	2101      	movs	r1, #1
    40c2:	f7fc fb6b 	bl	79c <process_event>
}
    40c6:	bd10      	pop	{r4, pc}

000040c8 <onoff_manager_init>:
{
    40c8:	b570      	push	{r4, r5, r6, lr}
    40ca:	0005      	movs	r5, r0
    40cc:	000c      	movs	r4, r1
	if ((mgr == NULL)
    40ce:	2800      	cmp	r0, #0
    40d0:	d00e      	beq.n	40f0 <onoff_manager_init+0x28>
	    || (transitions == NULL)
    40d2:	2900      	cmp	r1, #0
    40d4:	d00f      	beq.n	40f6 <onoff_manager_init+0x2e>
	    || (transitions->start == NULL)
    40d6:	680b      	ldr	r3, [r1, #0]
    40d8:	2b00      	cmp	r3, #0
    40da:	d00f      	beq.n	40fc <onoff_manager_init+0x34>
	    || (transitions->stop == NULL)) {
    40dc:	684b      	ldr	r3, [r1, #4]
    40de:	2b00      	cmp	r3, #0
    40e0:	d00f      	beq.n	4102 <onoff_manager_init+0x3a>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    40e2:	221c      	movs	r2, #28
    40e4:	2100      	movs	r1, #0
    40e6:	f000 fa5b 	bl	45a0 <memset>
    40ea:	612c      	str	r4, [r5, #16]
	return 0;
    40ec:	2000      	movs	r0, #0
}
    40ee:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    40f0:	2016      	movs	r0, #22
    40f2:	4240      	negs	r0, r0
    40f4:	e7fb      	b.n	40ee <onoff_manager_init+0x26>
    40f6:	2016      	movs	r0, #22
    40f8:	4240      	negs	r0, r0
    40fa:	e7f8      	b.n	40ee <onoff_manager_init+0x26>
    40fc:	2016      	movs	r0, #22
    40fe:	4240      	negs	r0, r0
    4100:	e7f5      	b.n	40ee <onoff_manager_init+0x26>
    4102:	2016      	movs	r0, #22
    4104:	4240      	negs	r0, r0
    4106:	e7f2      	b.n	40ee <onoff_manager_init+0x26>

00004108 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    4108:	b510      	push	{r4, lr}
    410a:	0004      	movs	r4, r0
    410c:	0008      	movs	r0, r1
    410e:	0011      	movs	r1, r2
    4110:	001a      	movs	r2, r3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    4112:	47a0      	blx	r4
	return z_impl_z_current_get();
    4114:	f7ff fcb2 	bl	3a7c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    4118:	f7fd fb30 	bl	177c <z_impl_k_thread_abort>

0000411c <free_list_add_bidx>:
		free_list_remove_bidx(h, c, bidx);
	}
}

static void free_list_add_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
    411c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct z_heap_bucket *b = &h->buckets[bidx];

	if (b->next == 0U) {
    411e:	1d13      	adds	r3, r2, #4
    4120:	009b      	lsls	r3, r3, #2
    4122:	581c      	ldr	r4, [r3, r0]
    4124:	2c00      	cmp	r4, #0
    4126:	d11a      	bne.n	415e <free_list_add_bidx+0x42>
		CHECK((h->avail_buckets & (1 << bidx)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= (1 << bidx);
    4128:	2301      	movs	r3, #1
    412a:	4093      	lsls	r3, r2
    412c:	68c4      	ldr	r4, [r0, #12]
    412e:	4323      	orrs	r3, r4
    4130:	60c3      	str	r3, [r0, #12]
		b->next = c;
    4132:	3204      	adds	r2, #4
    4134:	0092      	lsls	r2, r2, #2
    4136:	5011      	str	r1, [r2, r0]
			     enum chunk_fields f, chunkid_t val)
{
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    4138:	00cb      	lsls	r3, r1, #3
    413a:	18c3      	adds	r3, r0, r3

	if (big_heap(h)) {
    413c:	2280      	movs	r2, #128	; 0x80
    413e:	0212      	lsls	r2, r2, #8
    4140:	6884      	ldr	r4, [r0, #8]
    4142:	4294      	cmp	r4, r2
    4144:	d307      	bcc.n	4156 <free_list_add_bidx+0x3a>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
    4146:	6099      	str	r1, [r3, #8]
	return big_heap_chunks(h->end_chunk);
    4148:	6880      	ldr	r0, [r0, #8]
	if (big_heap(h)) {
    414a:	2280      	movs	r2, #128	; 0x80
    414c:	0212      	lsls	r2, r2, #8
    414e:	4290      	cmp	r0, r2
    4150:	d303      	bcc.n	415a <free_list_add_bidx+0x3e>
		((uint32_t *)cmem)[f] = val;
    4152:	60d9      	str	r1, [r3, #12]
		set_prev_free_chunk(h, c, first);
		set_next_free_chunk(h, c, second);
		set_next_free_chunk(h, first, c);
		set_prev_free_chunk(h, second, c);
	}
}
    4154:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
    4156:	8099      	strh	r1, [r3, #4]
    4158:	e7f6      	b.n	4148 <free_list_add_bidx+0x2c>
    415a:	80d9      	strh	r1, [r3, #6]
    415c:	e7fa      	b.n	4154 <free_list_add_bidx+0x38>
	void *cmem = &buf[c];
    415e:	00e2      	lsls	r2, r4, #3
    4160:	1882      	adds	r2, r0, r2
	return big_heap_chunks(h->end_chunk);
    4162:	6886      	ldr	r6, [r0, #8]
	if (big_heap(h)) {
    4164:	2380      	movs	r3, #128	; 0x80
    4166:	021b      	lsls	r3, r3, #8
    4168:	429e      	cmp	r6, r3
    416a:	d31c      	bcc.n	41a6 <free_list_add_bidx+0x8a>
		return ((uint32_t *)cmem)[f];
    416c:	6893      	ldr	r3, [r2, #8]
	void *cmem = &buf[c];
    416e:	00cd      	lsls	r5, r1, #3
    4170:	1945      	adds	r5, r0, r5
	if (big_heap(h)) {
    4172:	2780      	movs	r7, #128	; 0x80
    4174:	023f      	lsls	r7, r7, #8
    4176:	42be      	cmp	r6, r7
    4178:	d317      	bcc.n	41aa <free_list_add_bidx+0x8e>
		((uint32_t *)cmem)[f] = val;
    417a:	60ab      	str	r3, [r5, #8]
	if (big_heap(h)) {
    417c:	2680      	movs	r6, #128	; 0x80
    417e:	0236      	lsls	r6, r6, #8
    4180:	6887      	ldr	r7, [r0, #8]
    4182:	42b7      	cmp	r7, r6
    4184:	d313      	bcc.n	41ae <free_list_add_bidx+0x92>
		((uint32_t *)cmem)[f] = val;
    4186:	60ec      	str	r4, [r5, #12]
	void *cmem = &buf[c];
    4188:	00db      	lsls	r3, r3, #3
    418a:	18c3      	adds	r3, r0, r3
	if (big_heap(h)) {
    418c:	2480      	movs	r4, #128	; 0x80
    418e:	0224      	lsls	r4, r4, #8
    4190:	6885      	ldr	r5, [r0, #8]
    4192:	42a5      	cmp	r5, r4
    4194:	d30d      	bcc.n	41b2 <free_list_add_bidx+0x96>
		((uint32_t *)cmem)[f] = val;
    4196:	60d9      	str	r1, [r3, #12]
	return big_heap_chunks(h->end_chunk);
    4198:	6880      	ldr	r0, [r0, #8]
	if (big_heap(h)) {
    419a:	2380      	movs	r3, #128	; 0x80
    419c:	021b      	lsls	r3, r3, #8
    419e:	4298      	cmp	r0, r3
    41a0:	d309      	bcc.n	41b6 <free_list_add_bidx+0x9a>
		((uint32_t *)cmem)[f] = val;
    41a2:	6091      	str	r1, [r2, #8]
    41a4:	e7d6      	b.n	4154 <free_list_add_bidx+0x38>
		return ((uint16_t *)cmem)[f];
    41a6:	8893      	ldrh	r3, [r2, #4]
    41a8:	e7e1      	b.n	416e <free_list_add_bidx+0x52>
		((uint16_t *)cmem)[f] = val;
    41aa:	80ab      	strh	r3, [r5, #4]
    41ac:	e7e6      	b.n	417c <free_list_add_bidx+0x60>
    41ae:	80ec      	strh	r4, [r5, #6]
    41b0:	e7ea      	b.n	4188 <free_list_add_bidx+0x6c>
    41b2:	80d9      	strh	r1, [r3, #6]
    41b4:	e7f0      	b.n	4198 <free_list_add_bidx+0x7c>
    41b6:	8091      	strh	r1, [r2, #4]
    41b8:	e7cc      	b.n	4154 <free_list_add_bidx+0x38>

000041ba <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    41ba:	b570      	push	{r4, r5, r6, lr}
    41bc:	0004      	movs	r4, r0
    41be:	000d      	movs	r5, r1
	return big_heap_chunks(h->end_chunk);
    41c0:	6882      	ldr	r2, [r0, #8]
	chunk_set(h, c, LEFT_SIZE, size);
}

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
	return big_heap(h) && chunk_size(h, c) == 1U;
    41c2:	2380      	movs	r3, #128	; 0x80
    41c4:	021b      	lsls	r3, r3, #8
    41c6:	429a      	cmp	r2, r3
    41c8:	d307      	bcc.n	41da <free_list_add+0x20>
	void *cmem = &buf[c];
    41ca:	00cb      	lsls	r3, r1, #3
    41cc:	18c3      	adds	r3, r0, r3
		return ((uint32_t *)cmem)[f];
    41ce:	685b      	ldr	r3, [r3, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    41d0:	085b      	lsrs	r3, r3, #1
	return big_heap(h) && chunk_size(h, c) == 1U;
    41d2:	2b01      	cmp	r3, #1
    41d4:	d002      	beq.n	41dc <free_list_add+0x22>
    41d6:	2300      	movs	r3, #0
    41d8:	e000      	b.n	41dc <free_list_add+0x22>
    41da:	2300      	movs	r3, #0
	if (!solo_free_header(h, c)) {
    41dc:	2b00      	cmp	r3, #0
    41de:	d118      	bne.n	4212 <free_list_add+0x58>
	void *cmem = &buf[c];
    41e0:	00eb      	lsls	r3, r5, #3
    41e2:	18e3      	adds	r3, r4, r3
	if (big_heap(h)) {
    41e4:	2180      	movs	r1, #128	; 0x80
    41e6:	0209      	lsls	r1, r1, #8
    41e8:	428a      	cmp	r2, r1
    41ea:	d313      	bcc.n	4214 <free_list_add+0x5a>
		return ((uint32_t *)cmem)[f];
    41ec:	685b      	ldr	r3, [r3, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    41ee:	085b      	lsrs	r3, r3, #1
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
    41f0:	2180      	movs	r1, #128	; 0x80
    41f2:	0209      	lsls	r1, r1, #8
    41f4:	428a      	cmp	r2, r1
    41f6:	d30f      	bcc.n	4218 <free_list_add+0x5e>
    41f8:	2008      	movs	r0, #8
	return big_heap_bytes(size) ? 8 : 4;
}

static inline chunksz_t chunksz(size_t bytes)
{
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    41fa:	3008      	adds	r0, #8
    41fc:	08c0      	lsrs	r0, r0, #3
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    41fe:	1a18      	subs	r0, r3, r0
    4200:	3001      	adds	r0, #1
	return 31 - __builtin_clz(usable_sz);
    4202:	f7fb ff53 	bl	ac <__clzsi2>
    4206:	221f      	movs	r2, #31
    4208:	1a12      	subs	r2, r2, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
		free_list_add_bidx(h, c, bidx);
    420a:	0029      	movs	r1, r5
    420c:	0020      	movs	r0, r4
    420e:	f7ff ff85 	bl	411c <free_list_add_bidx>
	}
}
    4212:	bd70      	pop	{r4, r5, r6, pc}
		return ((uint16_t *)cmem)[f];
    4214:	885b      	ldrh	r3, [r3, #2]
    4216:	e7ea      	b.n	41ee <free_list_add+0x34>
	return big_heap(h) ? 8 : 4;
    4218:	2004      	movs	r0, #4
    421a:	e7ee      	b.n	41fa <free_list_add+0x40>

0000421c <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    421c:	b5f0      	push	{r4, r5, r6, r7, lr}
    421e:	46c6      	mov	lr, r8
    4220:	b500      	push	{lr}
	return big_heap_bytes(size) ? 8 : 4;
    4222:	2380      	movs	r3, #128	; 0x80
    4224:	02db      	lsls	r3, r3, #11
    4226:	429a      	cmp	r2, r3
    4228:	d329      	bcc.n	427e <sys_heap_init+0x62>
    422a:	2508      	movs	r5, #8
	/* Must fit in a 31 bit count of HUNK_UNIT */
	__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    422c:	1b55      	subs	r5, r2, r5

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    422e:	1dcc      	adds	r4, r1, #7
    4230:	2307      	movs	r3, #7
    4232:	439c      	bics	r4, r3
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    4234:	1949      	adds	r1, r1, r5
    4236:	4399      	bics	r1, r3
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    4238:	1b0b      	subs	r3, r1, r4
    423a:	4698      	mov	r8, r3
    423c:	08dd      	lsrs	r5, r3, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
    423e:	0027      	movs	r7, r4
	heap->heap = h;
    4240:	6004      	str	r4, [r0, #0]
	h->end_chunk = heap_sz;
    4242:	60a5      	str	r5, [r4, #8]
	h->avail_buckets = 0;
    4244:	2300      	movs	r3, #0
    4246:	60e3      	str	r3, [r4, #12]
	return big_heap(h) ? 8 : 4;
    4248:	2380      	movs	r3, #128	; 0x80
    424a:	021b      	lsls	r3, r3, #8
    424c:	429d      	cmp	r5, r3
    424e:	d318      	bcc.n	4282 <sys_heap_init+0x66>
    4250:	2008      	movs	r0, #8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    4252:	3008      	adds	r0, #8
    4254:	08c0      	lsrs	r0, r0, #3
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    4256:	1a28      	subs	r0, r5, r0
    4258:	3001      	adds	r0, #1
	return 31 - __builtin_clz(usable_sz);
    425a:	f7fb ff27 	bl	ac <__clzsi2>

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    425e:	2320      	movs	r3, #32
    4260:	1a18      	subs	r0, r3, r0
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    4262:	1d01      	adds	r1, r0, #4
    4264:	0089      	lsls	r1, r1, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    4266:	3107      	adds	r1, #7
    4268:	08cb      	lsrs	r3, r1, #3
    426a:	469c      	mov	ip, r3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    426c:	2300      	movs	r3, #0
    426e:	4283      	cmp	r3, r0
    4270:	da09      	bge.n	4286 <sys_heap_init+0x6a>
		h->buckets[i].next = 0;
    4272:	1d1a      	adds	r2, r3, #4
    4274:	0092      	lsls	r2, r2, #2
    4276:	2600      	movs	r6, #0
    4278:	51d6      	str	r6, [r2, r7]
	for (int i = 0; i < nb_buckets; i++) {
    427a:	3301      	adds	r3, #1
    427c:	e7f7      	b.n	426e <sys_heap_init+0x52>
	return big_heap_bytes(size) ? 8 : 4;
    427e:	2504      	movs	r5, #4
    4280:	e7d4      	b.n	422c <sys_heap_init+0x10>
	return big_heap(h) ? 8 : 4;
    4282:	2004      	movs	r0, #4
    4284:	e7e5      	b.n	4252 <sys_heap_init+0x36>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    4286:	4663      	mov	r3, ip
    4288:	005b      	lsls	r3, r3, #1
	if (big_heap(h)) {
    428a:	2280      	movs	r2, #128	; 0x80
    428c:	0212      	lsls	r2, r2, #8
    428e:	4295      	cmp	r5, r2
    4290:	d341      	bcc.n	4316 <sys_heap_init+0xfa>
		((uint32_t *)cmem)[f] = val;
    4292:	6063      	str	r3, [r4, #4]
	if (big_heap(h)) {
    4294:	2380      	movs	r3, #128	; 0x80
    4296:	021b      	lsls	r3, r3, #8
    4298:	429d      	cmp	r5, r3
    429a:	d33e      	bcc.n	431a <sys_heap_init+0xfe>
		((uint32_t *)cmem)[f] = val;
    429c:	2300      	movs	r3, #0
    429e:	6023      	str	r3, [r4, #0]
	if (big_heap(h)) {
    42a0:	2380      	movs	r3, #128	; 0x80
    42a2:	021b      	lsls	r3, r3, #8
    42a4:	429d      	cmp	r5, r3
    42a6:	d33b      	bcc.n	4320 <sys_heap_init+0x104>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    42a8:	2301      	movs	r3, #1
    42aa:	6862      	ldr	r2, [r4, #4]
    42ac:	4313      	orrs	r3, r2
    42ae:	6063      	str	r3, [r4, #4]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    42b0:	4663      	mov	r3, ip
    42b2:	1aea      	subs	r2, r5, r3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    42b4:	0050      	lsls	r0, r2, #1
	void *cmem = &buf[c];
    42b6:	2307      	movs	r3, #7
    42b8:	4399      	bics	r1, r3
    42ba:	1863      	adds	r3, r4, r1
	if (big_heap(h)) {
    42bc:	2180      	movs	r1, #128	; 0x80
    42be:	0209      	lsls	r1, r1, #8
    42c0:	428d      	cmp	r5, r1
    42c2:	d332      	bcc.n	432a <sys_heap_init+0x10e>
		((uint32_t *)cmem)[f] = val;
    42c4:	6058      	str	r0, [r3, #4]
	if (big_heap(h)) {
    42c6:	2180      	movs	r1, #128	; 0x80
    42c8:	0209      	lsls	r1, r1, #8
    42ca:	68a0      	ldr	r0, [r4, #8]
    42cc:	4288      	cmp	r0, r1
    42ce:	d32e      	bcc.n	432e <sys_heap_init+0x112>
		((uint32_t *)cmem)[f] = val;
    42d0:	4661      	mov	r1, ip
    42d2:	6019      	str	r1, [r3, #0]
	void *cmem = &buf[c];
    42d4:	2307      	movs	r3, #7
    42d6:	4645      	mov	r5, r8
    42d8:	439d      	bics	r5, r3
    42da:	1965      	adds	r5, r4, r5
	if (big_heap(h)) {
    42dc:	2380      	movs	r3, #128	; 0x80
    42de:	021b      	lsls	r3, r3, #8
    42e0:	68a1      	ldr	r1, [r4, #8]
    42e2:	4299      	cmp	r1, r3
    42e4:	d326      	bcc.n	4334 <sys_heap_init+0x118>
		((uint32_t *)cmem)[f] = val;
    42e6:	2300      	movs	r3, #0
    42e8:	606b      	str	r3, [r5, #4]
	if (big_heap(h)) {
    42ea:	2380      	movs	r3, #128	; 0x80
    42ec:	021b      	lsls	r3, r3, #8
    42ee:	68a1      	ldr	r1, [r4, #8]
    42f0:	4299      	cmp	r1, r3
    42f2:	d322      	bcc.n	433a <sys_heap_init+0x11e>
		((uint32_t *)cmem)[f] = val;
    42f4:	602a      	str	r2, [r5, #0]
	if (big_heap(h)) {
    42f6:	2380      	movs	r3, #128	; 0x80
    42f8:	021b      	lsls	r3, r3, #8
    42fa:	68a2      	ldr	r2, [r4, #8]
    42fc:	429a      	cmp	r2, r3
    42fe:	d31e      	bcc.n	433e <sys_heap_init+0x122>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    4300:	2301      	movs	r3, #1
    4302:	686a      	ldr	r2, [r5, #4]
    4304:	4313      	orrs	r3, r2
    4306:	606b      	str	r3, [r5, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
    4308:	4661      	mov	r1, ip
    430a:	0020      	movs	r0, r4
    430c:	f7ff ff55 	bl	41ba <free_list_add>
}
    4310:	bc04      	pop	{r2}
    4312:	4690      	mov	r8, r2
    4314:	bdf0      	pop	{r4, r5, r6, r7, pc}
		((uint16_t *)cmem)[f] = val;
    4316:	8063      	strh	r3, [r4, #2]
    4318:	e7bc      	b.n	4294 <sys_heap_init+0x78>
    431a:	2300      	movs	r3, #0
    431c:	8023      	strh	r3, [r4, #0]
    431e:	e7bf      	b.n	42a0 <sys_heap_init+0x84>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    4320:	8863      	ldrh	r3, [r4, #2]
    4322:	2201      	movs	r2, #1
    4324:	4313      	orrs	r3, r2
    4326:	8063      	strh	r3, [r4, #2]
    4328:	e7c2      	b.n	42b0 <sys_heap_init+0x94>
		((uint16_t *)cmem)[f] = val;
    432a:	8058      	strh	r0, [r3, #2]
    432c:	e7cb      	b.n	42c6 <sys_heap_init+0xaa>
    432e:	4661      	mov	r1, ip
    4330:	8019      	strh	r1, [r3, #0]
    4332:	e7cf      	b.n	42d4 <sys_heap_init+0xb8>
    4334:	2300      	movs	r3, #0
    4336:	806b      	strh	r3, [r5, #2]
    4338:	e7d7      	b.n	42ea <sys_heap_init+0xce>
    433a:	802a      	strh	r2, [r5, #0]
    433c:	e7db      	b.n	42f6 <sys_heap_init+0xda>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    433e:	886b      	ldrh	r3, [r5, #2]
    4340:	2201      	movs	r2, #1
    4342:	4313      	orrs	r3, r2
    4344:	806b      	strh	r3, [r5, #2]
    4346:	e7df      	b.n	4308 <sys_heap_init+0xec>

00004348 <extract_decimal>:
{
    4348:	b510      	push	{r4, lr}
    434a:	0004      	movs	r4, r0
	const char *sp = *str;
    434c:	6802      	ldr	r2, [r0, #0]
	size_t val = 0;
    434e:	2000      	movs	r0, #0
	while (isdigit((int)(unsigned char)*sp)) {
    4350:	7811      	ldrb	r1, [r2, #0]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    4352:	000b      	movs	r3, r1
    4354:	3b30      	subs	r3, #48	; 0x30
    4356:	2b09      	cmp	r3, #9
    4358:	d807      	bhi.n	436a <extract_decimal+0x22>
		val = 10U * val + *sp++ - '0';
    435a:	0083      	lsls	r3, r0, #2
    435c:	181b      	adds	r3, r3, r0
    435e:	005b      	lsls	r3, r3, #1
    4360:	3201      	adds	r2, #1
    4362:	185b      	adds	r3, r3, r1
    4364:	3b30      	subs	r3, #48	; 0x30
    4366:	0018      	movs	r0, r3
    4368:	e7f2      	b.n	4350 <extract_decimal+0x8>
	*str = sp;
    436a:	6022      	str	r2, [r4, #0]
}
    436c:	bd10      	pop	{r4, pc}

0000436e <encode_uint>:
{
    436e:	b5f0      	push	{r4, r5, r6, r7, lr}
    4370:	46de      	mov	lr, fp
    4372:	4657      	mov	r7, sl
    4374:	464e      	mov	r6, r9
    4376:	4645      	mov	r5, r8
    4378:	b5e0      	push	{r5, r6, r7, lr}
    437a:	b083      	sub	sp, #12
    437c:	0006      	movs	r6, r0
    437e:	000c      	movs	r4, r1
    4380:	9201      	str	r2, [sp, #4]
    4382:	469a      	mov	sl, r3
    4384:	9d0c      	ldr	r5, [sp, #48]	; 0x30
	bool upcase = isupper((int)conv->specifier);
    4386:	78d3      	ldrb	r3, [r2, #3]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    4388:	2241      	movs	r2, #65	; 0x41
    438a:	4252      	negs	r2, r2
    438c:	4693      	mov	fp, r2
    438e:	449b      	add	fp, r3
	switch (specifier) {
    4390:	2b6f      	cmp	r3, #111	; 0x6f
    4392:	d00f      	beq.n	43b4 <encode_uint+0x46>
    4394:	d906      	bls.n	43a4 <encode_uint+0x36>
    4396:	2b70      	cmp	r3, #112	; 0x70
    4398:	d00f      	beq.n	43ba <encode_uint+0x4c>
    439a:	2b78      	cmp	r3, #120	; 0x78
    439c:	d110      	bne.n	43c0 <encode_uint+0x52>
		return 16;
    439e:	3b68      	subs	r3, #104	; 0x68
    43a0:	4698      	mov	r8, r3
    43a2:	e025      	b.n	43f0 <encode_uint+0x82>
	switch (specifier) {
    43a4:	2b58      	cmp	r3, #88	; 0x58
    43a6:	d002      	beq.n	43ae <encode_uint+0x40>
    43a8:	230a      	movs	r3, #10
    43aa:	4698      	mov	r8, r3
    43ac:	e020      	b.n	43f0 <encode_uint+0x82>
		return 16;
    43ae:	3b48      	subs	r3, #72	; 0x48
    43b0:	4698      	mov	r8, r3
    43b2:	e01d      	b.n	43f0 <encode_uint+0x82>
		return 8;
    43b4:	2308      	movs	r3, #8
    43b6:	4698      	mov	r8, r3
    43b8:	e01a      	b.n	43f0 <encode_uint+0x82>
		return 16;
    43ba:	2310      	movs	r3, #16
    43bc:	4698      	mov	r8, r3
    43be:	e017      	b.n	43f0 <encode_uint+0x82>
	switch (specifier) {
    43c0:	230a      	movs	r3, #10
    43c2:	4698      	mov	r8, r3
	char *bp = bps + (bpe - bps);
    43c4:	e014      	b.n	43f0 <encode_uint+0x82>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    43c6:	465b      	mov	r3, fp
    43c8:	2b19      	cmp	r3, #25
    43ca:	d81f      	bhi.n	440c <encode_uint+0x9e>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    43cc:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    43ce:	3237      	adds	r2, #55	; 0x37
    43d0:	b2d2      	uxtb	r2, r2
    43d2:	3d01      	subs	r5, #1
    43d4:	702a      	strb	r2, [r5, #0]
		value /= radix;
    43d6:	464a      	mov	r2, r9
    43d8:	2300      	movs	r3, #0
    43da:	0030      	movs	r0, r6
    43dc:	0021      	movs	r1, r4
    43de:	f7fb fe83 	bl	e8 <__aeabi_uldivmod>
	} while ((value != 0) && (bps < bp));
    43e2:	42a7      	cmp	r7, r4
    43e4:	d818      	bhi.n	4418 <encode_uint+0xaa>
    43e6:	d015      	beq.n	4414 <encode_uint+0xa6>
    43e8:	4555      	cmp	r5, sl
    43ea:	d915      	bls.n	4418 <encode_uint+0xaa>
		value /= radix;
    43ec:	0006      	movs	r6, r0
    43ee:	000c      	movs	r4, r1
		unsigned int lsv = (unsigned int)(value % radix);
    43f0:	46c1      	mov	r9, r8
    43f2:	2700      	movs	r7, #0
    43f4:	4642      	mov	r2, r8
    43f6:	2300      	movs	r3, #0
    43f8:	0030      	movs	r0, r6
    43fa:	0021      	movs	r1, r4
    43fc:	f7fb fe74 	bl	e8 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    4400:	2a09      	cmp	r2, #9
    4402:	d8e0      	bhi.n	43c6 <encode_uint+0x58>
    4404:	b2d2      	uxtb	r2, r2
    4406:	3230      	adds	r2, #48	; 0x30
    4408:	b2d2      	uxtb	r2, r2
    440a:	e7e2      	b.n	43d2 <encode_uint+0x64>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    440c:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    440e:	3257      	adds	r2, #87	; 0x57
    4410:	b2d2      	uxtb	r2, r2
    4412:	e7de      	b.n	43d2 <encode_uint+0x64>
	} while ((value != 0) && (bps < bp));
    4414:	45b1      	cmp	r9, r6
    4416:	d9e7      	bls.n	43e8 <encode_uint+0x7a>
	if (conv->flag_hash) {
    4418:	9b01      	ldr	r3, [sp, #4]
    441a:	781b      	ldrb	r3, [r3, #0]
    441c:	069b      	lsls	r3, r3, #26
    441e:	d504      	bpl.n	442a <encode_uint+0xbc>
		if (radix == 8) {
    4420:	4643      	mov	r3, r8
    4422:	2b08      	cmp	r3, #8
    4424:	d009      	beq.n	443a <encode_uint+0xcc>
		} else if (radix == 16) {
    4426:	2b10      	cmp	r3, #16
    4428:	d00d      	beq.n	4446 <encode_uint+0xd8>
}
    442a:	0028      	movs	r0, r5
    442c:	b003      	add	sp, #12
    442e:	bc3c      	pop	{r2, r3, r4, r5}
    4430:	4690      	mov	r8, r2
    4432:	4699      	mov	r9, r3
    4434:	46a2      	mov	sl, r4
    4436:	46ab      	mov	fp, r5
    4438:	bdf0      	pop	{r4, r5, r6, r7, pc}
			conv->altform_0 = true;
    443a:	9901      	ldr	r1, [sp, #4]
    443c:	788b      	ldrb	r3, [r1, #2]
    443e:	2208      	movs	r2, #8
    4440:	4313      	orrs	r3, r2
    4442:	708b      	strb	r3, [r1, #2]
    4444:	e7f1      	b.n	442a <encode_uint+0xbc>
			conv->altform_0c = true;
    4446:	9901      	ldr	r1, [sp, #4]
    4448:	788b      	ldrb	r3, [r1, #2]
    444a:	2210      	movs	r2, #16
    444c:	4313      	orrs	r3, r2
    444e:	708b      	strb	r3, [r1, #2]
    4450:	e7eb      	b.n	442a <encode_uint+0xbc>

00004452 <outs>:
{
    4452:	b5f0      	push	{r4, r5, r6, r7, lr}
    4454:	46c6      	mov	lr, r8
    4456:	b500      	push	{lr}
    4458:	0007      	movs	r7, r0
    445a:	000e      	movs	r6, r1
    445c:	4698      	mov	r8, r3
	size_t count = 0;
    445e:	2400      	movs	r4, #0
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    4460:	e007      	b.n	4472 <outs+0x20>
		int rc = out((int)*sp++, ctx);
    4462:	1c55      	adds	r5, r2, #1
    4464:	7810      	ldrb	r0, [r2, #0]
    4466:	0031      	movs	r1, r6
    4468:	47b8      	blx	r7
		if (rc < 0) {
    446a:	2800      	cmp	r0, #0
    446c:	db0a      	blt.n	4484 <outs+0x32>
		++count;
    446e:	3401      	adds	r4, #1
		int rc = out((int)*sp++, ctx);
    4470:	002a      	movs	r2, r5
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    4472:	4542      	cmp	r2, r8
    4474:	d3f5      	bcc.n	4462 <outs+0x10>
    4476:	4643      	mov	r3, r8
    4478:	2b00      	cmp	r3, #0
    447a:	d102      	bne.n	4482 <outs+0x30>
    447c:	7813      	ldrb	r3, [r2, #0]
    447e:	2b00      	cmp	r3, #0
    4480:	d1ef      	bne.n	4462 <outs+0x10>
	return (int)count;
    4482:	0020      	movs	r0, r4
}
    4484:	bc04      	pop	{r2}
    4486:	4690      	mov	r8, r2
    4488:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000448a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    448a:	4770      	bx	lr

0000448c <pm_policy_next_state>:

static const struct pm_state_info pm_min_residency[] =
	PM_STATE_INFO_DT_ITEMS_LIST(DT_NODELABEL(cpu0));

struct pm_state_info pm_policy_next_state(int32_t ticks)
{
    448c:	b510      	push	{r4, lr}
    448e:	0004      	movs	r4, r0
			return pm_min_residency[i];
		}
	}

	LOG_DBG("No suitable power state found!");
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
    4490:	220c      	movs	r2, #12
    4492:	2100      	movs	r1, #0
    4494:	f000 f884 	bl	45a0 <memset>
}
    4498:	0020      	movs	r0, r4
    449a:	bd10      	pop	{r4, pc}

0000449c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    449c:	b510      	push	{r4, lr}

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    449e:	f000 facb 	bl	4a38 <z_fatal_error>
}
    44a2:	bd10      	pop	{r4, pc}

000044a4 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    44a4:	b510      	push	{r4, lr}
    44a6:	0001      	movs	r1, r0
	/* Stacked R0 holds the exception reason. */
	unsigned int reason = esf->basic.r0;
    44a8:	6800      	ldr	r0, [r0, #0]
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
    44aa:	f7ff fff7 	bl	449c <z_arm_fatal_error>

	memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
    44ae:	bd10      	pop	{r4, pc}

000044b0 <z_irq_spurious>:
 * called.
 *
 * @return N/A
 */
void z_irq_spurious(const void *unused)
{
    44b0:	b510      	push	{r4, lr}
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    44b2:	2100      	movs	r1, #0
    44b4:	2001      	movs	r0, #1
    44b6:	f7ff fff1 	bl	449c <z_arm_fatal_error>
}
    44ba:	bd10      	pop	{r4, pc}

000044bc <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    44bc:	b510      	push	{r4, lr}
	handler();
    44be:	f7fc ffc5 	bl	144c <z_SysNmiOnReset>
	z_arm_int_exit();
    44c2:	f7fd f86f 	bl	15a4 <z_arm_exc_exit>
}
    44c6:	bd10      	pop	{r4, pc}

000044c8 <relocate_vector_table>:
	size_t vector_size = (size_t)_vector_end - (size_t)_vector_start;
	(void)memcpy(VECTOR_ADDRESS, _vector_start, vector_size);
#elif defined(CONFIG_SW_VECTOR_RELAY) || defined(CONFIG_SW_VECTOR_RELAY_CLIENT)
	_vector_table_pointer = _vector_start;
#endif
}
    44c8:	4770      	bx	lr

000044ca <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    44ca:	b510      	push	{r4, lr}
	relocate_vector_table();
    44cc:	f7ff fffc 	bl	44c8 <relocate_vector_table>
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    44d0:	f7fe fe38 	bl	3144 <z_bss_zero>
	z_data_copy();
    44d4:	f7ff fafe 	bl	3ad4 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    44d8:	f7fd f8de 	bl	1698 <z_arm_interrupt_init>
	z_cstart();
    44dc:	f7fe fe3e 	bl	315c <z_cstart>

000044e0 <memory_fault_recoverable>:
}
    44e0:	2000      	movs	r0, #0
    44e2:	4770      	bx	lr

000044e4 <fault_handle>:
{
    44e4:	b510      	push	{r4, lr}
	*recoverable = false;
    44e6:	2300      	movs	r3, #0
    44e8:	7013      	strb	r3, [r2, #0]
	switch (fault) {
    44ea:	2903      	cmp	r1, #3
    44ec:	d001      	beq.n	44f2 <fault_handle+0xe>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    44ee:	2000      	movs	r0, #0
}
    44f0:	bd10      	pop	{r4, pc}
		reason = hard_fault(esf, recoverable);
    44f2:	0011      	movs	r1, r2
    44f4:	f7fd f866 	bl	15c4 <hard_fault>
		break;
    44f8:	e7fa      	b.n	44f0 <fault_handle+0xc>

000044fa <z_arm_fault_init>:
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    44fa:	4770      	bx	lr

000044fc <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
    44fc:	b510      	push	{r4, lr}
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    44fe:	0003      	movs	r3, r0
    4500:	2a00      	cmp	r2, #0
    4502:	d00b      	beq.n	451c <strncpy+0x20>
    4504:	780c      	ldrb	r4, [r1, #0]
    4506:	2c00      	cmp	r4, #0
    4508:	d008      	beq.n	451c <strncpy+0x20>
		*d = *s;
    450a:	701c      	strb	r4, [r3, #0]
		s++;
    450c:	3101      	adds	r1, #1
		d++;
    450e:	3301      	adds	r3, #1
		n--;
    4510:	3a01      	subs	r2, #1
    4512:	e7f5      	b.n	4500 <strncpy+0x4>
	}

	while (n > 0) {
		*d = '\0';
    4514:	2100      	movs	r1, #0
    4516:	7019      	strb	r1, [r3, #0]
		d++;
    4518:	3301      	adds	r3, #1
		n--;
    451a:	3a01      	subs	r2, #1
	while (n > 0) {
    451c:	2a00      	cmp	r2, #0
    451e:	d1f9      	bne.n	4514 <strncpy+0x18>
	}

	return dest;
}
    4520:	bd10      	pop	{r4, pc}

00004522 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    4522:	0003      	movs	r3, r0
	size_t n = 0;
    4524:	2000      	movs	r0, #0

	while (*s != '\0') {
    4526:	781a      	ldrb	r2, [r3, #0]
    4528:	2a00      	cmp	r2, #0
    452a:	d002      	beq.n	4532 <strlen+0x10>
		s++;
    452c:	3301      	adds	r3, #1
		n++;
    452e:	3001      	adds	r0, #1
    4530:	e7f9      	b.n	4526 <strlen+0x4>
	}

	return n;
}
    4532:	4770      	bx	lr

00004534 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    4534:	0003      	movs	r3, r0
	size_t n = 0;
    4536:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    4538:	781a      	ldrb	r2, [r3, #0]
    453a:	2a00      	cmp	r2, #0
    453c:	d004      	beq.n	4548 <strnlen+0x14>
    453e:	4288      	cmp	r0, r1
    4540:	d202      	bcs.n	4548 <strnlen+0x14>
		s++;
    4542:	3301      	adds	r3, #1
		n++;
    4544:	3001      	adds	r0, #1
    4546:	e7f7      	b.n	4538 <strnlen+0x4>
	}

	return n;
}
    4548:	4770      	bx	lr

0000454a <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    454a:	7803      	ldrb	r3, [r0, #0]
    454c:	780a      	ldrb	r2, [r1, #0]
    454e:	4293      	cmp	r3, r2
    4550:	d104      	bne.n	455c <strcmp+0x12>
    4552:	2b00      	cmp	r3, #0
    4554:	d002      	beq.n	455c <strcmp+0x12>
		s1++;
    4556:	3001      	adds	r0, #1
		s2++;
    4558:	3101      	adds	r1, #1
    455a:	e7f6      	b.n	454a <strcmp>
	}

	return *s1 - *s2;
    455c:	1a98      	subs	r0, r3, r2
}
    455e:	4770      	bx	lr

00004560 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    4560:	b510      	push	{r4, lr}
	const unsigned char *s_byte = (const unsigned char *)s;

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    4562:	0003      	movs	r3, r0
    4564:	404b      	eors	r3, r1
    4566:	079b      	lsls	r3, r3, #30
    4568:	d001      	beq.n	456e <memcpy+0xe>
	unsigned char *d_byte = (unsigned char *)d;
    456a:	0003      	movs	r3, r0
    456c:	e015      	b.n	459a <memcpy+0x3a>
    456e:	0003      	movs	r3, r0

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
    4570:	079c      	lsls	r4, r3, #30
    4572:	d00a      	beq.n	458a <memcpy+0x2a>
			if (n == 0) {
    4574:	2a00      	cmp	r2, #0
    4576:	d012      	beq.n	459e <memcpy+0x3e>
				return d;
			}
			*(d_byte++) = *(s_byte++);
    4578:	780c      	ldrb	r4, [r1, #0]
    457a:	701c      	strb	r4, [r3, #0]
			n--;
    457c:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
    457e:	3101      	adds	r1, #1
    4580:	3301      	adds	r3, #1
    4582:	e7f5      	b.n	4570 <memcpy+0x10>

		mem_word_t *d_word = (mem_word_t *)d_byte;
		const mem_word_t *s_word = (const mem_word_t *)s_byte;

		while (n >= sizeof(mem_word_t)) {
			*(d_word++) = *(s_word++);
    4584:	c910      	ldmia	r1!, {r4}
    4586:	c310      	stmia	r3!, {r4}
			n -= sizeof(mem_word_t);
    4588:	3a04      	subs	r2, #4
		while (n >= sizeof(mem_word_t)) {
    458a:	2a03      	cmp	r2, #3
    458c:	d8fa      	bhi.n	4584 <memcpy+0x24>
    458e:	e004      	b.n	459a <memcpy+0x3a>
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
    4590:	780c      	ldrb	r4, [r1, #0]
    4592:	701c      	strb	r4, [r3, #0]
		n--;
    4594:	3a01      	subs	r2, #1
		*(d_byte++) = *(s_byte++);
    4596:	3101      	adds	r1, #1
    4598:	3301      	adds	r3, #1
	while (n > 0) {
    459a:	2a00      	cmp	r2, #0
    459c:	d1f8      	bne.n	4590 <memcpy+0x30>
	}

	return d;
}
    459e:	bd10      	pop	{r4, pc}

000045a0 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    45a0:	b530      	push	{r4, r5, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    45a2:	b2cc      	uxtb	r4, r1
	unsigned char *d_byte = (unsigned char *)buf;
    45a4:	0003      	movs	r3, r0

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    45a6:	079d      	lsls	r5, r3, #30
    45a8:	d005      	beq.n	45b6 <memset+0x16>
		if (n == 0) {
    45aa:	2a00      	cmp	r2, #0
    45ac:	d013      	beq.n	45d6 <memset+0x36>
			return buf;
		}
		*(d_byte++) = c_byte;
    45ae:	701c      	strb	r4, [r3, #0]
		n--;
    45b0:	3a01      	subs	r2, #1
		*(d_byte++) = c_byte;
    45b2:	3301      	adds	r3, #1
    45b4:	e7f7      	b.n	45a6 <memset+0x6>
	}

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
    45b6:	25ff      	movs	r5, #255	; 0xff
    45b8:	400d      	ands	r5, r1

	c_word |= c_word << 8;
    45ba:	0229      	lsls	r1, r5, #8
    45bc:	430d      	orrs	r5, r1
	c_word |= c_word << 16;
    45be:	0429      	lsls	r1, r5, #16
    45c0:	4329      	orrs	r1, r5
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    45c2:	2a03      	cmp	r2, #3
    45c4:	d905      	bls.n	45d2 <memset+0x32>
		*(d_word++) = c_word;
    45c6:	c302      	stmia	r3!, {r1}
		n -= sizeof(mem_word_t);
    45c8:	3a04      	subs	r2, #4
    45ca:	e7fa      	b.n	45c2 <memset+0x22>

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
		*(d_byte++) = c_byte;
    45cc:	701c      	strb	r4, [r3, #0]
		n--;
    45ce:	3a01      	subs	r2, #1
		*(d_byte++) = c_byte;
    45d0:	3301      	adds	r3, #1
	while (n > 0) {
    45d2:	2a00      	cmp	r2, #0
    45d4:	d1fa      	bne.n	45cc <memset+0x2c>
	}

	return buf;
}
    45d6:	bd30      	pop	{r4, r5, pc}

000045d8 <_stdout_hook_default>:
	return EOF;
    45d8:	2001      	movs	r0, #1
}
    45da:	4240      	negs	r0, r0
    45dc:	4770      	bx	lr

000045de <nordicsemi_nrf51_init>:
    45de:	f3ef 8310 	mrs	r3, PRIMASK
    45e2:	b672      	cpsid	i
	if (key != 0U) {
    45e4:	2b00      	cmp	r3, #0
    45e6:	d102      	bne.n	45ee <nordicsemi_nrf51_init+0x10>
	__asm__ volatile(
    45e8:	b662      	cpsie	i
    45ea:	f3bf 8f6f 	isb	sy
}
    45ee:	2000      	movs	r0, #0
    45f0:	4770      	bx	lr

000045f2 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
    45f2:	b084      	sub	sp, #16
    45f4:	9001      	str	r0, [sp, #4]
    45f6:	9102      	str	r1, [sp, #8]
    45f8:	9203      	str	r2, [sp, #12]
	switch (info.state) {
    45fa:	b2c0      	uxtb	r0, r0
    45fc:	2806      	cmp	r0, #6
    45fe:	d001      	beq.n	4604 <pm_power_state_set+0x12>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
    4600:	b004      	add	sp, #16
    4602:	4770      	bx	lr
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
    4604:	2280      	movs	r2, #128	; 0x80
    4606:	05d2      	lsls	r2, r2, #23
    4608:	23a0      	movs	r3, #160	; 0xa0
    460a:	00db      	lsls	r3, r3, #3
    460c:	2101      	movs	r1, #1
    460e:	50d1      	str	r1, [r2, r3]
  __ASM volatile ("dsb 0xF":::"memory");
    4610:	f3bf 8f4f 	dsb	sy
        __WFE();
    4614:	bf20      	wfe
    while (true)
    4616:	e7fd      	b.n	4614 <pm_power_state_set+0x22>

00004618 <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
    4618:	b084      	sub	sp, #16
    461a:	9001      	str	r0, [sp, #4]
    461c:	9102      	str	r1, [sp, #8]
    461e:	9203      	str	r2, [sp, #12]
    4620:	b662      	cpsie	i
    4622:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    4626:	b004      	add	sp, #16
    4628:	4770      	bx	lr

0000462a <get_sub_data>:
{
    462a:	000b      	movs	r3, r1
	struct nrf_clock_control_data *data = dev->data;
    462c:	6902      	ldr	r2, [r0, #16]
	return &data->subsys[type];
    462e:	0049      	lsls	r1, r1, #1
    4630:	18c9      	adds	r1, r1, r3
    4632:	0089      	lsls	r1, r1, #2
    4634:	3138      	adds	r1, #56	; 0x38
    4636:	1850      	adds	r0, r2, r1
}
    4638:	4770      	bx	lr

0000463a <get_sub_config>:
	const struct nrf_clock_control_config *config =
    463a:	6840      	ldr	r0, [r0, #4]
	return &config->subsys[type];
    463c:	00c9      	lsls	r1, r1, #3
    463e:	1840      	adds	r0, r0, r1
}
    4640:	4770      	bx	lr

00004642 <get_onoff_manager>:
	struct nrf_clock_control_data *data = dev->data;
    4642:	6902      	ldr	r2, [r0, #16]
	return &data->mgr[type];
    4644:	00c8      	lsls	r0, r1, #3
    4646:	1a40      	subs	r0, r0, r1
    4648:	0080      	lsls	r0, r0, #2
    464a:	1810      	adds	r0, r2, r0
}
    464c:	4770      	bx	lr

0000464e <get_status>:
{
    464e:	b510      	push	{r4, lr}
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    4650:	b2c9      	uxtb	r1, r1
	return GET_STATUS(get_sub_data(dev, type)->flags);
    4652:	f7ff ffea 	bl	462a <get_sub_data>
    4656:	6883      	ldr	r3, [r0, #8]
    4658:	2007      	movs	r0, #7
    465a:	4018      	ands	r0, r3
}
    465c:	bd10      	pop	{r4, pc}

0000465e <set_off_state>:
{
    465e:	b530      	push	{r4, r5, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    4660:	f3ef 8310 	mrs	r3, PRIMASK
    4664:	b672      	cpsid	i
	uint32_t current_ctx = GET_CTX(*flags);
    4666:	6802      	ldr	r2, [r0, #0]
    4668:	24c0      	movs	r4, #192	; 0xc0
    466a:	0025      	movs	r5, r4
    466c:	4015      	ands	r5, r2
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    466e:	4214      	tst	r4, r2
    4670:	d001      	beq.n	4676 <set_off_state+0x18>
    4672:	428d      	cmp	r5, r1
    4674:	d108      	bne.n	4688 <set_off_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_OFF;
    4676:	2201      	movs	r2, #1
    4678:	6002      	str	r2, [r0, #0]
	int err = 0;
    467a:	2000      	movs	r0, #0
	if (key != 0U) {
    467c:	2b00      	cmp	r3, #0
    467e:	d102      	bne.n	4686 <set_off_state+0x28>
	__asm__ volatile(
    4680:	b662      	cpsie	i
    4682:	f3bf 8f6f 	isb	sy
}
    4686:	bd30      	pop	{r4, r5, pc}
		err = -EPERM;
    4688:	2001      	movs	r0, #1
    468a:	4240      	negs	r0, r0
    468c:	e7f6      	b.n	467c <set_off_state+0x1e>

0000468e <set_starting_state>:
{
    468e:	b530      	push	{r4, r5, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    4690:	f3ef 8310 	mrs	r3, PRIMASK
    4694:	b672      	cpsid	i
	uint32_t current_ctx = GET_CTX(*flags);
    4696:	6805      	ldr	r5, [r0, #0]
    4698:	24c0      	movs	r4, #192	; 0xc0
    469a:	402c      	ands	r4, r5
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    469c:	2207      	movs	r2, #7
    469e:	402a      	ands	r2, r5
    46a0:	2a01      	cmp	r2, #1
    46a2:	d009      	beq.n	46b8 <set_starting_state+0x2a>
	} else if (current_ctx != ctx) {
    46a4:	428c      	cmp	r4, r1
    46a6:	d00a      	beq.n	46be <set_starting_state+0x30>
		err = -EPERM;
    46a8:	2001      	movs	r0, #1
    46aa:	4240      	negs	r0, r0
	if (key != 0U) {
    46ac:	2b00      	cmp	r3, #0
    46ae:	d102      	bne.n	46b6 <set_starting_state+0x28>
	__asm__ volatile(
    46b0:	b662      	cpsie	i
    46b2:	f3bf 8f6f 	isb	sy
}
    46b6:	bd30      	pop	{r4, r5, pc}
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    46b8:	6001      	str	r1, [r0, #0]
	int err = 0;
    46ba:	2000      	movs	r0, #0
    46bc:	e7f6      	b.n	46ac <set_starting_state+0x1e>
		err = -EALREADY;
    46be:	2078      	movs	r0, #120	; 0x78
    46c0:	4240      	negs	r0, r0
    46c2:	e7f3      	b.n	46ac <set_starting_state+0x1e>

000046c4 <set_on_state>:
	__asm__ volatile("mrs %0, PRIMASK;"
    46c4:	f3ef 8210 	mrs	r2, PRIMASK
    46c8:	b672      	cpsid	i
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    46ca:	23c0      	movs	r3, #192	; 0xc0
    46cc:	6801      	ldr	r1, [r0, #0]
    46ce:	400b      	ands	r3, r1
    46d0:	2102      	movs	r1, #2
    46d2:	430b      	orrs	r3, r1
    46d4:	6003      	str	r3, [r0, #0]
	if (key != 0U) {
    46d6:	2a00      	cmp	r2, #0
    46d8:	d102      	bne.n	46e0 <set_on_state+0x1c>
	__asm__ volatile(
    46da:	b662      	cpsie	i
    46dc:	f3bf 8f6f 	isb	sy
}
    46e0:	4770      	bx	lr

000046e2 <clkstarted_handle>:
{
    46e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    46e4:	0004      	movs	r4, r0
    46e6:	000d      	movs	r5, r1
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    46e8:	f7ff ff9f 	bl	462a <get_sub_data>
	clock_control_cb_t callback = sub_data->cb;
    46ec:	6806      	ldr	r6, [r0, #0]
	void *user_data = sub_data->user_data;
    46ee:	6847      	ldr	r7, [r0, #4]
	sub_data->cb = NULL;
    46f0:	2300      	movs	r3, #0
    46f2:	6003      	str	r3, [r0, #0]
	set_on_state(&sub_data->flags);
    46f4:	3008      	adds	r0, #8
    46f6:	f7ff ffe5 	bl	46c4 <set_on_state>
	if (callback) {
    46fa:	2e00      	cmp	r6, #0
    46fc:	d003      	beq.n	4706 <clkstarted_handle+0x24>
		callback(dev, (clock_control_subsys_t)type, user_data);
    46fe:	003a      	movs	r2, r7
    4700:	0029      	movs	r1, r5
    4702:	0020      	movs	r0, r4
    4704:	47b0      	blx	r6
}
    4706:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00004708 <stop>:
{
    4708:	b570      	push	{r4, r5, r6, lr}
    470a:	0004      	movs	r4, r0
    470c:	0016      	movs	r6, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    470e:	b2cd      	uxtb	r5, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    4710:	0029      	movs	r1, r5
    4712:	f7ff ff8a 	bl	462a <get_sub_data>
	err = set_off_state(&subdata->flags, ctx);
    4716:	3008      	adds	r0, #8
    4718:	0031      	movs	r1, r6
    471a:	f7ff ffa0 	bl	465e <set_off_state>
	if (err < 0) {
    471e:	2800      	cmp	r0, #0
    4720:	db06      	blt.n	4730 <stop+0x28>
	get_sub_config(dev, type)->stop();
    4722:	0029      	movs	r1, r5
    4724:	0020      	movs	r0, r4
    4726:	f7ff ff88 	bl	463a <get_sub_config>
    472a:	6843      	ldr	r3, [r0, #4]
    472c:	4798      	blx	r3
	return 0;
    472e:	2000      	movs	r0, #0
}
    4730:	bd70      	pop	{r4, r5, r6, pc}

00004732 <api_stop>:
{
    4732:	b510      	push	{r4, lr}
	return stop(dev, subsys, CTX_API);
    4734:	2280      	movs	r2, #128	; 0x80
    4736:	f7ff ffe7 	bl	4708 <stop>
}
    473a:	bd10      	pop	{r4, pc}

0000473c <async_start>:
{
    473c:	b5f0      	push	{r4, r5, r6, r7, lr}
    473e:	b083      	sub	sp, #12
    4740:	0007      	movs	r7, r0
    4742:	0015      	movs	r5, r2
    4744:	9301      	str	r3, [sp, #4]
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    4746:	b2cc      	uxtb	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    4748:	0021      	movs	r1, r4
    474a:	f7ff ff6e 	bl	462a <get_sub_data>
    474e:	0006      	movs	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
    4750:	3008      	adds	r0, #8
    4752:	9908      	ldr	r1, [sp, #32]
    4754:	f7ff ff9b 	bl	468e <set_starting_state>
	if (err < 0) {
    4758:	2800      	cmp	r0, #0
    475a:	db09      	blt.n	4770 <async_start+0x34>
	subdata->cb = cb;
    475c:	6035      	str	r5, [r6, #0]
	subdata->user_data = user_data;
    475e:	9b01      	ldr	r3, [sp, #4]
    4760:	6073      	str	r3, [r6, #4]
	 get_sub_config(dev, type)->start();
    4762:	0021      	movs	r1, r4
    4764:	0038      	movs	r0, r7
    4766:	f7ff ff68 	bl	463a <get_sub_config>
    476a:	6803      	ldr	r3, [r0, #0]
    476c:	4798      	blx	r3
	return 0;
    476e:	2000      	movs	r0, #0
}
    4770:	b003      	add	sp, #12
    4772:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004774 <api_start>:
{
    4774:	b510      	push	{r4, lr}
    4776:	b082      	sub	sp, #8
	return async_start(dev, subsys, cb, user_data, CTX_API);
    4778:	2480      	movs	r4, #128	; 0x80
    477a:	9400      	str	r4, [sp, #0]
    477c:	f7ff ffde 	bl	473c <async_start>
}
    4780:	b002      	add	sp, #8
    4782:	bd10      	pop	{r4, pc}

00004784 <onoff_started_callback>:
{
    4784:	b510      	push	{r4, lr}
    4786:	0014      	movs	r4, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)sys;
    4788:	b2c9      	uxtb	r1, r1
	struct onoff_manager *mgr = get_onoff_manager(dev, type);
    478a:	f7ff ff5a 	bl	4642 <get_onoff_manager>
	notify(mgr, 0);
    478e:	2100      	movs	r1, #0
    4790:	47a0      	blx	r4
}
    4792:	bd10      	pop	{r4, pc}

00004794 <hfclk_start>:
{
    4794:	b510      	push	{r4, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    4796:	2001      	movs	r0, #1
    4798:	f7fe fa62 	bl	2c60 <nrfx_clock_start>
}
    479c:	bd10      	pop	{r4, pc}

0000479e <lfclk_start>:
{
    479e:	b510      	push	{r4, lr}
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    47a0:	2000      	movs	r0, #0
    47a2:	f7fe fa5d 	bl	2c60 <nrfx_clock_start>
}
    47a6:	bd10      	pop	{r4, pc}

000047a8 <hfclk_stop>:
{
    47a8:	b510      	push	{r4, lr}
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    47aa:	2001      	movs	r0, #1
    47ac:	f7fe fa94 	bl	2cd8 <nrfx_clock_stop>
}
    47b0:	bd10      	pop	{r4, pc}

000047b2 <lfclk_stop>:
{
    47b2:	b510      	push	{r4, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    47b4:	2000      	movs	r0, #0
    47b6:	f7fe fa8f 	bl	2cd8 <nrfx_clock_stop>
}
    47ba:	bd10      	pop	{r4, pc}

000047bc <blocking_start_callback>:
{
    47bc:	b510      	push	{r4, lr}
    47be:	0010      	movs	r0, r2
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    47c0:	f7fe fdd8 	bl	3374 <z_impl_k_sem_give>
}
    47c4:	bd10      	pop	{r4, pc}

000047c6 <debug_hook_out_nop>:
}
    47c6:	2000      	movs	r0, #0
    47c8:	4770      	bx	lr

000047ca <gpio_nrfx_port_get_raw>:
	return port->config;
    47ca:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    47cc:	685a      	ldr	r2, [r3, #4]
    return p_reg->IN;
    47ce:	23a2      	movs	r3, #162	; 0xa2
    47d0:	00db      	lsls	r3, r3, #3
    47d2:	58d3      	ldr	r3, [r2, r3]
	*value = nrf_gpio_port_in_read(reg);
    47d4:	600b      	str	r3, [r1, #0]
}
    47d6:	2000      	movs	r0, #0
    47d8:	4770      	bx	lr

000047da <gpio_nrfx_port_set_bits_raw>:
	return port->config;
    47da:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    47dc:	685a      	ldr	r2, [r3, #4]
    p_reg->OUTSET = set_mask;
    47de:	23a1      	movs	r3, #161	; 0xa1
    47e0:	00db      	lsls	r3, r3, #3
    47e2:	50d1      	str	r1, [r2, r3]
}
    47e4:	2000      	movs	r0, #0
    47e6:	4770      	bx	lr

000047e8 <gpio_nrfx_manage_callback>:
{
    47e8:	b570      	push	{r4, r5, r6, lr}
	return port->data;
    47ea:	6900      	ldr	r0, [r0, #16]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    47ec:	1d05      	adds	r5, r0, #4
	return list->head;
    47ee:	6843      	ldr	r3, [r0, #4]
	if (!sys_slist_is_empty(callbacks)) {
    47f0:	2b00      	cmp	r3, #0
    47f2:	d01d      	beq.n	4830 <gpio_nrfx_manage_callback+0x48>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
    47f4:	000e      	movs	r6, r1
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    47f6:	2400      	movs	r4, #0
    47f8:	e00a      	b.n	4810 <gpio_nrfx_manage_callback+0x28>
	return node->next;
    47fa:	680b      	ldr	r3, [r1, #0]
	list->head = node;
    47fc:	6043      	str	r3, [r0, #4]
Z_GENLIST_REMOVE(slist, snode)
    47fe:	686c      	ldr	r4, [r5, #4]
    4800:	42a6      	cmp	r6, r4
    4802:	d110      	bne.n	4826 <gpio_nrfx_manage_callback+0x3e>
	list->tail = node;
    4804:	606b      	str	r3, [r5, #4]
}
    4806:	e00e      	b.n	4826 <gpio_nrfx_manage_callback+0x3e>
	list->tail = node;
    4808:	606c      	str	r4, [r5, #4]
}
    480a:	e00c      	b.n	4826 <gpio_nrfx_manage_callback+0x3e>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    480c:	001c      	movs	r4, r3
    480e:	681b      	ldr	r3, [r3, #0]
    4810:	2b00      	cmp	r3, #0
    4812:	d00b      	beq.n	482c <gpio_nrfx_manage_callback+0x44>
    4814:	429e      	cmp	r6, r3
    4816:	d1f9      	bne.n	480c <gpio_nrfx_manage_callback+0x24>
Z_GENLIST_REMOVE(slist, snode)
    4818:	2c00      	cmp	r4, #0
    481a:	d0ee      	beq.n	47fa <gpio_nrfx_manage_callback+0x12>
	parent->next = child;
    481c:	680b      	ldr	r3, [r1, #0]
    481e:	6023      	str	r3, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
    4820:	686b      	ldr	r3, [r5, #4]
    4822:	429e      	cmp	r6, r3
    4824:	d0f0      	beq.n	4808 <gpio_nrfx_manage_callback+0x20>
	parent->next = child;
    4826:	2300      	movs	r3, #0
    4828:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    482a:	e001      	b.n	4830 <gpio_nrfx_manage_callback+0x48>
			if (!set) {
    482c:	2a00      	cmp	r2, #0
    482e:	d00c      	beq.n	484a <gpio_nrfx_manage_callback+0x62>
	if (set) {
    4830:	2a00      	cmp	r2, #0
    4832:	d00d      	beq.n	4850 <gpio_nrfx_manage_callback+0x68>
	parent->next = child;
    4834:	6843      	ldr	r3, [r0, #4]
    4836:	600b      	str	r3, [r1, #0]
	list->head = node;
    4838:	6041      	str	r1, [r0, #4]
Z_GENLIST_PREPEND(slist, snode)
    483a:	686b      	ldr	r3, [r5, #4]
    483c:	2b00      	cmp	r3, #0
    483e:	d001      	beq.n	4844 <gpio_nrfx_manage_callback+0x5c>
	return 0;
    4840:	2000      	movs	r0, #0
    4842:	e006      	b.n	4852 <gpio_nrfx_manage_callback+0x6a>
	list->tail = node;
    4844:	6069      	str	r1, [r5, #4]
    4846:	2000      	movs	r0, #0
}
    4848:	e003      	b.n	4852 <gpio_nrfx_manage_callback+0x6a>
				return -EINVAL;
    484a:	2016      	movs	r0, #22
    484c:	4240      	negs	r0, r0
    484e:	e000      	b.n	4852 <gpio_nrfx_manage_callback+0x6a>
	return 0;
    4850:	2000      	movs	r0, #0
}
    4852:	bd70      	pop	{r4, r5, r6, pc}

00004854 <gpio_nrfx_pin_interrupt_configure>:
{
    4854:	b570      	push	{r4, r5, r6, lr}
	return port->data;
    4856:	6904      	ldr	r4, [r0, #16]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    4858:	6845      	ldr	r5, [r0, #4]
    485a:	7a2d      	ldrb	r5, [r5, #8]
    485c:	016d      	lsls	r5, r5, #5
    485e:	261f      	movs	r6, #31
    4860:	400e      	ands	r6, r1
    4862:	4335      	orrs	r5, r6
	if (!IS_ENABLED(CONFIG_GPIO_NRF_INT_EDGE_USING_SENSE) &&
    4864:	26a0      	movs	r6, #160	; 0xa0
    4866:	0276      	lsls	r6, r6, #9
    4868:	42b2      	cmp	r2, r6
    486a:	d029      	beq.n	48c0 <gpio_nrfx_pin_interrupt_configure+0x6c>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    486c:	2580      	movs	r5, #128	; 0x80
    486e:	01ad      	lsls	r5, r5, #6
    4870:	42aa      	cmp	r2, r5
    4872:	d032      	beq.n	48da <gpio_nrfx_pin_interrupt_configure+0x86>
    4874:	2501      	movs	r5, #1
    4876:	408d      	lsls	r5, r1
    4878:	68e6      	ldr	r6, [r4, #12]
    487a:	4335      	orrs	r5, r6
    487c:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    487e:	25a0      	movs	r5, #160	; 0xa0
    4880:	026d      	lsls	r5, r5, #9
    4882:	42aa      	cmp	r2, r5
    4884:	d02f      	beq.n	48e6 <gpio_nrfx_pin_interrupt_configure+0x92>
    4886:	2201      	movs	r2, #1
    4888:	408a      	lsls	r2, r1
    488a:	6965      	ldr	r5, [r4, #20]
    488c:	4395      	bics	r5, r2
    488e:	002a      	movs	r2, r5
    4890:	6162      	str	r2, [r4, #20]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    4892:	22c0      	movs	r2, #192	; 0xc0
    4894:	02d2      	lsls	r2, r2, #11
    4896:	4293      	cmp	r3, r2
    4898:	d02a      	beq.n	48f0 <gpio_nrfx_pin_interrupt_configure+0x9c>
    489a:	2201      	movs	r2, #1
    489c:	408a      	lsls	r2, r1
    489e:	69a5      	ldr	r5, [r4, #24]
    48a0:	4395      	bics	r5, r2
    48a2:	002a      	movs	r2, r5
    48a4:	61a2      	str	r2, [r4, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    48a6:	2280      	movs	r2, #128	; 0x80
    48a8:	02d2      	lsls	r2, r2, #11
    48aa:	4293      	cmp	r3, r2
    48ac:	d025      	beq.n	48fa <gpio_nrfx_pin_interrupt_configure+0xa6>
    48ae:	2301      	movs	r3, #1
    48b0:	408b      	lsls	r3, r1
    48b2:	6922      	ldr	r2, [r4, #16]
    48b4:	439a      	bics	r2, r3
    48b6:	0013      	movs	r3, r2
    48b8:	6123      	str	r3, [r4, #16]
	return gpiote_pin_int_cfg(port, pin);
    48ba:	f7fd fb77 	bl	1fac <gpiote_pin_int_cfg>
}
    48be:	bd70      	pop	{r4, r5, r6, pc}
    *p_pin = pin_number & 0x1F;
    48c0:	261f      	movs	r6, #31
    48c2:	4035      	ands	r5, r6
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    48c4:	35c1      	adds	r5, #193	; 0xc1
    48c6:	35ff      	adds	r5, #255	; 0xff
    48c8:	00ad      	lsls	r5, r5, #2
    48ca:	26a0      	movs	r6, #160	; 0xa0
    48cc:	05f6      	lsls	r6, r6, #23
    48ce:	59ad      	ldr	r5, [r5, r6]
	    (mode == GPIO_INT_MODE_EDGE) &&
    48d0:	07ed      	lsls	r5, r5, #31
    48d2:	d5cb      	bpl.n	486c <gpio_nrfx_pin_interrupt_configure+0x18>
		return -ENOTSUP;
    48d4:	2086      	movs	r0, #134	; 0x86
    48d6:	4240      	negs	r0, r0
    48d8:	e7f1      	b.n	48be <gpio_nrfx_pin_interrupt_configure+0x6a>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    48da:	2501      	movs	r5, #1
    48dc:	408d      	lsls	r5, r1
    48de:	68e6      	ldr	r6, [r4, #12]
    48e0:	43ae      	bics	r6, r5
    48e2:	0035      	movs	r5, r6
    48e4:	e7ca      	b.n	487c <gpio_nrfx_pin_interrupt_configure+0x28>
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    48e6:	2201      	movs	r2, #1
    48e8:	408a      	lsls	r2, r1
    48ea:	6965      	ldr	r5, [r4, #20]
    48ec:	432a      	orrs	r2, r5
    48ee:	e7cf      	b.n	4890 <gpio_nrfx_pin_interrupt_configure+0x3c>
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    48f0:	2201      	movs	r2, #1
    48f2:	408a      	lsls	r2, r1
    48f4:	69a5      	ldr	r5, [r4, #24]
    48f6:	432a      	orrs	r2, r5
    48f8:	e7d4      	b.n	48a4 <gpio_nrfx_pin_interrupt_configure+0x50>
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    48fa:	2301      	movs	r3, #1
    48fc:	408b      	lsls	r3, r1
    48fe:	6922      	ldr	r2, [r4, #16]
    4900:	4313      	orrs	r3, r2
    4902:	e7d9      	b.n	48b8 <gpio_nrfx_pin_interrupt_configure+0x64>

00004904 <uart_nrfx_config_get>:
	return dev->data;
    4904:	6903      	ldr	r3, [r0, #16]
	*cfg = get_dev_data(dev)->uart_config;
    4906:	cb05      	ldmia	r3!, {r0, r2}
    4908:	c105      	stmia	r1!, {r0, r2}
}
    490a:	2000      	movs	r0, #0
    490c:	4770      	bx	lr

0000490e <uart_nrfx_irq_update>:
}
    490e:	2001      	movs	r0, #1
    4910:	4770      	bx	lr

00004912 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
    4912:	4770      	bx	lr

00004914 <counter_sub>:
	return (a - b) & COUNTER_MAX;
    4914:	1a40      	subs	r0, r0, r1
    4916:	0200      	lsls	r0, r0, #8
    4918:	0a00      	lsrs	r0, r0, #8
}
    491a:	4770      	bx	lr

0000491c <absolute_time_to_cc>:
	return absolute_time & COUNTER_MAX;
    491c:	0200      	lsls	r0, r0, #8
    491e:	0a00      	lsrs	r0, r0, #8
}
    4920:	4770      	bx	lr

00004922 <full_int_lock>:
	__asm__ volatile("mrs %0, PRIMASK;"
    4922:	f3ef 8010 	mrs	r0, PRIMASK
    4926:	b672      	cpsid	i
}
    4928:	4770      	bx	lr

0000492a <full_int_unlock>:
	if (key != 0U) {
    492a:	2800      	cmp	r0, #0
    492c:	d102      	bne.n	4934 <full_int_unlock+0xa>
	__asm__ volatile(
    492e:	b662      	cpsie	i
    4930:	f3bf 8f6f 	isb	sy
}
    4934:	4770      	bx	lr

00004936 <set_absolute_alarm>:
{
    4936:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4938:	0006      	movs	r6, r0
	uint32_t cc_val = abs_val & COUNTER_MAX;
    493a:	020d      	lsls	r5, r1, #8
    493c:	0a2d      	lsrs	r5, r5, #8
	uint32_t prev_cc = get_comparator(chan);
    493e:	f7fd fe8b 	bl	2658 <get_comparator>
    4942:	0007      	movs	r7, r0
    4944:	e01a      	b.n	497c <set_absolute_alarm+0x46>
	z_impl_k_busy_wait(usec_to_wait);
    4946:	3012      	adds	r0, #18
    4948:	f000 fa1f 	bl	4d8a <z_impl_k_busy_wait>
}
    494c:	e023      	b.n	4996 <set_absolute_alarm+0x60>
		event_clear(chan);
    494e:	0030      	movs	r0, r6
    4950:	f7fd fe8a 	bl	2668 <event_clear>
		event_enable(chan);
    4954:	0030      	movs	r0, r6
    4956:	f7fd fe93 	bl	2680 <event_enable>
		set_comparator(chan, cc_val);
    495a:	0029      	movs	r1, r5
    495c:	0030      	movs	r0, r6
    495e:	f7fd fe71 	bl	2644 <set_comparator>
		now2 = counter();
    4962:	f7fd fea1 	bl	26a8 <counter>
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    4966:	4284      	cmp	r4, r0
    4968:	d020      	beq.n	49ac <set_absolute_alarm+0x76>
    496a:	1c81      	adds	r1, r0, #2
    496c:	0028      	movs	r0, r5
    496e:	f7ff ffd1 	bl	4914 <counter_sub>
	} while ((now2 != now) &&
    4972:	2380      	movs	r3, #128	; 0x80
    4974:	041b      	lsls	r3, r3, #16
    4976:	4298      	cmp	r0, r3
    4978:	d918      	bls.n	49ac <set_absolute_alarm+0x76>
		prev_cc = cc_val;
    497a:	002f      	movs	r7, r5
		now = counter();
    497c:	f7fd fe94 	bl	26a8 <counter>
    4980:	0004      	movs	r4, r0
		set_comparator(chan, now);
    4982:	0001      	movs	r1, r0
    4984:	0030      	movs	r0, r6
    4986:	f7fd fe5d 	bl	2644 <set_comparator>
		if (counter_sub(prev_cc, now) == 1) {
    498a:	0021      	movs	r1, r4
    498c:	0038      	movs	r0, r7
    498e:	f7ff ffc1 	bl	4914 <counter_sub>
    4992:	2801      	cmp	r0, #1
    4994:	d0d7      	beq.n	4946 <set_absolute_alarm+0x10>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    4996:	1ca7      	adds	r7, r4, #2
    4998:	0039      	movs	r1, r7
    499a:	0028      	movs	r0, r5
    499c:	f7ff ffba 	bl	4914 <counter_sub>
    49a0:	2380      	movs	r3, #128	; 0x80
    49a2:	041b      	lsls	r3, r3, #16
    49a4:	4298      	cmp	r0, r3
    49a6:	d9d2      	bls.n	494e <set_absolute_alarm+0x18>
			cc_val = now + 2;
    49a8:	003d      	movs	r5, r7
    49aa:	e7d0      	b.n	494e <set_absolute_alarm+0x18>
}
    49ac:	0028      	movs	r0, r5
    49ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000049b0 <compare_set>:
{
    49b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    49b2:	b083      	sub	sp, #12
    49b4:	0004      	movs	r4, r0
    49b6:	0017      	movs	r7, r2
    49b8:	001d      	movs	r5, r3
	key = compare_int_lock(chan);
    49ba:	f7fd fe7d 	bl	26b8 <compare_int_lock>
    49be:	0006      	movs	r6, r0
	int ret = compare_set_nolocks(chan, target_time, handler, user_data);
    49c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    49c2:	9301      	str	r3, [sp, #4]
    49c4:	9b08      	ldr	r3, [sp, #32]
    49c6:	9300      	str	r3, [sp, #0]
    49c8:	003a      	movs	r2, r7
    49ca:	002b      	movs	r3, r5
    49cc:	0020      	movs	r0, r4
    49ce:	f7fd ff5b 	bl	2888 <compare_set_nolocks>
    49d2:	0005      	movs	r5, r0
	compare_int_unlock(chan, key);
    49d4:	0031      	movs	r1, r6
    49d6:	0020      	movs	r0, r4
    49d8:	f7fd fec0 	bl	275c <compare_int_unlock>
}
    49dc:	0028      	movs	r0, r5
    49de:	b003      	add	sp, #12
    49e0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000049e2 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
    49e2:	b510      	push	{r4, lr}
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
		sys_arch_reboot(0);
    49e4:	2000      	movs	r0, #0
    49e6:	f7fc fee7 	bl	17b8 <sys_arch_reboot>

000049ea <nrfx_isr>:

#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
    49ea:	b510      	push	{r4, lr}
	((nrfx_irq_handler_t)irq_handler)();
    49ec:	4780      	blx	r0
}
    49ee:	bd10      	pop	{r4, pc}

000049f0 <nrfx_busy_wait>:

void nrfx_busy_wait(uint32_t usec_to_wait)
{
    49f0:	b510      	push	{r4, lr}
	z_impl_k_busy_wait(usec_to_wait);
    49f2:	f000 f9ca 	bl	4d8a <z_impl_k_busy_wait>
	k_busy_wait(usec_to_wait);
}
    49f6:	bd10      	pop	{r4, pc}

000049f8 <nrfx_clock_enable>:
{
    49f8:	b510      	push	{r4, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    49fa:	2000      	movs	r0, #0
    49fc:	f7fc fce8 	bl	13d0 <arch_irq_is_enabled>
    4a00:	2800      	cmp	r0, #0
    4a02:	d000      	beq.n	4a06 <nrfx_clock_enable+0xe>
}
    4a04:	bd10      	pop	{r4, pc}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    4a06:	f7fc fcd7 	bl	13b8 <arch_irq_enable>
    4a0a:	e7fb      	b.n	4a04 <nrfx_clock_enable+0xc>

00004a0c <is_app_channel>:
    return NRFX_GPIOTE_APP_CHANNELS_MASK & (1UL << index);
    4a0c:	2301      	movs	r3, #1
    4a0e:	4083      	lsls	r3, r0
    4a10:	200f      	movs	r0, #15
    4a12:	4018      	ands	r0, r3
    4a14:	1e43      	subs	r3, r0, #1
    4a16:	4198      	sbcs	r0, r3
    4a18:	b2c0      	uxtb	r0, r0
}
    4a1a:	4770      	bx	lr

00004a1c <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    4a1c:	2800      	cmp	r0, #0
    4a1e:	d009      	beq.n	4a34 <z_device_ready+0x18>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    4a20:	68c3      	ldr	r3, [r0, #12]
    4a22:	8818      	ldrh	r0, [r3, #0]
    4a24:	05c0      	lsls	r0, r0, #23
    4a26:	0dc0      	lsrs	r0, r0, #23
    4a28:	3801      	subs	r0, #1
    4a2a:	38ff      	subs	r0, #255	; 0xff
    4a2c:	4243      	negs	r3, r0
    4a2e:	4158      	adcs	r0, r3
    4a30:	b2c0      	uxtb	r0, r0
}
    4a32:	4770      	bx	lr
		return false;
    4a34:	2000      	movs	r0, #0
    4a36:	e7fc      	b.n	4a32 <z_device_ready+0x16>

00004a38 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    4a38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4a3a:	0005      	movs	r5, r0
    4a3c:	000e      	movs	r6, r1
	__asm__ volatile("mrs %0, PRIMASK;"
    4a3e:	f3ef 8710 	mrs	r7, PRIMASK
    4a42:	b672      	cpsid	i
	return z_impl_z_current_get();
    4a44:	f7ff f81a 	bl	3a7c <z_impl_z_current_get>
    4a48:	0004      	movs	r4, r0
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    4a4a:	0031      	movs	r1, r6
    4a4c:	0028      	movs	r0, r5
    4a4e:	f7ff ffc8 	bl	49e2 <k_sys_fatal_error_handler>
	if (key != 0U) {
    4a52:	2f00      	cmp	r7, #0
    4a54:	d102      	bne.n	4a5c <z_fatal_error+0x24>
	__asm__ volatile(
    4a56:	b662      	cpsie	i
    4a58:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    4a5c:	0020      	movs	r0, r4
    4a5e:	f7fc fe8d 	bl	177c <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    4a62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00004a64 <setup_thread_stack>:
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    4a64:	1dd0      	adds	r0, r2, #7
    4a66:	2307      	movs	r3, #7
    4a68:	4398      	bics	r0, r3
	stack_ptr = (char *)stack + stack_obj_size;
    4a6a:	1808      	adds	r0, r1, r0
}
    4a6c:	4770      	bx	lr

00004a6e <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    4a6e:	f3ef 8005 	mrs	r0, IPSR
 * The current executing vector is found in the IPSR register. All
 * IRQs and system exceptions are considered as interrupt context.
 */
static ALWAYS_INLINE bool arch_is_in_isr(void)
{
	return (__get_IPSR()) ? (true) : (false);
    4a72:	1e43      	subs	r3, r0, #1
    4a74:	4198      	sbcs	r0, r3
    4a76:	b2c0      	uxtb	r0, r0
}
    4a78:	4770      	bx	lr

00004a7a <z_impl_k_thread_start>:
{
    4a7a:	b510      	push	{r4, lr}
	z_sched_start(thread);
    4a7c:	f7fe fe4e 	bl	371c <z_sched_start>
}
    4a80:	bd10      	pop	{r4, pc}

00004a82 <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    4a82:	b510      	push	{r4, lr}
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    4a84:	2400      	movs	r4, #0
    4a86:	6084      	str	r4, [r0, #8]
	thread_base->user_options = (uint8_t)options;
    4a88:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    4a8a:	7342      	strb	r2, [r0, #13]

	thread_base->prio = priority;
    4a8c:	7381      	strb	r1, [r0, #14]

	thread_base->sched_locked = 0U;
    4a8e:	73c4      	strb	r4, [r0, #15]
	node->next = NULL;
    4a90:	6184      	str	r4, [r0, #24]
	node->prev = NULL;
    4a92:	61c4      	str	r4, [r0, #28]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    4a94:	bd10      	pop	{r4, pc}

00004a96 <z_pm_save_idle_exit>:

void z_pm_save_idle_exit(int32_t ticks)
{
    4a96:	b510      	push	{r4, lr}
	/* Some CPU low power states require notification at the ISR
	 * to allow any operations that needs to be done before kernel
	 * switches task or processes nested interrupts.
	 * This can be simply ignored if not required.
	 */
	pm_system_resume();
    4a98:	f7fc fbda 	bl	1250 <pm_system_resume>
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
    4a9c:	f7ff ff39 	bl	4912 <sys_clock_idle_exit>
}
    4aa0:	bd10      	pop	{r4, pc}

00004aa2 <idle>:

void idle(void *unused1, void *unused2, void *unused3)
{
    4aa2:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    4aa4:	f3ef 8310 	mrs	r3, PRIMASK
    4aa8:	b672      	cpsid	i
		 * higher level construct.
		 */
		(void) arch_irq_lock();

		if (IS_ENABLED(CONFIG_PM)) {
			pm_save_idle();
    4aaa:	f7fe fc53 	bl	3354 <pm_save_idle>
    4aae:	e7f9      	b.n	4aa4 <idle+0x2>

00004ab0 <thread_active_elsewhere>:
}
    4ab0:	2000      	movs	r0, #0
    4ab2:	4770      	bx	lr

00004ab4 <pended_on_thread>:
	return thread->base.pended_on;
    4ab4:	6880      	ldr	r0, [r0, #8]
}
    4ab6:	4770      	bx	lr

00004ab8 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    4ab8:	230e      	movs	r3, #14
    4aba:	56c3      	ldrsb	r3, [r0, r3]
	int32_t b2 = thread_2->base.prio;
    4abc:	200e      	movs	r0, #14
    4abe:	5608      	ldrsb	r0, [r1, r0]
	if (b1 != b2) {
    4ac0:	4283      	cmp	r3, r0
    4ac2:	d001      	beq.n	4ac8 <z_sched_prio_cmp+0x10>
		return b2 - b1;
    4ac4:	1ac0      	subs	r0, r0, r3
}
    4ac6:	4770      	bx	lr
	return 0;
    4ac8:	2000      	movs	r0, #0
    4aca:	e7fc      	b.n	4ac6 <z_sched_prio_cmp+0xe>

00004acc <z_reschedule_irqlock>:
{
    4acc:	b510      	push	{r4, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    4ace:	2800      	cmp	r0, #0
    4ad0:	d105      	bne.n	4ade <z_reschedule_irqlock+0x12>
    4ad2:	f3ef 8305 	mrs	r3, IPSR
    4ad6:	2b00      	cmp	r3, #0
    4ad8:	d10a      	bne.n	4af0 <z_reschedule_irqlock+0x24>
    4ada:	3301      	adds	r3, #1
    4adc:	e000      	b.n	4ae0 <z_reschedule_irqlock+0x14>
    4ade:	2300      	movs	r3, #0
	if (resched(key)) {
    4ae0:	2b00      	cmp	r3, #0
    4ae2:	d107      	bne.n	4af4 <z_reschedule_irqlock+0x28>
	if (key != 0U) {
    4ae4:	2800      	cmp	r0, #0
    4ae6:	d102      	bne.n	4aee <z_reschedule_irqlock+0x22>
	__asm__ volatile(
    4ae8:	b662      	cpsie	i
    4aea:	f3bf 8f6f 	isb	sy
}
    4aee:	bd10      	pop	{r4, pc}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    4af0:	2300      	movs	r3, #0
    4af2:	e7f5      	b.n	4ae0 <z_reschedule_irqlock+0x14>
	ret = arch_swap(key);
    4af4:	f7fc fcac 	bl	1450 <arch_swap>
	return ret;
    4af8:	e7f9      	b.n	4aee <z_reschedule_irqlock+0x22>

00004afa <z_priq_dumb_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    4afa:	684a      	ldr	r2, [r1, #4]
	sys_dnode_t *const next = node->next;
    4afc:	680b      	ldr	r3, [r1, #0]

	prev->next = next;
    4afe:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    4b00:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    4b02:	2300      	movs	r3, #0
    4b04:	600b      	str	r3, [r1, #0]
	node->prev = NULL;
    4b06:	604b      	str	r3, [r1, #4]
}
    4b08:	4770      	bx	lr

00004b0a <z_priq_dumb_best>:
{
    4b0a:	0003      	movs	r3, r0
	return list->head == list;
    4b0c:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4b0e:	4283      	cmp	r3, r0
    4b10:	d000      	beq.n	4b14 <z_priq_dumb_best+0xa>
}
    4b12:	4770      	bx	lr
	struct k_thread *thread = NULL;
    4b14:	2000      	movs	r0, #0
	return thread;
    4b16:	e7fc      	b.n	4b12 <z_priq_dumb_best+0x8>

00004b18 <z_ready_thread>:
{
    4b18:	b570      	push	{r4, r5, r6, lr}
    4b1a:	0004      	movs	r4, r0
	LOCKED(&sched_spinlock) {
    4b1c:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    4b1e:	f3ef 8510 	mrs	r5, PRIMASK
    4b22:	b672      	cpsid	i
    4b24:	e007      	b.n	4b36 <z_ready_thread+0x1e>
			ready_thread(thread);
    4b26:	0020      	movs	r0, r4
    4b28:	f7fe fdb4 	bl	3694 <ready_thread>
    4b2c:	e00a      	b.n	4b44 <z_ready_thread+0x2c>
	__asm__ volatile(
    4b2e:	b662      	cpsie	i
    4b30:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    4b34:	2301      	movs	r3, #1
    4b36:	2b00      	cmp	r3, #0
    4b38:	d107      	bne.n	4b4a <z_ready_thread+0x32>
		if (!thread_active_elsewhere(thread)) {
    4b3a:	0020      	movs	r0, r4
    4b3c:	f7ff ffb8 	bl	4ab0 <thread_active_elsewhere>
    4b40:	2800      	cmp	r0, #0
    4b42:	d0f0      	beq.n	4b26 <z_ready_thread+0xe>
	if (key != 0U) {
    4b44:	2d00      	cmp	r5, #0
    4b46:	d0f2      	beq.n	4b2e <z_ready_thread+0x16>
    4b48:	e7f4      	b.n	4b34 <z_ready_thread+0x1c>
}
    4b4a:	bd70      	pop	{r4, r5, r6, pc}

00004b4c <z_thread_timeout>:
{
    4b4c:	b570      	push	{r4, r5, r6, lr}
    4b4e:	0004      	movs	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
    4b50:	0005      	movs	r5, r0
    4b52:	3d18      	subs	r5, #24
	LOCKED(&sched_spinlock) {
    4b54:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    4b56:	f3ef 8610 	mrs	r6, PRIMASK
    4b5a:	b672      	cpsid	i
    4b5c:	e01c      	b.n	4b98 <z_thread_timeout+0x4c>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    4b5e:	0028      	movs	r0, r5
    4b60:	f7ff ffa8 	bl	4ab4 <pended_on_thread>
    4b64:	0029      	movs	r1, r5
    4b66:	f7ff ffc8 	bl	4afa <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    4b6a:	7b6b      	ldrb	r3, [r5, #13]
    4b6c:	2202      	movs	r2, #2
    4b6e:	4393      	bics	r3, r2
    4b70:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
    4b72:	2300      	movs	r3, #0
    4b74:	60ab      	str	r3, [r5, #8]
	thread->base.thread_state &= ~_THREAD_PRESTART;
    4b76:	0022      	movs	r2, r4
    4b78:	3a18      	subs	r2, #24
    4b7a:	7b53      	ldrb	r3, [r2, #13]
    4b7c:	2104      	movs	r1, #4
    4b7e:	438b      	bics	r3, r1
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    4b80:	310c      	adds	r1, #12
    4b82:	438b      	bics	r3, r1
    4b84:	7353      	strb	r3, [r2, #13]
			ready_thread(thread);
    4b86:	0028      	movs	r0, r5
    4b88:	f7fe fd84 	bl	3694 <ready_thread>
	if (key != 0U) {
    4b8c:	2e00      	cmp	r6, #0
    4b8e:	d102      	bne.n	4b96 <z_thread_timeout+0x4a>
	__asm__ volatile(
    4b90:	b662      	cpsie	i
    4b92:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    4b96:	2301      	movs	r3, #1
    4b98:	2b00      	cmp	r3, #0
    4b9a:	d10b      	bne.n	4bb4 <z_thread_timeout+0x68>
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    4b9c:	0023      	movs	r3, r4
    4b9e:	3b18      	subs	r3, #24
    4ba0:	7b5b      	ldrb	r3, [r3, #13]
		if (!killed) {
    4ba2:	2228      	movs	r2, #40	; 0x28
    4ba4:	421a      	tst	r2, r3
    4ba6:	d1f1      	bne.n	4b8c <z_thread_timeout+0x40>
			if (thread->base.pended_on != NULL) {
    4ba8:	0023      	movs	r3, r4
    4baa:	3b18      	subs	r3, #24
    4bac:	689b      	ldr	r3, [r3, #8]
    4bae:	2b00      	cmp	r3, #0
    4bb0:	d1d5      	bne.n	4b5e <z_thread_timeout+0x12>
    4bb2:	e7e0      	b.n	4b76 <z_thread_timeout+0x2a>
}
    4bb4:	bd70      	pop	{r4, r5, r6, pc}

00004bb6 <add_to_waitq_locked>:
{
    4bb6:	b570      	push	{r4, r5, r6, lr}
    4bb8:	0005      	movs	r5, r0
    4bba:	000e      	movs	r6, r1
	unready_thread(thread);
    4bbc:	f7fe fdc8 	bl	3750 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    4bc0:	7b6b      	ldrb	r3, [r5, #13]
    4bc2:	2202      	movs	r2, #2
    4bc4:	4313      	orrs	r3, r2
    4bc6:	736b      	strb	r3, [r5, #13]
	if (wait_q != NULL) {
    4bc8:	2e00      	cmp	r6, #0
    4bca:	d018      	beq.n	4bfe <add_to_waitq_locked+0x48>
		thread->base.pended_on = wait_q;
    4bcc:	60ae      	str	r6, [r5, #8]
	return list->head == list;
    4bce:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4bd0:	42a6      	cmp	r6, r4
    4bd2:	d01b      	beq.n	4c0c <add_to_waitq_locked+0x56>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4bd4:	2c00      	cmp	r4, #0
    4bd6:	d00d      	beq.n	4bf4 <add_to_waitq_locked+0x3e>
		if (z_sched_prio_cmp(thread, t) > 0) {
    4bd8:	0021      	movs	r1, r4
    4bda:	0028      	movs	r0, r5
    4bdc:	f7ff ff6c 	bl	4ab8 <z_sched_prio_cmp>
    4be0:	2800      	cmp	r0, #0
    4be2:	dc0d      	bgt.n	4c00 <add_to_waitq_locked+0x4a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    4be4:	2c00      	cmp	r4, #0
    4be6:	d005      	beq.n	4bf4 <add_to_waitq_locked+0x3e>
	return (node == list->tail) ? NULL : node->next;
    4be8:	6872      	ldr	r2, [r6, #4]
    4bea:	4294      	cmp	r4, r2
    4bec:	d002      	beq.n	4bf4 <add_to_waitq_locked+0x3e>
    4bee:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4bf0:	2c00      	cmp	r4, #0
    4bf2:	d1ef      	bne.n	4bd4 <add_to_waitq_locked+0x1e>
	sys_dnode_t *const tail = list->tail;
    4bf4:	6873      	ldr	r3, [r6, #4]
	node->next = list;
    4bf6:	602e      	str	r6, [r5, #0]
	node->prev = tail;
    4bf8:	606b      	str	r3, [r5, #4]
	tail->next = node;
    4bfa:	601d      	str	r5, [r3, #0]
	list->tail = node;
    4bfc:	6075      	str	r5, [r6, #4]
}
    4bfe:	bd70      	pop	{r4, r5, r6, pc}
	sys_dnode_t *const prev = successor->prev;
    4c00:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    4c02:	606b      	str	r3, [r5, #4]
	node->next = successor;
    4c04:	602c      	str	r4, [r5, #0]
	prev->next = node;
    4c06:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    4c08:	6065      	str	r5, [r4, #4]
}
    4c0a:	e7f8      	b.n	4bfe <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4c0c:	2400      	movs	r4, #0
    4c0e:	e7e1      	b.n	4bd4 <add_to_waitq_locked+0x1e>

00004c10 <pend>:
{
    4c10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4c12:	46ce      	mov	lr, r9
    4c14:	4647      	mov	r7, r8
    4c16:	b580      	push	{r7, lr}
    4c18:	0005      	movs	r5, r0
    4c1a:	000f      	movs	r7, r1
    4c1c:	4691      	mov	r9, r2
    4c1e:	4698      	mov	r8, r3
	LOCKED(&sched_spinlock) {
    4c20:	2400      	movs	r4, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    4c22:	f3ef 8610 	mrs	r6, PRIMASK
    4c26:	b672      	cpsid	i
    4c28:	e003      	b.n	4c32 <pend+0x22>
	__asm__ volatile(
    4c2a:	b662      	cpsie	i
    4c2c:	f3bf 8f6f 	isb	sy
    4c30:	2401      	movs	r4, #1
    4c32:	2c00      	cmp	r4, #0
    4c34:	d106      	bne.n	4c44 <pend+0x34>
		add_to_waitq_locked(thread, wait_q);
    4c36:	0039      	movs	r1, r7
    4c38:	0028      	movs	r0, r5
    4c3a:	f7ff ffbc 	bl	4bb6 <add_to_waitq_locked>
	if (key != 0U) {
    4c3e:	2e00      	cmp	r6, #0
    4c40:	d0f3      	beq.n	4c2a <pend+0x1a>
    4c42:	e7f5      	b.n	4c30 <pend+0x20>
	add_thread_timeout(thread, timeout);
    4c44:	464a      	mov	r2, r9
    4c46:	4643      	mov	r3, r8
    4c48:	0028      	movs	r0, r5
    4c4a:	f7fe fbd9 	bl	3400 <add_thread_timeout>
}
    4c4e:	bc0c      	pop	{r2, r3}
    4c50:	4690      	mov	r8, r2
    4c52:	4699      	mov	r9, r3
    4c54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00004c56 <z_unpend_first_thread>:
{
    4c56:	b570      	push	{r4, r5, r6, lr}
    4c58:	0006      	movs	r6, r0
	LOCKED(&sched_spinlock) {
    4c5a:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    4c5c:	f3ef 8510 	mrs	r5, PRIMASK
    4c60:	b672      	cpsid	i
	struct k_thread *thread = NULL;
    4c62:	2400      	movs	r4, #0
    4c64:	e014      	b.n	4c90 <z_unpend_first_thread+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    4c66:	f7ff ff25 	bl	4ab4 <pended_on_thread>
    4c6a:	0021      	movs	r1, r4
    4c6c:	f7ff ff45 	bl	4afa <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    4c70:	7b63      	ldrb	r3, [r4, #13]
    4c72:	2202      	movs	r2, #2
    4c74:	4393      	bics	r3, r2
    4c76:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    4c78:	2300      	movs	r3, #0
    4c7a:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
    4c7c:	0020      	movs	r0, r4
    4c7e:	3018      	adds	r0, #24
    4c80:	f000 f826 	bl	4cd0 <z_abort_timeout>
	if (key != 0U) {
    4c84:	2d00      	cmp	r5, #0
    4c86:	d102      	bne.n	4c8e <z_unpend_first_thread+0x38>
	__asm__ volatile(
    4c88:	b662      	cpsie	i
    4c8a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    4c8e:	2301      	movs	r3, #1
    4c90:	2b00      	cmp	r3, #0
    4c92:	d105      	bne.n	4ca0 <z_unpend_first_thread+0x4a>
		thread = _priq_wait_best(&wait_q->waitq);
    4c94:	0030      	movs	r0, r6
    4c96:	f7ff ff38 	bl	4b0a <z_priq_dumb_best>
    4c9a:	1e04      	subs	r4, r0, #0
		if (thread != NULL) {
    4c9c:	d1e3      	bne.n	4c66 <z_unpend_first_thread+0x10>
    4c9e:	e7f1      	b.n	4c84 <z_unpend_first_thread+0x2e>
}
    4ca0:	0020      	movs	r0, r4
    4ca2:	bd70      	pop	{r4, r5, r6, pc}

00004ca4 <remove_timeout>:
{
    4ca4:	b570      	push	{r4, r5, r6, lr}
    4ca6:	0004      	movs	r4, r0
	if (next(t) != NULL) {
    4ca8:	f7fe ff38 	bl	3b1c <next>
    4cac:	2800      	cmp	r0, #0
    4cae:	d007      	beq.n	4cc0 <remove_timeout+0x1c>
		next(t)->dticks += t->dticks;
    4cb0:	6902      	ldr	r2, [r0, #16]
    4cb2:	6943      	ldr	r3, [r0, #20]
    4cb4:	6925      	ldr	r5, [r4, #16]
    4cb6:	6966      	ldr	r6, [r4, #20]
    4cb8:	1952      	adds	r2, r2, r5
    4cba:	4173      	adcs	r3, r6
    4cbc:	6102      	str	r2, [r0, #16]
    4cbe:	6143      	str	r3, [r0, #20]
	sys_dnode_t *const prev = node->prev;
    4cc0:	6862      	ldr	r2, [r4, #4]
	sys_dnode_t *const next = node->next;
    4cc2:	6823      	ldr	r3, [r4, #0]
	prev->next = next;
    4cc4:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    4cc6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    4cc8:	2300      	movs	r3, #0
    4cca:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
    4ccc:	6063      	str	r3, [r4, #4]
}
    4cce:	bd70      	pop	{r4, r5, r6, pc}

00004cd0 <z_abort_timeout>:
{
    4cd0:	b570      	push	{r4, r5, r6, lr}
    4cd2:	0005      	movs	r5, r0
	LOCKED(&timeout_lock) {
    4cd4:	2400      	movs	r4, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    4cd6:	f3ef 8610 	mrs	r6, PRIMASK
    4cda:	b672      	cpsid	i
	int ret = -EINVAL;
    4cdc:	2016      	movs	r0, #22
    4cde:	4240      	negs	r0, r0
    4ce0:	e009      	b.n	4cf6 <z_abort_timeout+0x26>
			remove_timeout(to);
    4ce2:	0028      	movs	r0, r5
    4ce4:	f7ff ffde 	bl	4ca4 <remove_timeout>
			ret = 0;
    4ce8:	0020      	movs	r0, r4
	if (key != 0U) {
    4cea:	2e00      	cmp	r6, #0
    4cec:	d102      	bne.n	4cf4 <z_abort_timeout+0x24>
	__asm__ volatile(
    4cee:	b662      	cpsie	i
    4cf0:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    4cf4:	2401      	movs	r4, #1
    4cf6:	2c00      	cmp	r4, #0
    4cf8:	d103      	bne.n	4d02 <z_abort_timeout+0x32>
		if (sys_dnode_is_linked(&to->node)) {
    4cfa:	682b      	ldr	r3, [r5, #0]
    4cfc:	2b00      	cmp	r3, #0
    4cfe:	d1f0      	bne.n	4ce2 <z_abort_timeout+0x12>
    4d00:	e7f3      	b.n	4cea <z_abort_timeout+0x1a>
}
    4d02:	bd70      	pop	{r4, r5, r6, pc}

00004d04 <z_get_next_timeout_expiry>:
{
    4d04:	b510      	push	{r4, lr}
	LOCKED(&timeout_lock) {
    4d06:	2300      	movs	r3, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    4d08:	f3ef 8410 	mrs	r4, PRIMASK
    4d0c:	b672      	cpsid	i
	int32_t ret = (int32_t) K_TICKS_FOREVER;
    4d0e:	2001      	movs	r0, #1
    4d10:	4240      	negs	r0, r0
    4d12:	e003      	b.n	4d1c <z_get_next_timeout_expiry+0x18>
	__asm__ volatile(
    4d14:	b662      	cpsie	i
    4d16:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    4d1a:	2301      	movs	r3, #1
    4d1c:	2b00      	cmp	r3, #0
    4d1e:	d104      	bne.n	4d2a <z_get_next_timeout_expiry+0x26>
		ret = next_timeout();
    4d20:	f7fe ff14 	bl	3b4c <next_timeout>
	if (key != 0U) {
    4d24:	2c00      	cmp	r4, #0
    4d26:	d0f5      	beq.n	4d14 <z_get_next_timeout_expiry+0x10>
    4d28:	e7f7      	b.n	4d1a <z_get_next_timeout_expiry+0x16>
}
    4d2a:	bd10      	pop	{r4, pc}

00004d2c <z_set_timeout_expiry>:
{
    4d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4d2e:	0006      	movs	r6, r0
    4d30:	000f      	movs	r7, r1
	LOCKED(&timeout_lock) {
    4d32:	2400      	movs	r4, #0
	__asm__ volatile("mrs %0, PRIMASK;"
    4d34:	f3ef 8510 	mrs	r5, PRIMASK
    4d38:	b672      	cpsid	i
    4d3a:	e00c      	b.n	4d56 <z_set_timeout_expiry+0x2a>
			      || (ticks <= next_to);
    4d3c:	2401      	movs	r4, #1
		bool sooner = (next_to == K_TICKS_FOREVER)
    4d3e:	2301      	movs	r3, #1
    4d40:	401c      	ands	r4, r3
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    4d42:	2801      	cmp	r0, #1
    4d44:	dd01      	ble.n	4d4a <z_set_timeout_expiry+0x1e>
    4d46:	2c00      	cmp	r4, #0
    4d48:	d10f      	bne.n	4d6a <z_set_timeout_expiry+0x3e>
	if (key != 0U) {
    4d4a:	2d00      	cmp	r5, #0
    4d4c:	d102      	bne.n	4d54 <z_set_timeout_expiry+0x28>
	__asm__ volatile(
    4d4e:	b662      	cpsie	i
    4d50:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    4d54:	2401      	movs	r4, #1
    4d56:	2c00      	cmp	r4, #0
    4d58:	d10e      	bne.n	4d78 <z_set_timeout_expiry+0x4c>
		int next_to = next_timeout();
    4d5a:	f7fe fef7 	bl	3b4c <next_timeout>
			      || (ticks <= next_to);
    4d5e:	1c43      	adds	r3, r0, #1
    4d60:	d0ec      	beq.n	4d3c <z_set_timeout_expiry+0x10>
    4d62:	42b0      	cmp	r0, r6
    4d64:	dbeb      	blt.n	4d3e <z_set_timeout_expiry+0x12>
    4d66:	2401      	movs	r4, #1
    4d68:	e7e9      	b.n	4d3e <z_set_timeout_expiry+0x12>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    4d6a:	42b0      	cmp	r0, r6
    4d6c:	dd00      	ble.n	4d70 <z_set_timeout_expiry+0x44>
    4d6e:	0030      	movs	r0, r6
    4d70:	0039      	movs	r1, r7
    4d72:	f7fd fe89 	bl	2a88 <sys_clock_set_timeout>
    4d76:	e7e8      	b.n	4d4a <z_set_timeout_expiry+0x1e>
}
    4d78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00004d7a <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    4d7a:	b510      	push	{r4, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    4d7c:	f7ff f80e 	bl	3d9c <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    4d80:	bd10      	pop	{r4, pc}

00004d82 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
    4d82:	b510      	push	{r4, lr}
	return sys_clock_tick_get();
    4d84:	f7ff f80a 	bl	3d9c <sys_clock_tick_get>
}
    4d88:	bd10      	pop	{r4, pc}

00004d8a <z_impl_k_busy_wait>:
}
#include <syscalls/k_uptime_ticks_mrsh.c>
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
    4d8a:	b510      	push	{r4, lr}
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    4d8c:	2800      	cmp	r0, #0
    4d8e:	d100      	bne.n	4d92 <z_impl_k_busy_wait+0x8>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    4d90:	bd10      	pop	{r4, pc}
	arch_busy_wait(usec_to_wait);
    4d92:	f7fc fd27 	bl	17e4 <arch_busy_wait>
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
    4d96:	e7fb      	b.n	4d90 <z_impl_k_busy_wait+0x6>

00004d98 <z_impl_atomic_cas>:
 * @param new_value value to compare against
 * @return Returns true if <new_value> is written, false otherwise.
 */
bool z_impl_atomic_cas(atomic_t *target, atomic_val_t old_value,
		       atomic_val_t new_value)
{
    4d98:	b510      	push	{r4, lr}
	__asm__ volatile("mrs %0, PRIMASK;"
    4d9a:	f3ef 8310 	mrs	r3, PRIMASK
    4d9e:	b672      	cpsid	i
	k_spinlock_key_t key;
	int ret = false;

	key = k_spin_lock(&lock);

	if (*target == old_value) {
    4da0:	6804      	ldr	r4, [r0, #0]
    4da2:	428c      	cmp	r4, r1
    4da4:	d006      	beq.n	4db4 <z_impl_atomic_cas+0x1c>
	int ret = false;
    4da6:	2000      	movs	r0, #0
	if (key != 0U) {
    4da8:	2b00      	cmp	r3, #0
    4daa:	d102      	bne.n	4db2 <z_impl_atomic_cas+0x1a>
	__asm__ volatile(
    4dac:	b662      	cpsie	i
    4dae:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&lock, key);

	return ret;
}
    4db2:	bd10      	pop	{r4, pc}
		*target = new_value;
    4db4:	6002      	str	r2, [r0, #0]
		ret = true;
    4db6:	2001      	movs	r0, #1
    4db8:	e7f6      	b.n	4da8 <z_impl_atomic_cas+0x10>

00004dba <atomic_get>:
 *
 * @return The value read from <target>
 */
atomic_val_t atomic_get(const atomic_t *target)
{
	return *target;
    4dba:	6800      	ldr	r0, [r0, #0]
}
    4dbc:	4770      	bx	lr

00004dbe <z_impl_atomic_set>:
 * @param value the value to write
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_set(atomic_t *target, atomic_val_t value)
{
    4dbe:	0003      	movs	r3, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    4dc0:	f3ef 8210 	mrs	r2, PRIMASK
    4dc4:	b672      	cpsid	i
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
    4dc6:	6800      	ldr	r0, [r0, #0]
	*target = value;
    4dc8:	6019      	str	r1, [r3, #0]
	if (key != 0U) {
    4dca:	2a00      	cmp	r2, #0
    4dcc:	d102      	bne.n	4dd4 <z_impl_atomic_set+0x16>
	__asm__ volatile(
    4dce:	b662      	cpsie	i
    4dd0:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);

	return ret;
}
    4dd4:	4770      	bx	lr

00004dd6 <z_impl_atomic_or>:
 * @param value the value to OR
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_or(atomic_t *target, atomic_val_t value)
{
    4dd6:	0003      	movs	r3, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    4dd8:	f3ef 8210 	mrs	r2, PRIMASK
    4ddc:	b672      	cpsid	i
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
    4dde:	6800      	ldr	r0, [r0, #0]
	*target |= value;
    4de0:	4301      	orrs	r1, r0
    4de2:	6019      	str	r1, [r3, #0]
	if (key != 0U) {
    4de4:	2a00      	cmp	r2, #0
    4de6:	d102      	bne.n	4dee <z_impl_atomic_or+0x18>
	__asm__ volatile(
    4de8:	b662      	cpsie	i
    4dea:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);

	return ret;
}
    4dee:	4770      	bx	lr

00004df0 <z_impl_atomic_and>:
 * @param value the value to AND
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_and(atomic_t *target, atomic_val_t value)
{
    4df0:	0003      	movs	r3, r0
	__asm__ volatile("mrs %0, PRIMASK;"
    4df2:	f3ef 8210 	mrs	r2, PRIMASK
    4df6:	b672      	cpsid	i
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
    4df8:	6800      	ldr	r0, [r0, #0]
	*target &= value;
    4dfa:	4001      	ands	r1, r0
    4dfc:	6019      	str	r1, [r3, #0]
	if (key != 0U) {
    4dfe:	2a00      	cmp	r2, #0
    4e00:	d102      	bne.n	4e08 <z_impl_atomic_and+0x18>
	__asm__ volatile(
    4e02:	b662      	cpsie	i
    4e04:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);

	return ret;
}
    4e08:	4770      	bx	lr

00004e0a <k_heap_init>:
{
    4e0a:	b510      	push	{r4, lr}
    4e0c:	0003      	movs	r3, r0
    4e0e:	330c      	adds	r3, #12
	list->head = (sys_dnode_t *)list;
    4e10:	60c3      	str	r3, [r0, #12]
	list->tail = (sys_dnode_t *)list;
    4e12:	6103      	str	r3, [r0, #16]
	sys_heap_init(&h->heap, mem, bytes);
    4e14:	f7ff fa02 	bl	421c <sys_heap_init>
}
    4e18:	bd10      	pop	{r4, pc}

00004e1a <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    4e1a:	4770      	bx	lr

00004e1c <z_arm_platform_init>:
	/* Implement z_arm_platform_init() directly in ASM,
	 * and ensure no stack access is performed until
	 * we jump to SystemInit().
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
    4e1c:	4800      	ldr	r0, [pc, #0]	; (4e20 <z_arm_platform_init+0x4>)
	bx r0
    4e1e:	4700      	bx	r0
	ldr r0, =SystemInit
    4e20:	00002bcd 	.word	0x00002bcd
